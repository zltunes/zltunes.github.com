<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>全面的 iOS 客户端网络诊断方案</title>
      <link href="/2019/03/03/ios-network-diagnosis/"/>
      <url>/2019/03/03/ios-network-diagnosis/</url>
      <content type="html"><![CDATA[<p>最近工作中经常遇到需要排查客户端网络状况的场景，例如可能由于某些地区网络运营商的问题，导致客户端某些功能不正常；或者用户自己网络的问题导致无法正常使用我们的后台服务。对此本文提供一套全面的客户端网络诊断方案。<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前的做法非常麻烦：</p><ol><li>用户反馈某一功能异常；</li><li>客服联系该用户；</li><li>客服指导该用户手机上下载网络诊断软件；</li><li>按情况 ping 某域名、traceroute 某域名；</li><li>让用户截图把信息发回来，转交给开发人员分析。</li></ol><p>现在在 App 内集成网络诊断功能，用户只需要点击一次，应用内分析出网络情况生成日志文本，之后可以选择微信分享或者直接上传到开发者后台。</p><iframe height="400" width="598" src="https://player.youku.com/embed/XNDA2OTcwMTYyNA==" frameborder="0" 'allowfullscreen'=""></iframe><h1 id="1-检查本地网络环境信息"><a href="#1-检查本地网络环境信息" class="headerlink" title="1. 检查本地网络环境信息"></a>1. 检查本地网络环境信息</h1><p>检查当前是否联网、联网类型、SIM卡网络运营商等基础信息有两种方法：</p><h2 id="通过-statusBar-的网络-subview"><a href="#通过-statusBar-的网络-subview" class="headerlink" title="通过 statusBar 的网络 subview"></a>通过 statusBar 的网络 subview</h2><p>这种方法的前提是必须保证状态栏不隐藏。</p><pre><code class="objective-c">//网络类型typedef enum {    NETWORK_TYPE_NONE = 0,    NETWORK_TYPE_2G = 1,    NETWORK_TYPE_3G = 2,    NETWORK_TYPE_4G = 3,    NETWORK_TYPE_5G = 4,      NETWORK_TYPE_WIFI = 5,} NETWORK_TYPE;+ (NETWORK_TYPE)getNetworkTypeFromStatusBar{    UIApplication *app = [UIApplication sharedApplication];    NETWORK_TYPE nettype = NETWORK_TYPE_NONE;    //iOS11    if ([[app valueForKeyPath:@&quot;_statusBar&quot;] isKindOfClass:NSClassFromString(@&quot;UIStatusBar_Modern&quot;)]) {        NSArray *views = [[[[app valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews];        for (UIView *view in views) {            for (id child in view.subviews) {                //wifi                if ([child isKindOfClass:NSClassFromString(@&quot;_UIStatusBarWifiSignalView&quot;)]) {                    nettype = NETWORK_TYPE_WIFI;                }                //2G 3G 4G                if ([child isKindOfClass:NSClassFromString(@&quot;_UIStatusBarStringView&quot;)]) {                    if ([[child valueForKey:@&quot;_originalText&quot;] containsString:@&quot;2G&quot;]) {                        nettype = NETWORK_TYPE_2G;                    } else if ([[child valueForKey:@&quot;_originalText&quot;] containsString:@&quot;3G&quot;]) {                        nettype = NETWORK_TYPE_3G;                    } else if ([[child valueForKey:@&quot;_originalText&quot;] containsString:@&quot;4G&quot;]) {                        nettype = NETWORK_TYPE_4G;                    }                }            }        }    } else {        NSArray *subviews = [[[[UIApplication sharedApplication] valueForKey:@&quot;statusBar&quot;]                              valueForKey:@&quot;foregroundView&quot;] subviews];        NSNumber *dataNetworkItemView = nil;        for (id subview in subviews) {            if ([subview isKindOfClass:[NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;) class]]) {                dataNetworkItemView = subview;                break;            }        }        NSNumber *num = [dataNetworkItemView valueForKey:@&quot;dataNetworkType&quot;];        nettype = [num intValue];    }   return nettype;}</code></pre><h2 id="通过-CTTelephonyNetworkInfo"><a href="#通过-CTTelephonyNetworkInfo" class="headerlink" title="通过 CTTelephonyNetworkInfo"></a>通过 CTTelephonyNetworkInfo</h2><p>这个类是 iOS7 以后才出现的，需要导入<a href="https://developer.apple.com/documentation/coretelephony" target="_blank" rel="noopener">CoreTelephony.framework</a>, 用来获取手机的运营商信息和简单的通话信息。</p><pre><code class="Swift">let ctNetworkInfo = CTTelephonyNetworkInfo()    /// 当前蜂窝网络类型    public func cellularType() -&gt; CellularType {        switch  ctNetworkInfo.currentRadioAccessTechnology {        case CTRadioAccessTechnologyEdge, CTRadioAccessTechnologyGPRS, CTRadioAccessTechnologyCDMA1x:            return ._2G        case CTRadioAccessTechnologyHSDPA, CTRadioAccessTechnologyWCDMA, CTRadioAccessTechnologyHSUPA, CTRadioAccessTechnologyCDMAEVDORev0, CTRadioAccessTechnologyCDMAEVDORevA, CTRadioAccessTechnologyCDMAEVDORevB, CTRadioAccessTechnologyeHRPD:            return ._3G        case CTRadioAccessTechnologyLTE:            return ._4G        default:            return .unknow        }    }    /// 移动运营商类型    public func mobileCarrierType() -&gt; CarrierType {        let carrier = ctNetworkInfo.subscriberCellularProvider        guard let MCC = carrier?.mobileCountryCode, let MNC = carrier?.mobileNetworkCode else {            return .unknow        }        switch Int(MCC) {        case 460:            do { //CN                switch Int(MNC) {                case 0, 2, 7, 8:    return .chinaMobile                case 1, 6, 9:       return .chinaUnicom                case 3, 5, 11:      return .chinaTelecom                case 20:            return .chinaTietong                default:            return .unknow                }            }        case 454:            do {//HK                switch Int(MNC) {                case 12, 13:    return .chinaMobileHK                case 7:         return .chinaUnicomHK                default:        return .otherHK                }            }        default: return .unknow        }    }    /// 移动运营商名称    public func mobileCarrierName() -&gt; String {        if let carrier = ctNetworkInfo.subscriberCellularProvider {            if let name = carrier.carrierName {                return name            }        }        return &quot;unknow&quot;    }</code></pre><p>获取系统 WiFi 的相关信息则可以通过系统 sdk 的<code>CaptiveNetwork</code>类：</p><pre><code class="Swift">// MARK: - WIFIextension NetworkDetector {    /// 获取WIFI信息    private func supportedInterfacesNetworkInfo() -&gt; [String: Any]? {        guard let interfaceList = CNCopySupportedInterfaces() as? [String] else {            return nil        }        for interface in interfaceList {            if let networkInfo = CNCopyCurrentNetworkInfo(interface as CFString) as? [String: Any],                let _ = networkInfo[kCNNetworkInfoKeySSID as String] {                return networkInfo            }        }        return nil    }    /// WIFI名称    public func SSID(_ networkInfo: [String: Any]? = nil) -&gt; String? {        if let info = (networkInfo ?? supportedInterfacesNetworkInfo()) {            return info[kCNNetworkInfoKeySSID as String] as? String        }        return nil    }    /// WIFI Mac地址    public func BSSID(_ networkInfo: [String: Any]? = nil) -&gt; String? {        if let info = (networkInfo ?? supportedInterfacesNetworkInfo()) {            return info[kCNNetworkInfoKeyBSSID as String] as? String        }        return nil    }}</code></pre><p>获取 iOS 设备的ip地址，这方面网上文章很多了，<a href="https://blog.csdn.net/luoshengkim/article/details/51135063" target="_blank" rel="noopener">参考这里</a>。</p><h1 id="2-检查后台可用性"><a href="#2-检查后台可用性" class="headerlink" title="2. 检查后台可用性"></a>2. 检查后台可用性</h1><p>这一步主要通过 TCP 连接测试目标地址的可用性与连通性。首先给出域名转ip的方法（支持 ipv4 和 ipv6）。</p><pre><code class="Obj-c">/*! * 通过hostname获取ip列表 DNS解析地址 */+ (NSArray *)getDNSsWithDormain:(NSString *)hostName{    NSMutableArray *result = [[NSMutableArray alloc] init];    NSArray *IPV4DNSs = [self getIPV4DNSWithHostName:hostName];    if (IPV4DNSs &amp;&amp; IPV4DNSs.count &gt; 0) {        [result addObjectsFromArray:IPV4DNSs];    }    //由于在IPV6环境下不能用IPV4的地址进行连接监测    //所以只返回IPV6的服务器DNS地址    NSArray *IPV6DNSs = [self getIPV6DNSWithHostName:hostName];    if (IPV6DNSs &amp;&amp; IPV6DNSs.count &gt; 0) {        [result removeAllObjects];        [result addObjectsFromArray:IPV6DNSs];    }    return [NSArray arrayWithArray:result];}+ (NSArray *)getIPV4DNSWithHostName:(NSString *)hostName{    const char *hostN = [hostName UTF8String];    struct hostent *phot;    @try {        phot = gethostbyname(hostN);    } @catch (NSException *exception) {        return nil;    }    NSMutableArray *result = [[NSMutableArray alloc] init];    int j = 0;    while (phot &amp;&amp; phot-&gt;h_addr_list &amp;&amp; phot-&gt;h_addr_list[j]) {        struct in_addr ip_addr;        memcpy(&amp;ip_addr, phot-&gt;h_addr_list[j], 4);        char ip[20] = {0};        inet_ntop(AF_INET, &amp;ip_addr, ip, sizeof(ip));        NSString *strIPAddress = [NSString stringWithUTF8String:ip];        [result addObject:strIPAddress];        j++;    }    return [NSArray arrayWithArray:result];}+ (NSArray *)getIPV6DNSWithHostName:(NSString *)hostName{    const char *hostN = [hostName UTF8String];    struct hostent *phot;    @try {        /**         * 只有在IPV6的网络下才会有返回值         */        phot = gethostbyname2(hostN, AF_INET6);    } @catch (NSException *exception) {        return nil;    }    NSMutableArray *result = [[NSMutableArray alloc] init];    int j = 0;    while (phot &amp;&amp; phot-&gt;h_addr_list &amp;&amp; phot-&gt;h_addr_list[j]) {        struct in6_addr ip6_addr;        memcpy(&amp;ip6_addr, phot-&gt;h_addr_list[j], sizeof(struct in6_addr));        NSString *strIPAddress = [self formatIPV6Address: ip6_addr];        [result addObject:strIPAddress];        j++;    }    return [NSArray arrayWithArray:result];}</code></pre><p>iOS 实现 socket 编程可以使用<code>CFNetwork</code>, 是基于<code>CFSocket</code>等接口的上层封装，<code>ASIHttpRequest</code>就工作在这一层。不过<code>CFNetwork</code>用起来依旧比较复杂。用的较多的是谷歌封装的一个IM框架<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>, 它给 Mac 和 iOS 提供了易于使用的、强大的异步套接字库，向上封装出简单易用的OC接口。省去了我们面向 Socket 以及数据流 Stream 等繁琐复杂的编程，而且支持TCP或者UDP协议，支持IPv4和IPv6。<br><a href="https://github.com/zltunes/NetworkDetector/blob/master/GCDSocketEngine.swift" target="_blank" rel="noopener">这里</a>提供一个封装好的 Engine 类，调用方实现 protocol 方法即可。另外支持发送心跳包，用于IM、自建推送等长连接场景。</p><h1 id="3-测试长连接"><a href="#3-测试长连接" class="headerlink" title="3. 测试长连接"></a>3. 测试长连接</h1><p>长连接的实现方式，一种是上面的基于 tcp 的长连接，客户端通常用这种。web的场景则有 http keep-alive 和 websocket 两种。</p><h2 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h2><p>长连接需要保持心跳，因为国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断。而国内的运营商一般NAT超时的时间为5分钟，所以通常我们心跳设置的时间间隔为3-5分钟。<br>每次发送心跳包之前记录时间，在回调<code>didRead data:</code>中计算本次心跳包发起到收到的耗时。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><code>keep-alive</code>和<code>webSocket</code>这两种长连接有什么区别呢？<br>在 HTTP1.0 中，一次 TCP 连接只能完成1个 HTTP 请求，一个Request 一个Response, 这次HTTP请求就结束了。HTTP1.1中进行了改进，keep-alive connection 允许<strong>在一次 TCP 连接中完成多个 HTTP 请求</strong>，但因为局限较多，这种仍被称作是<strong>伪.长连接</strong>，原因如下：</p><ol><li>遵循 Request = Response, 在 HTTP 中永远是一一对应的；</li><li>对每个请求仍然要单独发 Header, 信息交换效率很低；</li><li>Response 永远是被动的，不能主动发起。</li></ol><p>传统HTTP客户端与服务器请求响应模式如下图所示：<br><img src="https://mccdn.qcloud.com/static/img/c99efde0caccb49814ea83c126b0e18a/image.jpg" alt=""><br>WebSocket 可以看成是 HTTP 协议为了支持长连接所打的一个大补丁，它借用了HTTP的协议来完成一部分握手，但握手成功后就完全按照Websocket协议进行了，相比 keep-alive 建立的是<strong>真.长连接</strong>：</p><ol><li>通过第一个 HTTP request 建立 TCP 连接之后，之后的交换数据都不需要再发 HTTP request 了，提高信息交换效率；</li><li>被动性。服务端可以主动推送信息给客户端。</li></ol><p>WebSocket模式客户端与服务器请求响应模式如下图：<br><img src="https://mccdn.qcloud.com/static/img/e4128e588c6c21216319351ee7eb0bac/image.jpg" alt=""></p><p>iOS 平台常用的一个 WebSocket 框架<a href="https://github.com/daltoniam/Starscream" target="_blank" rel="noopener">Starscream</a>, 用法与 CocoaAsyncSocket 类似，建立连接后定时向后台写入一段字符串来做心跳检验。</p><h1 id="4-Ping-域名测试"><a href="#4-Ping-域名测试" class="headerlink" title="4. Ping 域名测试"></a>4. Ping 域名测试</h1><p>ping 程序是对两台主机之间<strong>连通性</strong>进行测试的基本工具，基于 ICMP 协议，ICMP 协议定义了一组错误信息，当路由器或者主机无法成功处理一个 IP 封包的时候，能够将错误信息回送给来源主机。<br>苹果官方有封装 ping 功能的库<a href="https://developer.apple.com/library/archive/samplecode/SimplePing/Introduction/Intro.html#//apple_ref/doc/uid/DTS10000716" target="_blank" rel="noopener">SimplePing</a>, 支持 iPv4 和 iPv6。SimplePing 流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/656644-555fbc9fd4a0b461.png?imageMogr2/auto-orient/" alt=""><br>用起来也非常简单：</p><pre><code class="Objc">    // 1. 利用 HostName 创建 SimplePing 对象    SimplePing *pinger = [[SimplePing alloc] initWithHostName:@&quot;www.apple.com&quot;];    self.pinger = pinger;    // 2. 指定 IP 地址类型    if (isIpv4 &amp;&amp; !isIpv6) {        pinger.addressStyle = SimplePingAddressStyleICMPv4;    }else if (isIpv6 &amp;&amp; !isIpv4) {        pinger.addressStyle = SimplePingAddressStyleICMPv6;    }    // 3. 设置 delegate,用于接收回调信息    pinger.delegate = self;    // 4. 开始 ping    [pinger start];</code></pre><p>需要注意的是，<strong>delegate 中的一系列回调方法将在对象调用 start 方法所在的线程对应的 runloop 中以 NSDefaultRunLoopMode 执行</strong>，因此为保证接收到回调我们需要加以下 do…while 代码使 ping 程序在当前线程一直执行。</p><pre><code class="Objc">_sendCount = 1;do {    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];} while (self.pinger != nil || _sendCount &lt;= MAXCOUNT_PING);</code></pre><p>得到最后一个 ping 结果后将 pinger 置为 nil, 或 _sendCount 达到最大值，从而结束 while 循环。</p><pre><code class="Objc">self.pinger = nil;_sendCount = MAXCOUNT_PING + 1;</code></pre><p>提供一个封装好的<a href="https://github.com/zltunes/NetworkDetector/tree/master/NetPing" target="_blank" rel="noopener">NetPing</a>类，通过模拟 shell 命令 ping 的过程，监控目标主机是否连通，并通过解析 ICMP 包，输出每次 ping 的域名ip、数据大小、icmp_seq、time 等信息，从而完整展示 ping 的结果。每个域名连续执行五次，因为每次的速度不一致，可以观察其平均速度来判断网络情况。</p><pre><code class="c">Ping: www.qq.com 64 bytes from 182.254.34.74: icmp_seq=0 type=ICMPv4TypeEchoReply time=22.996 ms64 bytes from 182.254.34.74: icmp_seq=1 type=ICMPv4TypeEchoReply time=36.688 ms64 bytes from 182.254.34.74: icmp_seq=2 type=ICMPv4TypeEchoReply time=25.390 ms64 bytes from 182.254.34.74: icmp_seq=3 type=ICMPv4TypeEchoReply time=25.516 ms64 bytes from 182.254.34.74: icmp_seq=4 type=ICMPv4TypeEchoReply time=28.377 ms</code></pre><p>在发送 ping 数据时为什么初始化一个<code>NSTimer</code>?, 因为如果 ping 失败，也就是发送的测试报文成功，但一直没收到响应的报文，此时却不会有任何的回调方法告知我们，因此加一个 timer 进行<strong>延时判断</strong>。如果3s内无 response 则输出 timeout, 并主动重试（当 ping 次数未超限）。 如果是在 delegate 回调中触发了 <code>sendPing</code>（ping命令发生错误、发送ping数据失败、成功接收到 PingResponse 数据、接收到错误的 PingResponse 数据），则会及时将 timer 关掉。</p><pre><code class="objc">/* * 发送Ping数据，pinger会组装一个ICMP控制报文的数据发送过去 * */- (void)sendPing{    if (timer) {        [timer invalidate];    }    if (_sendCount &gt; MAXCOUNT_PING) {        _sendCount++;        self.pinger = nil;        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(netPingDidEnd)]) {            [self.delegate netPingDidEnd];        }    }    else {        assert(self.pinger != nil);        _sendCount++;        _startTime = [NetTimer getMicroSeconds];        if (_isLargePing) {            NSString *testStr = @&quot;&quot;;            for (int i=0; i&lt;408; i++) {                testStr = [testStr stringByAppendingString:@&quot;abcdefghi &quot;];            }            testStr = [testStr stringByAppendingString:@&quot;abcdefgh&quot;];            NSData *data = [testStr dataUsingEncoding:NSASCIIStringEncoding];            [self.pinger sendPingWithData:data];        } else {            [self.pinger sendPingWithData:nil];        }        timer = [NSTimer scheduledTimerWithTimeInterval:3.0                                                 target:self                                               selector:@selector(pingTimeout:)                                               userInfo:[NSNumber numberWithInt:_sendCount]                                                repeats:NO];    }}- (void)pingTimeout:(NSTimer *)index{    if ([[index userInfo] intValue] == _sendCount &amp;&amp; _sendCount &lt;= MAXCOUNT_PING + 1 &amp;&amp;        _sendCount &gt; 1) {        NSString *timeoutLog =            [NSString stringWithFormat:@&quot;ping: cannot resolve %@: TimeOut&quot;, _hostAddress];        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(appendPingLog:)]) {            [self.delegate appendPingLog:timeoutLog];        }        [self sendPing];    }}</code></pre><h1 id="5-Traceroute-测试"><a href="#5-Traceroute-测试" class="headerlink" title="5. Traceroute 测试"></a>5. Traceroute 测试</h1><p>与 Ping 一样，Traceroute 也是基于 ICMP 协议的常规网络分析工具。数据从主机发送到目标服务器要经过层层路由转发，Traceroute 用来侦测到目的主机之间所经路由。带 -R 参数的 ping 命令也可以记录路由过程，但是因为 IP 数据报头的长度限制(最多能保存9个IP地址)，ping 不能完全的记录下所经过的路由器，traceroute 正好就填补了这个缺憾。工作原理很简单：</p><ol><li>发送一份 TTL == 1 的 IP 数据报给目的主机，经过第一个路由器时，TTL 值被减为 0，则第一个路由器丢弃该数据报，并返回一份 <strong>ICMP超时报文</strong>，于此得到了路径中第一个路由器的地址；</li><li>再发送一份 TTL 值为 2 的数据报，便可得到第二个路由器的地址；</li><li>以此类推，一直到到达目的主机为止，这样便记录下了路径上所有的路由 IP。</li></ol><h2 id="基于-UDP-实现"><a href="#基于-UDP-实现" class="headerlink" title="基于 UDP 实现"></a>基于 UDP 实现</h2><p>我们如何知道数据报何时到达目的主机呢？在基于UDP的方案中，traceroute 使用了一个大于30000的端口号，服务器在收到这个数据包的时候会返回一个<strong>端口不可达</strong>的ICMP错误信息，客户端通过判断收到的错误信息是TTL超时还是端口不可达来判断数据包是否到达目标主机。Linux 和 MacOS 平台上的 traceroute 都是基于该原理实现的。然而使用过程中会发现这种方法并不太靠谱。TTL增加到一定大小后就拿不到返回的数据包了，也无法知道什么时候到达目的主机。<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1g0ng36vh5xj30wi0kagn1.jpg" alt=""><br>原因可以看下<a href="https://www.cnblogs.com/beyond_dxb/p/8383821.html" target="_blank" rel="noopener">这篇文章</a>的分析：</p><blockquote><p>使用 UDP 的 traceroute，失败还是比较常见的。这常常是由于，在运营商的路由器上，UDP与ICMP的待遇大不相同。为了利于troubleshooting，ICMP ECHO Request/Reply 是不会封的，而UDP则不同。UDP常被用来做网络攻击，因为UDP无需连接，因而没有任何状态约束它，比较方便攻击者伪造源IP、伪造目的端口发送任意多的UDP包，长度自定义。所以运营商为安全考虑，对于UDP端口常常采用白名单ACL，就是只有ACL允许的端口才可以通过，没有明确允许的则统统丢弃。比如允许DNS/DHCP/SNMP等。</p></blockquote><p>目前网上许多开源的iOS traceroute库基本都是UDP的方案，使用起来并不靠谱，为此实现一套基于 ICMP 的方案。</p><h2 id="基于-ICMP-实现"><a href="#基于-ICMP-实现" class="headerlink" title="基于 ICMP 实现"></a>基于 ICMP 实现</h2><p>详细代码见<a href="https://github.com/zltunes/NetworkDetector/tree/master/Traceroute" target="_blank" rel="noopener">这里</a>。整体流程如下：</p><pre><code class="c">// 1. 创建套接字int send_sock = socket(remoteAddr-&gt;sa_family, SOCK_DGRAM, isIPv6 ? IPPROTO_ICMPV6 : IPPROTO_ICMP);// 2. 最多尝试30跳int ttl = 1;bool finished = false; // 是否抵达目标主机while(ttl &lt;= 30 &amp;&amp; !finished) {    // 3. 设置TTL，下一跳TTL递增    setsockopt(sock, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl));    ++ttl;    // 4. 构建icmp报文    packetData = makeICMPPacket(...);    // 5. 连续发送3个ICMP报文，记录往返时长    for (0...3) {        // 6. 发送icmp报文        sendto(...);        // 7. 接收icmp数据        ssize_t resultLen = recvfrom(...);        if (resultLen &gt;= 0) {            // 8. 解析数据包            ICMPPacket *packet = unpack(...);            if (icmp_timeout) {                // 到达中间节点            } else if (icmp_EchoReply &amp;&amp; ip == 目标主机ip) {                // 到达目标服务器，traceroute 结束            } else {                // 失败            }        }    }}</code></pre><p>从伪代码看出，关键在于如何创建和发送ICMP数据，以及如何从接收到的ip数据包中解析ICMP。</p><h3 id="ICMP-数据创建"><a href="#ICMP-数据创建" class="headerlink" title="ICMP 数据创建"></a>ICMP 数据创建</h3><p><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1g0ni5cyvx2j320s0kqjzi.jpg" alt=""><br>图为<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">ICMP数据结构</a>，据此定义 ICMPPacket 数据结构：</p><pre><code class="c">typedef struct ICMPPacket {    uint8_t     type; // 类型    uint8_t     code; // 类型代码    uint16_t    checksum; // 校验码    uint16_t    identifier; // ID    uint16_t    sequenceNumber; // 序列号    // data...} ICMPPacket;</code></pre><p>ICMPv4TypeEchoRequest 类型=8，代码=0，创建好 ICMP 报文直接发送就可以了，系统会自动加上IP头部。</p><h3 id="ICMP-数据解析"><a href="#ICMP-数据解析" class="headerlink" title="ICMP 数据解析"></a>ICMP 数据解析</h3><p><img src="https://ww1.sinaimg.cn/large/007iUjdily1g0nih9sjz1j31ja0v0dpf.jpg" alt=""></p><pre><code class="c">typedef struct IPv4Header {    uint8_t versionAndHeaderLength; // 版本和首部长度    uint8_t serviceType;    uint16_t totalLength;     uint16_t identifier;    uint16_t flagsAndFragmentOffset;    uint8_t timeToLive;    uint8_t protocol; // 协议类型，1表示ICMP    uint16_t checksum;    uint8_t sourceAddress[4];    uint8_t destAddress[4];    // options...    // data...} IPv4Header;</code></pre><p>根据ip数据包结构的关键字段，我们可以获取到 ICMP 数据包，再根据上面的<code>类型</code>字段判断是<code>CMPv4TypeTimeOut</code>(11) 还是<br><code>ICMPv4TypeEchoReply</code>(0)，从而得知当前所处路由位置。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>以 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 为例，比较两种方案的 traceroute 结果，<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1g0niyv0o02j314u0uujxk.jpg" alt=""><br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1g0niy2cnrmj315o0o6dm0.jpg" alt=""><br>UDP 方案从ttl==13之后都不再收到服务器返回，也无法得知什么时候到达baidu, ICMP 则完整地输出路由表。<br>两种方案都会出现某一跳显示星号的情况，代表那一跳路由器隐藏了自己位置。并不是所有网关都会如实返回ICMP超时报文。出于安全性考虑，大多数防火墙以及启用了防火墙功能的路由器缺省配置为<strong>不返回各种ICMP报文</strong>，因此traceroute程序不一定能拿到所有的沿途网关地址。<br>总结一下：</p><ol><li>UDP模式：UDP探测数据包（目标端口大于30000） -&gt; 中间网关发回 ICMP TTL Timout -&gt; 目标主机发回 ICMP Destination Unreachable</li><li>ICMP模式：ICMPEchoRequest 探测数据包 -&gt; 中间网关发回 ICMP TTL Timout -&gt; 目标主机发回 ICMPEchoReply </li></ol><h1 id="6-文件下载测试"><a href="#6-文件下载测试" class="headerlink" title="6. 文件下载测试"></a>6. 文件下载测试</h1><p><a href="https://github.com/zltunes/NetworkDetector/blob/master/SimpleDownloadEngine.swift" target="_blank" rel="noopener">这里</a>提供一个基于 URLSession 实现的简单的下载器，在下载成功的回调中计算文件下载速度，网上相关教程很多，不赘述了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，开发者诊断 iOS APP 网络状况所需要的功能基本都包括了，该工具目前集成在<a href="https://itunes.apple.com/cn/app/id1437741103?mt=8" target="_blank" rel="noopener">TAiQ</a>客户端，协助排查<a href="https://taiq.qq.com/" target="_blank" rel="noopener">王者荣耀智能机器人</a>联网问题。完整诊断结果如下：</p><pre><code class="c">Step1:-------------&gt; 检查当前网络 &lt;---------------当前是否联网：已联网当前联网类型：wifiSSID：Tencent-StaffWiFi当前本机IP: 10.70.75.98本地网关: fe80:c::本地DNS: 10.11.10.12, 10.6.210.85, 10.14.12.239Step2:-------------&gt; 检查后台可用性 &lt;---------------Server: nggws.starrobot.3g.qq.com,port:443isConnected: true, isAvailable: trueServer: nggws.starrobot.3g.qq.com,port:80isConnected: true, isAvailable: true域名转IP: 14.17.41.219Server: nggws.robot.3g.qq.com,port:443isConnected: true, isAvailable: trueServer: nggws.robot.3g.qq.com,port:80isConnected: true, isAvailable: true域名转IP: 183.61.51.41Server: qdtts.3g.qq.com,port:443isConnected: true, isAvailable: trueServer: qdtts.3g.qq.com,port:80isConnected: true, isAvailable: true域名转IP: 58.60.9.100Server: yingyongbao.soundai.cn,port:443isConnected: true, isAvailable: true域名转IP: 182.61.53.149Step3:-------------&gt; TestWebSocket &lt;---------------wss://nggws.starrobot.3g.qq.com:443, 连接成功心跳包[1]发起到收到耗时：10ms心跳包[2]发起到收到耗时：25ms心跳包[3]发起到收到耗时：12msws://nggws.starrobot.3g.qq.com:80, 连接成功心跳包[1]发起到收到耗时：17ms心跳包[2]发起到收到耗时：16ms心跳包[3]发起到收到耗时：11mswss://nggws.robot.3g.qq.com:443, 连接成功心跳包[1]发起到收到耗时：14ms心跳包[2]发起到收到耗时：13ms心跳包[3]发起到收到耗时：15msws://nggws.robot.3g.qq.com:80, 连接成功心跳包[1]发起到收到耗时：11ms心跳包[2]发起到收到耗时：13ms心跳包[3]发起到收到耗时：18msStep4:---------------&gt; PING域名测试 &lt;---------------PING: [    nggws.starrobot.3g.qq.com    ]64 bytes from 14.17.41.219 icmp_seq=#0 time=14ms64 bytes from 14.17.41.219 icmp_seq=#1 time=5ms64 bytes from 14.17.41.219 icmp_seq=#2 time=14ms64 bytes from 14.17.41.219 icmp_seq=#3 time=4ms64 bytes from 14.17.41.219 icmp_seq=#4 time=8msPING: [    nggws.robot.3g.qq.com    ]64 bytes from 183.61.51.41 icmp_seq=#0 time=11ms64 bytes from 183.61.51.41 icmp_seq=#1 time=7ms64 bytes from 183.61.51.41 icmp_seq=#2 time=10ms64 bytes from 183.61.51.41 icmp_seq=#3 time=12ms64 bytes from 183.61.51.41 icmp_seq=#4 time=11msPING: [    qdtts.3g.qq.com    ]64 bytes from 58.60.9.100 icmp_seq=#0 time=7ms64 bytes from 58.60.9.100 icmp_seq=#1 time=8ms64 bytes from 58.60.9.100 icmp_seq=#2 time=5ms64 bytes from 58.60.9.100 icmp_seq=#3 time=9ms64 bytes from 58.60.9.100 icmp_seq=#4 time=6msPING: [    yingyongbao.soundai.cn    ]64 bytes from 182.61.53.149 icmp_seq=#0 time=13ms64 bytes from 182.61.53.149 icmp_seq=#1 time=18ms64 bytes from 182.61.53.149 icmp_seq=#2 time=17ms64 bytes from 182.61.53.149 icmp_seq=#3 time=16ms64 bytes from 182.61.53.149 icmp_seq=#4 time=18msPING: [    www.baidu.com    ]64 bytes from 14.215.177.39 icmp_seq=#0 time=11ms64 bytes from 14.215.177.39 icmp_seq=#1 time=9ms64 bytes from 14.215.177.39 icmp_seq=#2 time=11ms64 bytes from 14.215.177.39 icmp_seq=#3 time=16ms64 bytes from 14.215.177.39 icmp_seq=#4 time=10msStep5:---------------&gt; traceroute 测试 &lt;---------------开始traceroute...1    10.70.75.2        5.86ms    3.17ms    8.69ms    2    10.14.61.41        3.94ms    7.24ms    5.30ms    3    10.14.60.30        9.65ms    2.92ms    9.28ms    4    10.14.61.60        3.01ms    3.72ms    6.01ms    5    14.17.22.1        6.59ms    9.81ms    4.17ms    6    10.200.102.1        4.57ms    4.17ms    6.41ms    7    ********    -----ms    -----ms    -----ms    8    14.17.0.97        14.05ms    8.24ms    5.05ms    9    119.147.220.157        9.93ms    5.11ms    4.47ms    10    113.96.4.118        18.49ms    14.68ms    9.45ms    11    219.135.96.86        58.19ms    -----ms    22.62ms    12    14.29.117.238        12.20ms    8.35ms    -----ms    13    ********    -----ms    -----ms    -----ms    14    14.215.177.38        10.80ms    7.38ms    8.88ms    Step6.1:--------&gt; 文件下载测试[http] &lt;--------下载成功：19KB, 速度：54.11KB/S, 总耗时：356msStep6.2:--------&gt; 文件下载测试[https] &lt;--------下载成功：19KB, 速度：47.33KB/S, 总耗时：407msStep7:----&gt; 网络诊断结束，点[复制]按钮发送给客服，谢谢 &lt;----</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DynamicCard - 基于 FlexBoxLayout 的动态排版渲染引擎</title>
      <link href="/2019/02/02/dynamiccard/"/>
      <url>/2019/02/02/dynamiccard/</url>
      <content type="html"><![CDATA[<p>客户端开发一直存在的一个主要矛盾是产品运营日益增长的快速迭代需要同应用市场严格的审核上架周期之间的矛盾。为应对这一矛盾各种客户端动态化的方案层出不穷。本文介绍一种我们团队自研的基于 FlexBox 和 Yoga 的动态排版框架( for iOS )，可在线上调整页面样式，同时对新增卡片类型可做到无需跟版本实时更新。<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>App Store 新应用上架和版本更新必经的人工审核一直让急性子的中国开发者头疼，虽然目前已经大大缩减了审核周期（通常前一天晚上提审，次日上午即可得到结果），但遇到重大 bug 急需修复，或者仅仅是想改动某个 label 的样式，想在某个地方加个 button 都要重新开发和提审的话显然是不现实的。另一方面现在的 APP 页面样式五花八门，以常见的 feeds 流为例：<br><img src="https://ww1.sinaimg.cn/large/007iUjdily1fxhukh0quej31k10u07wj" alt=""><br>一个 tableview 常常由文字+图片+视频随机排列组合形成多种样式的 cell, 如果按照传统的方法每新增一种样式就新建一个类继承 <code>UITableViewCell</code>, 非常低效和复杂。这种场景页面的动态化也是刚需。<br>一个成熟的UI排版渲染引擎至少需要解决以下问题：</p><ol><li>提升开发效率。</li><li>新增和修改 Feed 样式不需要跟版本。</li><li>列表的滑动流畅不应受影响。</li><li>允许扩展自定义样式。</li></ol><p>业内终端动态化最著名的两个框架是 ReactNative 和 weex，两个框架的好处是代码复用和跨平台，但带来的问题就是对开发人员的要求挺高的，不仅要懂 js/react/vue, 还要懂安卓和 iOS 开发；对工程的侵入性很大，很多开发人员<a href="https://juejin.im/post/5b2a5368f265da595c0cf6d5" target="_blank" rel="noopener">对 React Native 的缺陷诟病已久</a>。其实如果团队内不是所有人都熟悉js的话，很自然的想法是退而求其次，不必下发 jsBundle，<strong>通过后台下发 json/xml 配置文件，终端去解析并在 APP 上生成真实布局</strong>。这就是 DynamicCard 实现动态化的核心。DynamicCard 先后应用于<a href="https://www.zhihu.com/question/266485668" target="_blank" rel="noopener">立知</a>、<a href="https://itunes.apple.com/cn/app/%E9%85%B1%E6%B2%B9-%E6%B8%B8%E6%88%8F%E7%A4%BE%E5%8C%BA/id1439301792?mt=8" target="_blank" rel="noopener">酱油</a>两个项目的大部分页面。先来看看用起来是怎么样的。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先需要一个排版描述（layoutDic, 限于篇幅，子卡只给出 10002）：</p><pre><code class="JSON">&quot;1007&quot;: {    &quot;cardID&quot;: 1007,    &quot;version&quot;: 1,    &quot;minFrameworkVersion&quot;: 1,    &quot;desc&quot;: &quot;内容视频卡&quot;,    &quot;flex_direction&quot;: &quot;column&quot;,    &quot;subviews&quot;: [{            &quot;margin&quot;: [16, 28, 16, 0],            &quot;subCardID&quot;: &quot;10001&quot;,            &quot;is_clickable&quot;: 1,            &quot;name&quot;: &quot;userSubCard&quot;,            &quot;type&quot;: &quot;UISubCardView&quot;        },        {            &quot;margin&quot;: [16, 10, 16, 0],            &quot;type&quot;: &quot;UILabel&quot;,                  &quot;name&quot;: &quot;content&quot;,            &quot;font_size&quot;: 14,            &quot;lines&quot;: 0,            &quot;font_color&quot;: &quot;#222222&quot;,            &quot;font_name&quot;: &quot;PingFangSC-Regular&quot;,            &quot;line_height&quot;: 24,            &quot;letter_space&quot;: 0.7,            &quot;text&quot;: &quot;content_text&quot;        },        {            &quot;margin&quot;: [16, 16, 16, 0],            &quot;type&quot;: &quot;UIVideoView&quot;,            &quot;name&quot;: &quot;video&quot;,            &quot;video_url&quot;: &quot;video_url&quot;,            &quot;video_cover&quot;: &quot;video_cover&quot;,            &quot;video_width&quot;: &quot;video_width&quot;,            &quot;video_height&quot;: &quot;video_height&quot;,            &quot;video_auotoPlay&quot;: &quot;video_auotoPlay&quot;,            &quot;video_showMute&quot;: &quot;video_showMute&quot;,            &quot;corner_radius&quot;: 8,            &quot;background_color&quot;: &quot;#ffffff&quot;        },        {            &quot;margin&quot;: [16, 12, 0, 0],            &quot;subCardID&quot;: &quot;10004&quot;,            &quot;name&quot;: &quot;gameSubCard&quot;,            &quot;type&quot;: &quot;UISubCardView&quot;        },        {            &quot;margin&quot;: [16, 12, 0, 24],            &quot;subCardID&quot;: &quot;10002&quot;,            &quot;name&quot;: &quot;actionSubCard&quot;,            &quot;type&quot;: &quot;UISubCardView&quot;        }    ]}&quot;10002&quot;: {    &quot;cardID&quot;: 10002,    &quot;version&quot;: 1,    &quot;minFrameworkVersion&quot;: 1,    &quot;desc&quot;: &quot;内容卡的操作子卡（点赞评论）&quot;,    &quot;flex_direction&quot;: &quot;row&quot;,    &quot;align_items&quot;: &quot;alignStart&quot;,    &quot;subviews&quot;: [{            &quot;margin&quot;: [0, 0, 0, 0],            &quot;size&quot;: [76, 24],            &quot;type&quot;: &quot;UIVirtualView&quot;,            &quot;flex_direction&quot;: &quot;row&quot;,            &quot;align_items&quot;: &quot;alignStart&quot;,            &quot;subviews&quot;: [{                &quot;margin&quot;: [0, 0, 0, 0],                &quot;size&quot;: [0, 24],                &quot;type&quot;: &quot;UIButton&quot;,                &quot;font_color&quot;: &quot;#777575&quot;,                &quot;font_color_selected&quot;: &quot;#777575&quot;,                &quot;font_size&quot;: 12,                &quot;name&quot;: &quot;like&quot;,                &quot;status&quot;: &quot;like_status&quot;,                &quot;font_name&quot;: &quot;PingFangSC-Light&quot;,                &quot;image_url&quot;: &quot;like_picture&quot;,                &quot;direction&quot;: &quot;left&quot;,                &quot;horizontal_alignment&quot;: &quot;left&quot;,                &quot;content_edge_insets&quot;: [5.3, 3.5, 5.3, 3.5],                &quot;compound_drawable_padding&quot;: 8.7,                &quot;title&quot;: &quot;like_count&quot;,                &quot;action&quot;: &quot;like_event&quot;            }]        },        {            &quot;margin&quot;: [0, 0, 0, 0],            &quot;size&quot;: [76, 24],            &quot;type&quot;: &quot;UIVirtualView&quot;,            &quot;flex_direction&quot;: &quot;row&quot;,            &quot;align_items&quot;: &quot;alignStart&quot;,            &quot;subviews&quot;: [{                &quot;margin&quot;: [0, 0, 0, 0],                &quot;size&quot;: [0, 24],                &quot;type&quot;: &quot;UIButton&quot;,                &quot;font_color&quot;: &quot;#777575&quot;,                &quot;font_color_selected&quot;: &quot;#777575&quot;,                &quot;font_size&quot;: 12,                &quot;name&quot;: &quot;comment&quot;,                &quot;font_name&quot;: &quot;PingFangSC-Light&quot;,                &quot;image_url&quot;: &quot;comment_picture&quot;,                &quot;direction&quot;: &quot;left&quot;,                &quot;horizontal_alignment&quot;: &quot;left&quot;,                &quot;content_edge_insets&quot;: [5.3, 3.5, 5.3, 3.5],                &quot;compound_drawable_padding&quot;: 8.7,                &quot;title&quot;: &quot;comment_count&quot;,                &quot;action&quot;: &quot;comment_event&quot;            }]        }    ]}</code></pre><p>接着需要一个业务数据描述（dataDic）</p><pre><code class="JSON">{    &quot;card_id&quot;:1007,    &quot;user_icon&quot;:&quot;http://img.jystatic.com/expmepic/2018/07/20/44b83ff79eaaba7a89247a6046b2dc4a_1532092212.png&quot;,    &quot;user_name&quot;:&quot;抽筋八骨&quot;,    &quot;user_id&quot;:&quot;108395&quot;,    &quot;user_levelImage&quot;:&quot;https://img.jystatic.com/expmepic/20180816/w3.png&quot;,    &quot;user_event&quot;:&quot;JumpUserDetailPage&quot;,    &quot;time_text&quot;:&quot;7月26日&quot;,    &quot;follow_event&quot;:&quot;FollowEvent&quot;,    &quot;follow_name&quot;:&quot;关注|已关注&quot;,    &quot;follow_status&quot;:0,    &quot;content_id&quot;:&quot;post_108395_1532592117598&quot;,    &quot;content_text&quot;:&quot;今天推荐一款船新的音乐游戏polytone，感觉自己化身DJ在打碟&quot;,    &quot;video_cover&quot;:&quot;https://img.jystatic.com/expmepic/2018/09/19/800efe4c5ae4dd82414a9ec6060190ee_1532590303.1.png&quot;,    &quot;video_width&quot;:1920,    &quot;video_url&quot;:&quot;http://video2.jystatic.com/shg_1110_50003_d7459ef7730a4fa78c37976431c2cd2d.f501.mp4?dis_k=1043e9edde940a512d19a2f4432c6767&amp;dis_t=1546874077&quot;,    &quot;video_duration&quot;:34,    &quot;video_height&quot;:1080,    &quot;app_icon&quot;:&quot;https://img.jystatic.com/expmepic/2018/07/25/21abecdd40f93c1987fe8f27fd691316_1532504772830148299.png&quot;,    &quot;app_name&quot;:&quot;polytone&quot;,    &quot;app_event&quot;:&quot;JumpGameDetailPage&quot;,    &quot;like_event&quot;:&quot;LikeEvent&quot;,    &quot;like_status&quot;:0,    &quot;like_count&quot;:403,    &quot;like_picture&quot;:&quot;icon_like_normal.png|icon_like_highlight.png&quot;,    &quot;comment_count&quot;:43,    &quot;comment_picture&quot;:&quot;icon_comment.png&quot;,    &quot;comment_event&quot;:&quot;JumpCommentsPage&quot;}</code></pre><p>以上排版数据的结果如下：<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyyfa7rwuxj30ie0jyaid.jpg" alt=""><br>看到这个demo，大家应该知道 DynamicCard 是什么东西了，上面的 JSON 文件阅读起来也非常自然、直接。接下来要解决的问题比较多。这里重点描述<strong>布局与事件处理、重用、扩展</strong>。分别解决 <strong>UI 在线调整、性能优化、功能扩充</strong>三个方面的问题。</p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="v0-AutoLayout"><a href="#v0-AutoLayout" class="headerlink" title="v0. AutoLayout"></a>v0. AutoLayout</h2><p>第一版我们采用了 autolayout 布局，对于每个控件由四个数组控制决定它的约束：</p><blockquote><p>margin、marginView、marginDirection、size</p></blockquote><p>View 层使用<a href="https://objccn.io/issue-5-1/" target="_blank" rel="noopener">TextKit</a>实现图文混排，这样不必再关心控件具体是 <code>UILabel</code>, 还是<code>UITextView</code>、<code>UIImageView</code>等，统一抽象到一个三层架构中进行渲染：<code>NSTextStorage</code>管理文本内容和属性，<code>NSLayoutManager</code>从<code>NSTextStorage</code>对象中取得文本后进行排版，然后把排版之后的文本放到<code>NSTextContainer</code>对象指定的区域上。最后再由一个文本控件从<code>NSTextContainer</code>中取出内容显示到屏幕中。<br><img src="https://objccn.io/images/issues/issue-5/TextKit.png" alt=""><br>很快发现由于每个控件都用四个数组才能确定位置，随着卡片样式的丰富，布局字典过于复杂，反而拖累了开发效率，亟需新的布局引擎。</p><h2 id="v1-FlexBoxLayout"><a href="#v1-FlexBoxLayout" class="headerlink" title="v1. FlexBoxLayout"></a>v1. FlexBoxLayout</h2><p>这里要感谢<a href="https://lpd-ios.github.io/" target="_blank" rel="noopener">饿了么团队</a>的两篇博文<a href="https://lpd-ios.github.io/2017/04/05/FlexBox-Weex/" target="_blank" rel="noopener">《由 FlexBox 算法强力驱动的 Weex 布局引擎》</a>、<a href="https://lpd-ios.github.io/2017/02/12/Flexbox-CSSLayout/" target="_blank" rel="noopener">《iOS Flexbox 布局优化》</a>，带我们找到了非常适合当下场景的<strong>基于 Yoga 引擎的 Flexbox 布局方案 —— <a href="https://github.com/carlSQ/FlexBoxLayout" target="_blank" rel="noopener">FlexBoxLayout</a></strong>，不了解<code>Yoga</code>和<code>FlexBox</code>的话可以阅读那两篇文章。总之它使得我们可以像安卓开发中 XML 使用五大布局定义视图一样实现 iOS 界面布局，从开头 demo 的 layoutDic 可以看出。</p><p>DynamicCard 框架整体设计为 MVVM 架构，每张卡片分配唯一的一个<code>cardID</code>, 代表一种样式。定义<code>CardView</code>作为卡片根容器，用<code>CardModel</code>进行初始化。<code>subViews</code>为该卡片的所有字view，定义基类<code>ViewModel</code>管理 view 的一些基础属性如<code>background_color</code>, <code>corner_radius</code>, <code>border_width</code>, <code>visibility</code> 等，之后我们用工厂方法创建每种具体 view 所绑定的 <code>viewModel</code>，如：</p><table><thead><tr><th>view</th><th>viewModel</th></tr></thead><tbody><tr><td>DCLabel</td><td>DCLabelModel</td></tr><tr><td>DCButton</td><td>DCButtonModel</td></tr><tr><td>DCImageView</td><td>DCImageModel</td></tr><tr><td>DCVideoView</td><td>DCVideoModel</td></tr></tbody></table><p><code>ViewModel</code>用来绑定 view 和 data，以及管理数据的更新。框架的工作原理如下图，对一张卡片的渲染大致分三个流程：</p><ol><li>从统一后台（或者本地缓存）拉取布局字典，从业务后台获取数据字典；</li><li>根据 layoutMap + dataMap 生成所需要的 viewModels 及 cardModel，完成 view-viewModel 的数据绑定；</li><li>使用 FlexBoxLayout 进行布局，最终将卡片展示在屏幕上。</li></ol><p><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyzaxbruuxj31hx0u04qp.jpg" alt=""><br>为提升开发效率我们作了两点优化：</p><ol><li>支持子卡, 对应 viewModel <code>SubCardViewModel</code>, 便于组合复用一些模板卡片，如demo 10001,10002,10004 卡;</li><li>支持虚拟视图，对应 viewModel <code>DCVirtualNodeModel</code>,  避免为实现 FlexBox 布局而创建无用 view 占内存。</li></ol><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>每个<code>viewModel</code>除了<code>layoutDic</code>和<code>dataDic</code>外，还有一个<code>actionModel</code>，通过<code>action</code>字段下发对应的点击事件。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>本地统一管理一个路由事件表，事件分为两类：</p><ol><li>跳转事件。<br><em>eg. [“JumpCommentsPage” : “jyp://open?page=CommentDetailViewController”]</em></li><li>自定义事件。<br><em>eg. [“LikeEvent” : “jyp://open?target=ButtonService&amp;&amp;action=onLikeButtonClick:”]</em></li></ol><p>后台为某个 view 的 action 赋值后，本地路由去匹配完整的伪协议链接，根据格式判断是跳转还是点击，注意两种事件都是将所需参数注入<code>dataDic</code>传给路由。 如果是跳转事件很好处理；自定义事件我们则需要让<code>viewModel</code>实时响应其数据变化，与其相关联的其他<code>viewModel</code>也要及时刷新。 </p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>前面讲到 DynamicCard 使用 MVVM 架构，自然是需要 viewModel 监听 model 的属性变化，再控制 view 去刷新UI。图示为 model 层，单例<code>modelManager</code>将维护一个<code>modelList</code>，这里有个前提是 id 之间不能有重复。<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyzk0e1xj3j313k0u078c.jpg" alt=""><br>以 demo 卡片为例，dataDic 存在 userId、contentId，初始化该卡片<code>cardModel</code>时新建<code>userModel</code>及<code>contentModel</code>插入 modelList, 并为二者添加观察者<code>cardModel</code>，<code>cardModel</code>实现<code>observeValueForKeyPath:</code>. 用户点赞后，<code>modelManager</code>更新该卡片 <code>contentModel</code>, 观察者<code>cardModel</code>更新<code>like_status</code>、<code>like_count</code>值后，刷新对应的 subView.<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fyzl8bus1oj30wm0u0k7y.jpg" alt=""><br>注意如果app内其它地方卡片2也有该 feed（同一 contentId），则不需新建 contentModel, 将卡片2添加到观察者列表中，在卡片1点赞，卡片2也会实时响应刷新。</p><h1 id="重用"><a href="#重用" class="headerlink" title="重用"></a>重用</h1><p>重用是 DynamicCard 在设计之初就重点考虑的一个因素，也是不同于其他引擎的最大的特色。例如 React Native 很大的一个缺陷就是不支持 cell 重用，原因：</p><blockquote><ol><li>UITableView 是主线程同步的，为了保证 UI 流畅度，UI 的渲染需要达到60帧/秒，每帧的大致消耗时间保持在16ms之内；</li><li>React Native 运行在单独线程，和UI主线程不同步，也就是从 RN Render 到真正调用 native 代码这个过程是异步的，导致从js运行到最后系统渲染的总时间很难做到&lt;16ms.</li></ol></blockquote><p>可以说有了<strong>重用</strong>这个特性，DynamicCard 才能应用在列表等有高性能要求的场景。重用指的是，在 UITableView 滑动的时候，不同列表项复用同一个 Cell，Cell 里面的视图数据可以重复使用，核心是为了减少创建视图和修改视图树的次数。<code>FlexBoxLayout</code>提供了 UITableView 的一个 category: <code>UITableView+FBLayout</code>, <strong>支持自动高度、布局缓存，contentView 缓存，和自动 cache 失效机制。</strong> 简单分析下实现方式。<br>为每个<code>UITableView</code>提供两种缓存方案：contentView 缓存 和布局缓存（可选）。对外提供 cell view 的构建block, 展示某行 cell 时，先查看 contentView 是否有缓存（以 indexPath 索引），如果有直接返回缓存。没有的话通过 block 获取 view，然后查找 layout 缓存，如果命中直接<code>applyLayoutCache</code>设置 frame，否则<code>applyWithSize</code>计算 frame. 至此 cell 样式确定，然后根据需要可将 layout 或者 contentView 添加到缓存中。<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fz0gk0y13cj31ba0u0wln.jpg" alt=""><br>我们进一步封装一个<code>DyCardTableViewController</code>, 提供数据源<code>dataList</code>, 即后台返回的 dataDic 数组。</p><pre><code class="Swift">lazy var dataList = [[String: Any]]()</code></pre><p>创建 tableView 并提供<code>fb_setCellContnetViewBlock</code>实现：</p><pre><code class="Swift">tableView.fb_setCellContnetViewBlock(forIndexPath: { [weak self] indexPath -&gt; UIView in    guard let data = self?.dataList[indexPath.row],        let cardID = data[DyCardDataKey.cardID] as? String,        let layoutDic = DCLayoutEngine.shared.getLayoutDicByCardId(cardID) else {            return DCCardView(frame: .zero)    }    let cardModel = DCCardModel(layoutDic: layoutDic, dataDic: data)    let cardView = DCCardView(cardModel: cardModel)    cardView.cardClickClosure = self?.cardClickClosure    return cardView})</code></pre><p>但实际使用中发现开启 contentView 缓存后，列表下拉非常流畅，但上滑加载速度慢，研究源码发现其实是“伪重用”：</p><pre><code class="Objective-c">//UITableView+FBLayout.m- (UITableViewCell *)fb_cacheCellForIndexPath:(NSIndexPath *)indexPath {    // static NSString *kCellIdentifier = @&quot;fb_kCellIdentifier&quot;;    UITableViewCell *cell = [self dequeueReusableCellWithIdentifier:kCellIdentifier forIndexPath:indexPath];    UIView *reuseContentView = [cell.contentView viewWithTag:contentViewTag];    [self updateLayoutCacheWtih:reuseContentView toIndexPath:cell.indexPathStorage];    // 取缓存，或者block创建    UIView *cellContentView = [self fb_cacheContentView:indexPath reuseContentView:reuseContentView];    cell.fb_drawsAsynchronously = YES;    cellContentView.fb_drawsAsynchronously = YES;    cell.selectionStyle = cellContentView.fb_selectionStyle;    cell.backgroundColor = cellContentView.backgroundColor;    cell.clipsToBounds = cellContentView.clipsToBounds;    [cell setIndexPathStorageWithIndexPath:indexPath];    [self fb_configContentView:cellContentView forCell:cell];    return cell;}- (void)fb_configContentView:(UIView *)contentView forCell:(UITableViewCell *)cell{  UIView *removedView = [cell.contentView viewWithTag:contentViewTag];  [removedView removeFromSuperview];  [cell.contentView addSubview:contentView];}</code></pre><p><code>reuseIdentifier</code>只有一个定值，所谓的“重用”只到 contentView 级别，具体的子 view(label\button 等) 仍需由 CardView 创建 -&gt; 填充数据 -&gt; 布局 -&gt; 计算frame, 这显然是不够的。对<code>UITableView+FBLayout</code>进行了改造：</p><ol><li>既然一个<code>cardId</code>代表一种卡片样式，直接以<code>cardId</code>作为<code>reuseIdentifier</code>；</li><li><code>ViewModel</code>基类提供<code>updateView()</code>方法，子类实现直接刷新数据而不必新建view, 例如 label 更新 text, imageView 更新 image;</li><li>关闭 contentView 缓存，每个 cell 优先从复用池取，如果有，则 update 数据后计算 frame（or下拉场景直接 apply layoutCache），没有则新建。</li></ol><p>优化后的 block 实现：</p><pre><code class="Swift"> tableView.fb_setCellContnetViewBlock(forIndexPath: { [weak self] indexPath, reuseContentView -&gt; UIView in     guard let data = self?.dataList[indexPath.row],         let cardID = data[DyCardDataKey.cardID] as? String,         let layoutDic = DCLayoutEngine.shared.getLayoutDicByCardId(cardID) else {             return DCCardView(frame: .zero)     }     if (self?.base_reuseContent)! {         if let reuseContentView = reuseContentView as? DCCardView, let cardID = Int(cardID){             //reuse             if reuseContentView.cardModel?.cardID == cardID {                 reuseContentView.cardModel?.update(dataDic:data)                 return reuseContentView             }         }     }     let cardModel = DCCardModel(layoutDic: layoutDic, dataDic: data)     let cardView = DCCardView(cardModel: cardModel)     cardView.cardClickClosure = self?.cardClickClosure     return cardView }) self.view.addSubview(tableView) tableView.snp.makeConstraints(self.tableViewConstraintWithTopBar(self.navigationBar, nil)) return tableView}()</code></pre><p>至此，对于一个类似 feeds 的列表，终端只需新建 ViewController 继承<code>DyCardTableViewController</code>, 设置好 tableView 位置等，再从后台拉取 dataDic 数组组装<code>dataList</code>即可，不用再关心每张卡片的样式。效率提升、代码整洁。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>DynamicCard 内置了一些基础渲染控件，比如文字（DCLabel），图片（DCImageView），按钮（DCButton）等。如果这些组件不满足需求，还可以通过扩展组件来完成封装。实现自定义控件的大概流程如下：<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fz0my8zr2oj312a0u0wtm.jpg" alt=""></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>DynamicCard 先后在腾讯<a href="https://www.zhihu.com/question/266485668" target="_blank" rel="noopener">立知</a>、<a href="https://itunes.apple.com/cn/app/%E9%85%B1%E6%B2%B9-%E6%B8%B8%E6%88%8F%E7%A4%BE%E5%8C%BA/id1439301792?mt=8" target="_blank" rel="noopener">酱油</a>两个项目得到应用。终端有一个 manager 负责卡片的<strong>版本控制</strong>和<strong>存储</strong>。本地预存一份原始布局 json 文件，以提供无网络等异常情况下的默认样式。我们为终端同学提供了一个 CMS 平台，可批量上传or手动添加某个卡片的布局json，首次上传 version = 0, 之后每编辑一次该卡片 version 自动加1，totalVersion 也加1。此外每张卡还有一个值<code>minParseVersion</code>, 表示支持该卡片样式的最低<code>DynamicCard</code> framework 版本。终端<code>kLayoutParseVersion</code>通常是跟随 app 版本升级的，例如某个版本扩展了新的自定义视图，或者解析规则发生了变化等。 APP 运行后，设置定时任务每隔一段时间检查是否有卡片布局更新（比较本地<code>totalVersion</code>是否小于后台），如果有则请求数据，下发的新卡片需满足两个条件：</p><ol><li>version &gt; 终端本地卡片 version（or 本地没有该 cardId）</li><li>minParseVersion &lt;= kLayoutParseVersion</li></ol><p>例如下图只会下发 1002 和 1011 卡：<br><img src="https://ww1.sinaimg.cn/large/007i4MEmgy1fz0pz56yvcj31hy0tm79k.jpg" alt=""></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li><strong>动态</strong>：这是 DynamicCard 最大的优势，也是开发此框架的初衷。现在所有的布局字典都统一在 CMS 平台配置、编辑、管理版本、下发，数据字典由业务后台下发。终端可以动态接收和实时加载、渲染、刷新数据，卡片的新增和调整摆脱了对终端版本的依赖，APP 具备 native 体验的同时又有类似 H5 的灵活性。</li><li><strong>快速</strong>：排版性能与直接书写的排版代码性能相差不大，封装的 TableView 支持自动高度、布局缓存、contentView 缓存、和自动 cache 失效机制，以保障列表页的流畅度（当然，比 AutoLayout 性能好很多）。</li><li><strong>描述型排版</strong>：DynamicCard 接收的排版信息是一个字典，不需要写逻辑代码。做成描述型的好处是:<ul><li>方便维护，不易出错（因为没有代码）；</li><li>方便存储；</li><li>提升开发效率，只要熟悉 FlexBox, 各种布局实现起来要比代码容易得多（此外可以给控件扩展一些属性快速实现效果，比如 UIButton 图文排布）。</li></ul></li></ol><pre><code class="Swift">var direction: String?                   // 图片位于文字的方位var compound_drawable_padding: Float?    // 间隙大小</code></pre><p>就实际使用感受来讲，DynamicCard 需要后台与安卓/iOS开发共同维护一份数据字典的文档，dataDic key 要求和 layoutDic 中定义的 value 一致，如果有不一致或者找不到的情况控件便无法正常渲染，一定程度上加大了后台的工作量。<br>相比 weex/RN 下发js脚本，DynamicCard 在事件处理方面显得不够灵活。但接入和学习成本小得多，终端上手快，而 weex/RN 其实是降低了前端开发者入门移动端的门槛。<br>终端要根据实际场景选择是否采用 DynamicCard，一些样式丰富且频繁变化的界面如feed流非常适合。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby on Rails 学习笔记</title>
      <link href="/2018/06/15/rails-tutorial/"/>
      <url>/2018/06/15/rails-tutorial/</url>
      <content type="html"><![CDATA[<p><a href="https://rubyonrails.org" target="_blank" rel="noopener">Ruby on Rails</a> 是一个使用 Ruby 语言写的开源 Web 应用框架，它是严格按照 MVC 结构开发的。目标是努力使自身保持简单，使用最少的配置和代码。后来的 Django(Python)、Laravel(PHP)、 ChicagoBoss(Erlang)等框架都借鉴了 rails 的设计思想。Twitter、GitHub、Groupon，国内的暴走漫画、薄荷网等前期都是用 rails 作为主要的开发框架。虽然现在已经每况日下（ruby小众、性能不佳、社区活跃度低、学习门槛高…），但 rails 仍是一个了不起的框架。本文使用 rails 搭建一个类似 <a href="https://www.meetup.com" target="_blank" rel="noopener">Meetup</a> 的平台，体会 rails 开发的一些基础要素。<br><a id="more"></a></p><h1 id="Vagrant-VirtualBox-打造跨平台开发环境"><a href="#Vagrant-VirtualBox-打造跨平台开发环境" class="headerlink" title="Vagrant+VirtualBox 打造跨平台开发环境"></a>Vagrant+VirtualBox 打造跨平台开发环境</h1><p><a href="https://www.vagrantup.com/" target="_blank" rel="noopener">Vagrant</a> + <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VirtualBox</a> 应该是目前为止我找到的安装 ubuntu 虚拟机最简单的方式。在 rails 项目中使用 vagrant 搭建开发环境最直观的好处有三个：</p><ul><li>快。vagrant 重新封包后的 box 很小（远小于 Vmware 克隆出来的虚拟机），因此安装 ubuntu 不到10分钟完成。</li><li>共享文件夹。我可以用在 mac 使用 sublime+git 开发，同时在 ubuntu 虚拟机中运行 rails+mysql。二者同步。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgqo9erpj31j80ssgpf" alt=""></li><li>方便协作。与队友合作的时候打包一个已经配置好的 package 直接拿给队友用就可以了。免去了不同机子上折腾环境的问题，极大提高了效率。</li></ul><blockquote><p>这里有一篇<a href="https://github.com/astaxie/Go-in-Action/blob/master/ebook/zh/01.1.md" target="_blank" rel="noopener">详细介绍</a></p></blockquote><h1 id="Rails-Way"><a href="#Rails-Way" class="headerlink" title="Rails Way"></a>Rails Way</h1><p><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgqyivz0j30oj0dvdgy" alt=""><br>rails 的根本骨架是上面的 MVC 结构。<br>浏览器一个请求进来(这个请求首次是由浏览器输入主页地址敲下 enter 之后，其它是从 view 中的<code>link_path</code>来的，比如按钮点击)，首先由路由代码分发给响应的 controller 来响应该次请求（首次是返回root主页，其它都是在 controller 中定义的 action），controller 选择合适的 html 文件渲染，同时可能有对 model 层的操作，最终响应这次请求。数据放在 model 中，处理后传递给 controller。 具体可见这张图：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgr4ou5mj31fu164nfh" alt=""><br>如网址首页 root 请求由 page controller 响应，page controller 选择 views 下的同名文件夹之下的 welcome.html (后缀一般是.html.erb )进行渲染。其余请求处理过程都是如此。</p><h1 id="layout-解决代码重复问题"><a href="#layout-解决代码重复问题" class="headerlink" title="layout 解决代码重复问题"></a>layout 解决代码重复问题</h1><p>一个项目不同 html 间总有大量重复代码，如 welcome 和 about ，rails 用 layout 解决。打开本项目/layout/application.html.erb可以看到：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgrcap0jj30s40cc0v3" alt=""><br>具体到需要复用该布局的html只要写<code>yield</code>中的内容即可。</p><h1 id="Asset-Pipeline"><a href="#Asset-Pipeline" class="headerlink" title="Asset Pipeline"></a>Asset Pipeline</h1><p>图片和css/js资源在assets下，分别由 application.js 和 application.css 统一管理。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgrieqkqj30co0d8wfq" alt=""><br>这样在 application.html.erb 中不必再引入所有.css和.js，只要一句<code>&lt;%= stylesheet_link_tag &quot;application&quot; %&gt;</code> 就解决了，代码清爽了很多。多说一句，rails 自带支持 sass ，只要把后缀改为 .css.scss 就可以。</p><h1 id="Rails-接口操作数据库"><a href="#Rails-接口操作数据库" class="headerlink" title="Rails 接口操作数据库"></a>Rails 接口操作数据库</h1><p>本项目用 mysql, rails 操作数据库有一套非常简便的接口。<br>创建数据库:</p><pre><code class="ruby">rake db:create</code></pre><p>建表： 更改数据库的表结构，rails 给出的方法是<code>migration</code>。</p><pre><code class="ruby">rails g migration CreateIssues</code></pre><p>生成的数据库在 db/migrate 下：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgroxv1xj30ja0cutbj" alt=""><br>数据库建好后就可以创建 model 了。</p><h1 id="Partial-实现数据与模版分离"><a href="#Partial-实现数据与模版分离" class="headerlink" title="Partial 实现数据与模版分离"></a>Partial 实现数据与模版分离</h1><p>先补充一点：上面那张 MVC 的图中 controller 和 view 之间那条线是可以传递数据的。这也是 controller 读取 model 层数据交给 view 层进行显示的方式。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgrubxxgj30yg0ih75q" alt=""><br>主页下边需要显示 issues 列表，包括 issue 的标题、评论数、评论数目等属性。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgs04lf3j30v00e1whc" alt=""><br>每条 issue 都从 controller 中添加数据和样式显然不合适。rails 的解决方案是<code>partials</code> ，把页面中固定的某个模块抽取出来。如本例中的_issue_list.html.erb 用来管理 issue_list 。具体步骤：先创建数据库并创建对应的 model，请求传来的时候，page_controller 读取数据库内容， partial 定义 model 的显示逻辑，html 用 render 插入 partial ，数据库的内容便呈现给用户了。rails 中的 partials 和 layout 机制都为简化 html 代码，优化架构发挥了很大作用。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgs5d6frj3142056abn" alt=""></p><h1 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h1><h2 id="读取展示"><a href="#读取展示" class="headerlink" title="读取展示"></a>读取展示</h2><ul><li>先在model层为issues添加content，对issues表执行add_column操作。</li><li>添加路由， get ‘/issues/:id’ =&gt; “issues#show”</li><li>generator 自动创建 controller,同时可以生成对应的 show 模版。controller中定义<code>show action</code>，view 中定义好样式。read 操作完成。</li></ul><h2 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a>删除资源</h2><ul><li>先从 view 入手，定义删除按钮和链接。</li><li>添加路由<code>delete &#39;issues/:id&#39; =&gt; &#39;issues#destroy&#39;</code></li><li>controller 中实现<code>destroy</code>方法（对 model 的操作）。</li></ul><h1 id="Strong-Parameters-防止表单攻击"><a href="#Strong-Parameters-防止表单攻击" class="headerlink" title="Strong Parameters 防止表单攻击"></a>Strong Parameters 防止表单攻击</h1><p>本项目中允许用户发布issue,是通过表单实现的。具体方法是 Issue 的<code>create</code>方法。</p><pre><code class="ruby">def create    Issue.create(params[:issue])  redirect_to :rootend</code></pre><p>这样可以向数据库中写入数据，但直接这么提交会报错。</p><pre><code class="ruby">ActiveModel::ForbiddenAttributesError</code></pre><p>这个是 rails 为了防止坏人通过表单提交攻击网站，而采用的自我保护机制。如果不加说明坏蛋们就可以在<code>params[:issue]</code> 中人为植入其他的参数，比如<code>admin: true</code>这样就可以给他自己管理员权限了，所以必须要你自己指明哪些字段是允许直接用 params 里的参数来修改的。<br>rails3 创建或更新 Active Record 对象时，Model 中需要列一个白名单，声明哪些属性可以被 parameter 的数据更新。rails4 中用的是 Strong Parameters 的机制，Model 不再负责白名单的维护，把过滤非法属性的职责推给了 Controller。<br>View 层穿过来的数据会转化为一个<code>ActionController::Parameters</code>对象<br>过滤老的<code>ActionController::Parameters</code>对象，生成一个新的。</p><ul><li>只保留白名单属性</li><li>实例变量 @permitted 赋为 true</li></ul><p>只有 @permitted 为 true 时才可传入 model 层。 具体到本例： 到 issue_controller.rb 中添加：</p><pre><code class="ruby">private    def issue_params    params.require(:issue).permit(:title, :content)  end</code></pre><p>create 方法改为：</p><pre><code class="ruby">Issue.create(issue_params)</code></pre><h1 id="rails-的-DRY-don’t-repeat-yourself-原则"><a href="#rails-的-DRY-don’t-repeat-yourself-原则" class="headerlink" title="rails 的 DRY(don’t repeat yourself) 原则"></a>rails 的 DRY(don’t repeat yourself) 原则</h1><p>rails 简化代码有许多优秀的机制。</p><ul><li>layout 抽取可复用代码。对应<code>&lt;%yield%&gt;</code>。</li><li>partials 抽取页面中相对独立的模块。对应<code>render</code>。同样可起到代码复用的作用。</li><li>resources 集成 model 的 CURD 操作<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgsg5ztnj30mp0ip420" alt=""></li></ul><h1 id="资源间建立一对多关系"><a href="#资源间建立一对多关系" class="headerlink" title="资源间建立一对多关系"></a>资源间建立一对多关系</h1><p>前面创建了 issues 表，接着要为每个 issue 添加 comment。 先创建 model：</p><pre><code class="ruby">rails g model comment content:text username:string email:string issue_id:integer</code></pre><p>再创建对应的路由和 controller, controller 中定义 comment 的 create 方法。如何在/issues/show.html 中显示所有 comment? 这就涉及到在两个 model 间建立一对多的关系。</p><ul><li>确保 comments 表里面有<code>issue_id</code>这个字段，注意，<strong>名字一个字都不能错</strong>，因为要用它是和 issues 表产生映射关系的纽带。</li><li>到 issue.rb 文件中添加<code>has_many :comments</code></li><li>到 comment.rb 中，添加<code>belongs_to :issue</code></li></ul><p>同理，user 和 comment/issues 各自之间的一对多关系都是这么映射的。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgsmz306j30k006sgmo" alt=""><br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgt1cvz8j30is05ojse" alt=""><br>这样就可以直接使用<code>issue.comments</code>,<code>comment.issue</code>这样方便的表达。</p><pre><code class="ruby">def show     @issue = Issue.find(params[:id])   @comments = @issue.commentsend</code></pre><h1 id="加密及验证"><a href="#加密及验证" class="headerlink" title="加密及验证"></a>加密及验证</h1><p>注册登录是一个网站最基本的用户管理模块。如何把注册表单中提交的明文密码进行加密存储，登录时又如何将用户输入的明文密码与加密后的密码进行匹配？rails 提供一个强大的接口解决 —— <a href="http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html" target="_blank" rel="noopener">has_secure_password</a>.</p><ul><li>在 Gemfile 里面添加 Bcrypt。</li><li>users 这张表里设置<code>password_digest</code>字段。（表明要存储的是加密后的密码）</li><li>User model添加<code>has_secure_password</code>.</li><li>controller 定义<code>reate</code>方法：</li></ul><pre><code class="ruby">def create    user = User.new(user_params)  user.save  redirect_to :rootendprivate    def user_params    params.require(:user).permit!  end</code></pre><p>注意这里的<code>strong parameter</code>。使用<code>has_secure_password</code>方法后sign up 的行为（数据库创建新用户，密码加密后存储）就都自动完成了。至于登录时的密码匹配工作是由 authenticate 这个方法完成的（后边会看到）。 去数据库看一下：</p><pre><code class="ruby">rails c  u = User.first  </code></pre><p><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgt95ughj30zc04o760" alt=""><br>可以看到密码是加密后的。</p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>session 是 rails 中一个默认就有的方法，可以向里面存放数据，那么只要一直打开网站，那么用户存储的数据就一直存在。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgtfy8a1j30mg0ca0ux" alt=""><br>规定 session 中存放<code>user_id</code>，怎么显示用户名？rails 中有一个约定俗成的方法<code>current_user</code>:</p><pre><code class="ruby">def current_user    @current_user ||= User.find(session[:user_id]) if session[:user_id]end  helper_method :current_user  </code></pre><p>这样随时可以知道当前是否有用户在线以及在线用户信息。</p><h1 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h1><p>session 存放的数据是临时性的，如果网站关闭了或是关机重启了，session 中的数据也就丢失了。实现<code>remember me</code>需要 cookie 。cookie 可以把服务器发过来的数据保留成一个<strong>本地硬盘</strong>上的一个文件。另外，rails 同样提供了一个方法叫<code>cookies</code> 可以方便开发者操作 cookie。<br>实现remember的关键代码：</p><pre><code class="ruby">cookies.permanent[:auth_token] = user.auth_token  </code></pre><p>如果用户不打算 remember me:</p><pre><code class="ruby">cookies[:auth_token] = user.auth_token</code></pre><p>这种效果跟 session 是一样的。<br>用户在 cookie 中怎么存储？<br>cookie 中的数据是要存到本地的，显然不能直接把用户id存起来。所以通过为每一个用户生成一串随机数，用来代表他的身份。数据库中为每个 User 添加<code>auth token</code>字段（base 64存储）：</p><pre><code class="ruby">rails g migration AddAuthTokenToUsers auth_token:string  </code></pre><p>生成<code>auth_token</code>方法：</p><pre><code class="ruby">before_create { generate_token(:auth_token) }def generate_token(column)    begin    self[column] = SecureRandom.urlsafe_base64  end while User.exists?(column =&gt; self[column])end  </code></pre><h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><p>rails 自带的<code>validator</code>接口基本满足最常用的情况。user model中：</p><pre><code class="ruby">validates :name, :email, presence: true  validates :name, :email, uniqueness: { case_sensitive: false }  </code></pre><p><code>presence: true</code>表明 name/email 都是必填项。<code>uniqueness</code>保证唯一性。<code>validator</code> 接口方法的触发时机是在向数据库中 save 之前。因此之前 user 的 create 方法中保存 cookie 前要加判断条件<code>if user.save</code> 。save 成功说明已经通过 validator 的验证。</p><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><p>rails中使用<code>i18N</code>实现国际化。<br>application.rb 设置语言类型： </p><pre><code class="ruby">config.i18n.default_locale = &#39;zh-CN&#39;</code></pre><p>书写 zh-CN.yml, 将需要翻译的词进行翻译。</p><h1 id="优化体验"><a href="#优化体验" class="headerlink" title="优化体验"></a>优化体验</h1><h2 id="atwho"><a href="#atwho" class="headerlink" title="atwho"></a>atwho</h2><p>用到<a href="https://github.com/ichord/jquery-atwho-rails" target="_blank" rel="noopener">jquery-atwho-rails gem</a>, comment_box 添加<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgpvuzw9j314s0eawhr" alt=""><br>基本原理就是定义一个数组，拿到页面上的所有用户名，检查有无重复。</p><h2 id="hot-keys"><a href="#hot-keys" class="headerlink" title="hot keys"></a>hot keys</h2><p>用到<a href="https://github.com/jeresig/jquery.hotkeys" target="_blank" rel="noopener">jquery.hotkeys</a>, comment_box 添加<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgtpfnkpj314o0aw76k" alt=""><br><code>13</code>对应回车键，<code>ctrKey</code>对应 ctrl，<code>metaKey</code>在 Mac 下对应 Command 键， Windows 下应该对应 Window 键。</p><h2 id="markdown-格式支持"><a href="#markdown-格式支持" class="headerlink" title="markdown 格式支持"></a>markdown 格式支持</h2><p>用到<a href="https://github.com/vmg/redcarpet" target="_blank" rel="noopener">redcarpet</a>, application_helper.rb 中：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgu5dmk1j31380hsq6a" alt=""><br><code>html_safe :</code>如果去掉，页面中刷新会出现 html 标签，这是一种<strong>安全机制</strong>，防止有人嵌入 html 代码来实现对网站的攻击。不过前面<code>filter_html: true</code>已经过滤掉了可能导致安全隐患的 html 标签。所以就可以放心的来添加 <code>.html_safe</code>来让 rails 放弃这种安全机制了。</p><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>用到<a href="https://github.com/tmm1/pygments.rb" target="_blank" rel="noopener">pygemnt</a></p><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>这里涉及到的只是非常简单的权限控制，包括只有登录用户<code>(@current_user)</code>能发布 issue，只有 issue 的作者本人可以删除或编辑<br>issue: </p><pre><code class="ruby">&lt;% if current_user &amp;&amp; current_user == @issue.user %&gt; </code></pre><p>可以看出主要是通过<code>current_user</code>实现的，同时要设置好 user 和 issue 的一对多关系。</p><h1 id="ActionMailer-实现-mail-服务"><a href="#ActionMailer-实现-mail-服务" class="headerlink" title="ActionMailer 实现 mail 服务"></a>ActionMailer 实现 mail 服务</h1><p>ActionMailer 用户注册后发送欢迎邮件。 代码写在<code>user.save</code>之后： </p><pre><code class="ruby">UserMailer.welcome_email(@user).deliver</code></pre><p>生成 UserMailer 和 welcome email 方法。再修改 user mailer.rb，就跟 controller action 差不多，再写一个 view 文件－－邮件正文。实现发邮件功能需要集成第三方服务<a href="https://www.mailgun.com" target="_blank" rel="noopener">Mailgun</a>或国内的<a href="https://www.sendcloud.net" target="_blank" rel="noopener">sendCloud</a>。</p><blockquote><p><a href="https://github.com/zltunes/Meetup" target="_blank" rel="noopener">源码</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rails </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactiveCocoa 入门与登录实战</title>
      <link href="/2018/06/14/reactivecocoa-tutorial/"/>
      <url>/2018/06/14/reactivecocoa-tutorial/</url>
      <content type="html"><![CDATA[<p>ReactiveCocoa 是 github 开源的一个<strong>函数式、响应式</strong>编程框架，是在 iOS 平台上对 FRP 的实现。<br><a id="more"></a></p><h1 id="RAC-解决的主要问题"><a href="#RAC-解决的主要问题" class="headerlink" title="RAC 解决的主要问题"></a>RAC 解决的主要问题</h1><p>iOS 开发中消息传递和回调机制一直很复杂，RAC 使用 Signal 来代替 KVO、Notification、Delegate 和 Target-Action 等传递消息，解决对象之间状态与状态依赖过多的问题，RAC 通常和 MVVM 结合在一起，在很多地方被用作 iOS 项目中 MVVM 架构的实践方式。</p><h1 id="常用几招"><a href="#常用几招" class="headerlink" title="常用几招"></a>常用几招</h1><h2 id="target-action类："><a href="#target-action类：" class="headerlink" title="target-action类："></a>target-action类：</h2><h3 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h3><p>需求：实时监听 textField 输入的字符串并打印。<br>传统 target-action 方式:</p><pre><code class="objc">//注册 selector[textField addTarget:self action:@selector(textChanged:) forControlEvents:UIControlEventEditingChanged];//实现 selector- (void)textChanged:(UITextField *)textField{      LxDBAnyVar(textField);}</code></pre><p>这里用到一个很方便的用于打印对象的工具<a href="https://github.com/DeveloperLx/LxDBAnything" target="_blank" rel="noopener">LxDBAnyVar</a><br>用 RAC 的方式:</p><pre><code class="objc">[[textField rac_signalForControlEvents:UIControlEventEditingChanged]   subscribeNext:^(id x) {    LxDBAnyVar(x);}];</code></pre><p>事实上对于所有 UIControl 子类的对象的事件监听都可以用这种方式。比如 UIButton 的<code>TouchUpInside</code>事件。<br>更简洁版本:</p><pre><code class="objc">[textField.rac_textSignal subscribeNext:^(NSString *x) {         LxDBAnyVar(x);}];</code></pre><h3 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h3><p>需求：为 UIView 添加点击事件。</p><pre><code class="objc">self.view.userInteractionEnabled = YES;UITapGestureRecognizer * tap = [[UITapGestureRecognizer alloc]init];      [[tap rac_gestureSignal] subscribeNext:^(UITapGestureRecognizer * tap) {        LxDBAnyVar(tap);    }];[self.view addGestureRecognizer:tap];</code></pre><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>需求：监听 app 进入后台的通知。</p><pre><code class="objc">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(NSNotification * notification) {        LxDBAnyVar(notification);}];</code></pre><p>注意：使用 RAC 监听通知不需要<code>removeObserver</code>。因为监听者是 RAC 内部持有的，RAC 会管理通知什么时候释放。</p><h3 id="定时器-NSTimer"><a href="#定时器-NSTimer" class="headerlink" title="定时器 NSTimer"></a>定时器 NSTimer</h3><p>需求1. 延迟某个时间后再做某件事。<br>更改<code>afterDelay</code>属性:</p><pre><code class="objc">[[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{        LxPrintAnything(rac);}];</code></pre><p>需求2. 每间隔多长时间做一件事。<br>更改<code>interval</code>属性:</p><pre><code class="objc">[[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]subscribeNext:^(NSDate * date) {        LxDBAnyVar(date);}];</code></pre><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>需求：监听点击了 AlertView 的哪一个按钮。</p><pre><code class="objc">UIAlertView * alertView = [[UIAlertView alloc]initWithTitle:@&quot;RAC&quot; message:@&quot;ReactiveCocoa&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Ensure&quot;, nil];  [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple * tuple) {        LxDBAnyVar(tuple);        LxDBAnyVar(tuple.first);        LxDBAnyVar(tuple.second);        LxDBAnyVar(tuple.third);}];[alertView show];</code></pre><p><code>tuple</code>是 RAC 自己定义的集合类，特点是一个对象含有多个对象。此处对应 alertView 中的按钮。<br>更简单方式：</p><pre><code class="objc">[[alertView rac_buttonClickedSignal]subscribeNext:^(id x) {        LxDBAnyVar(x);}];</code></pre><p>RAC 取代代理有局限：<strong>只能是没有返回值（void）的代理方法。</strong></p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>需求：监听 scrollView 滑动时 contentOffset 的变化。</p><pre><code class="objc">[RACObserve(scrollView, contentOffset) subscribeNext:^(id x) {        LxDBAnyVar(x);}];</code></pre><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="RAC-常见类"><a href="#RAC-常见类" class="headerlink" title="RAC 常见类"></a>RAC 常见类</h2><h3 id="RACSignal-核心"><a href="#RACSignal-核心" class="headerlink" title="RACSignal (核心)"></a>RACSignal (核心)</h3><p>过程：创建信号 -&gt; 激活信号 -&gt; 废弃信号。<br>RAC的核心就是<code>RACSignal</code>，我们可以直接创建信号<code>createSignal</code>，并发送<code>sendNext</code>，当信号完成后用<code>dispose</code>销毁。</p><pre><code class="objc">// 1.创建信号RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        // block调用时刻：每当有订阅者订阅信号，就会调用block。        // 2.发送信号:注意signal本身不具备发送信号的能力，而是交给内部一个订阅者去发出。        [subscriber sendNext:@1];        // 如果不再发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。        [subscriber sendCompleted];        return [RACDisposable disposableWithBlock:^{            // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。            // 执行完Block后，当前信号就不在被订阅了。            NSLog(@&quot;信号被销毁&quot;);        }];    }];    // 3.订阅信号,才会激活信号.    [siganl subscribeNext:^(id x) {        // block调用时刻：每当有信号发出数据，就会调用block.        NSLog(@&quot;接收到数据:%@&quot;,x);    }error:^(NSError *error) {     NSLog(error);   }completed:^{     NSLog(@&quot;completed&quot;); }];</code></pre><h3 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h3><p>处理事件的类。如监听按钮点击，网络请求，可以把事件如何处理，事件中的数据如何传递等包装到这个类中。</p><pre><code class="objc">// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {    NSLog(@&quot;执行命令&quot;);    // 创建空信号,必须返回信号    //        return [RACSignal empty];    // 2.创建信号,用来传递数据    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [subscriber sendNext:@&quot;请求数据&quot;];        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。        [subscriber sendCompleted];        return nil;    }];}];// 强引用命令，不要被销毁，否则接收不到数据_conmmand = command;// 3.订阅RACCommand中的信号[command.executionSignals subscribeNext:^(id x) {    [x subscribeNext:^(id x) {        NSLog(@&quot;%@&quot;,x);    }];}];// RAC高级用法// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号[command.executionSignals.switchToLatest subscribeNext:^(id x) {    NSLog(@&quot;%@&quot;,x);}];// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。[[command.executing skip:1] subscribeNext:^(id x) {    if ([x boolValue] == YES) {        // 正在执行        NSLog(@&quot;正在执行&quot;);    }else{        // 执行完成        NSLog(@&quot;执行完成&quot;);    }}];// 5.执行命令[self.conmmand execute:@1];</code></pre><h2 id="RAC-常见宏"><a href="#RAC-常见宏" class="headerlink" title="RAC 常见宏"></a>RAC 常见宏</h2><h3 id="RAC-TARGET-KEYPATH-NIL-VALUE-…"><a href="#RAC-TARGET-KEYPATH-NIL-VALUE-…" class="headerlink" title="RAC(TARGET, [KEYPATH, [NIL_VALUE]]=…"></a>RAC(TARGET, [KEYPATH, [NIL_VALUE]]=…</h3><p>用于给某个对象的某个属性绑定信号。</p><pre><code class="objc">// 只要文本框文字改变，就会修改label的文字RAC(self.label,text) = _textField.rac_textSignal;</code></pre><h3 id="RACObserve-TARGET-KEYPATH"><a href="#RACObserve-TARGET-KEYPATH" class="headerlink" title="RACObserve(TARGET, [KEYPATH])"></a>RACObserve(TARGET, [KEYPATH])</h3><p>用于监听某个对象的某个属性,返回信号。</p><pre><code class="objc">[RACObserve(scrollView, contentOffset) subscribeNext:^(id x) {        NSLog(x);}];</code></pre><h2 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h2><h3 id="映射-flattenMap-Map"><a href="#映射-flattenMap-Map" class="headerlink" title="映射 flattenMap,Map"></a>映射 flattenMap,Map</h3><p>用于把源信号内容映射成新的内容。<br>Map 使用：</p><ol><li>传入一个block,类型是返回对象，参数是value。</li><li>value就是源信号的内容，直接拿到源信号的内容做处理。</li><li>把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。</li></ol><pre><code class="objc">[[_textField.rac_textSignal map:^id(id value) {        // 当源信号发出，就会调用这个block，修改源信号的内容        // 返回值：就是处理完源信号的内容。        return [NSString stringWithFormat:@&quot;输出:%@&quot;,value];    }] subscribeNext:^(id x) {        NSLog(@&quot;%@&quot;,x);}];</code></pre><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>多个异步请求都完成后，再做某件事。<br>将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的 signal 至少都有过一次 <code>sendNext</code>，才会触发合并的信号。</p><pre><code class="objc">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@1];   return nil;}];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@2];   return nil;}];// 把两个信号组合成一个信号,跟zip一样，没什么区别RACSignal *combineSignal = [signalA combineLatestWith:signalB];[combineSignal subscribeNext:^(id x) {   NSLog(@&quot;%@&quot;,x);}];</code></pre><p>当组合信号被订阅，内部会自动订阅signalA、signalB，必须两个信号都发出内容，才会被触发。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>用于信号发出的内容是元组，把信号发出元组的值聚合成一个值。<br>常见用法：先组合再聚合。</p><pre><code class="objc">combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@1];   return nil;}];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@2];   return nil;}];// reduce中的block简介:// reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容// reduceblcok的返回值：聚合信号之后的内容。RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2){  return [NSString stringWithFormat:@&quot;%@ %@&quot;,num1,num2];}];[reduceSignal subscribeNext:^(id x) {   NSLog(@&quot;%@&quot;,x);}];</code></pre><h1 id="实战：用-RAC-实现登录模块"><a href="#实战：用-RAC-实现登录模块" class="headerlink" title="实战：用 RAC 实现登录模块"></a>实战：用 RAC 实现登录模块</h1><p><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwa6avjzang30810ecaaw" alt=""><br>如图是常见的一个登录需求，登录按钮在信息填写完整且符合规定前不可用，我们尝试用 RAC+MVVM 实现。项目结构如图：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwa6bdad76j30fc0jgzkf" alt=""></p><h2 id="model-层"><a href="#model-层" class="headerlink" title="model 层"></a>model 层</h2><pre><code class="objc">@interface User : NSObject@property NSString  * user_id;@property NSString  * access_token;@property NSString  *phone_num;@property NSString  *password;@property BOOL      isLogin;@end</code></pre><h2 id="view-model-层"><a href="#view-model-层" class="headerlink" title="view-model 层"></a>view-model 层</h2><p><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwa6bljc56j315y0d8wh7" alt=""><br>MVVM 相比 MVC 多了 view-model 层，将原先 controller 层的大部分业务逻辑抽离出来，本案例主要涉及两个：</p><ol><li>判断是否允许登录</li><li>执行登录动作</li></ol><p>因此在 LoginViewModel 中设置两个信号。</p><pre><code class="objc">@interface LoginViewModel : NSObject@property(nonatomic,strong) User *user;//是否允许登录的信号@property(nonatomic,strong,readonly) RACSignal *enableLoginSignal;//执行登录操作的信号@property(nonatomic,strong,readonly) RACCommand *loginCommand;@end</code></pre><h3 id="判断是否允许登录"><a href="#判断是否允许登录" class="headerlink" title="判断是否允许登录"></a>判断是否允许登录</h3><pre><code class="objc">//    监听账号的属性值改变，把它们聚合为一个信号。_enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.user, phone_num),RACObserve(self.user, password)] reduce:^id(NSString *phone_num,NSString *password){    NSPredicate *phoneNum_prdicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;^1[3|4|5|7|8][0-9]\\d{8}$&quot;];    NSPredicate *pwd_predicate     = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;^.{6,}$&quot;];    return @([phoneNum_prdicate evaluateWithObject:phone_num] &amp;&amp; [pwd_predicate evaluateWithObject:password]);}];</code></pre><p>看得出来相比以前用<code>target-action</code>监听 textField 变化，再用<code>if...else</code>判断两个值是否都存在且合法，现在利用 RAC <code>conbine + reduce</code>处理信号，只需单个函数即可实现，代码清爽很多。</p><h3 id="执行登录动作"><a href="#执行登录动作" class="headerlink" title="执行登录动作"></a>执行登录动作</h3><pre><code class="objc">_loginCommand = [[RACCommand alloc]initWithSignalBlock:^RACSignal *(id input) {    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [User loginWithParameters:_user.mj_keyValues SuccessBlock:^(id returnValue) {            User* newUser = [User mj_objectWithKeyValues:returnValue];            _user.user_id      = newUser.user_id;            _user.access_token = newUser.access_token;            _user.isLogin      = YES;            [subscriber sendNext:@&quot;success&quot;];            [subscriber sendCompleted];        } FailureBlock:^(NSError *error) {            [subscriber sendNext:[NSString stringWithFormat:@&quot;登录失败!%@&quot;,error]];            [subscriber sendCompleted];        }];        return nil;    }];}];</code></pre><p>注意<code>raccommand</code>返回的需是一个信号，登录操作就在这里面，登录之后发送信号。<br><code>loginCommand</code>还可以监听登录状态。</p><pre><code class="objc">[[_loginCommand.executing skip:1]subscribeNext:^(id x) {    if ([x isEqualToNumber:@(YES)]) {        [Config showProgressHUDwithStatus:@&quot;登录中...&quot;];    } else {        [Config dismissHUD];    }}];@end</code></pre><h2 id="controller-层"><a href="#controller-层" class="headerlink" title="controller 层"></a>controller 层</h2><pre><code class="objc">@interface LoginVC : UIViewController@property (strong, nonatomic) IBOutlet UITextField    *accountTextField;@property (strong, nonatomic) IBOutlet UITextField    *pwdTextField;@property (strong, nonatomic) IBOutlet UIButton       *loginBtn;@property (strong,nonatomic ) LoginViewModel          *loginViewModel;@end</code></pre><h3 id="视图模型绑定"><a href="#视图模型绑定" class="headerlink" title="视图模型绑定"></a>视图模型绑定</h3><pre><code class="objc">// 给模型的属性绑定信号// 账号文本框一改变，就给 User 属性赋值    RAC(self.loginViewModel.user,phone_num) = _accountTextField.rac_textSignal;RAC(self.loginViewModel.user,password)  = _pwdTextField.rac_textSignal;// 为登录按钮的&quot;enable&quot;属性绑定信号RAC(self.loginBtn,enabled)              = self.loginViewModel.enableLoginSignal;</code></pre><h3 id="监听登录动作"><a href="#监听登录动作" class="headerlink" title="监听登录动作"></a>监听登录动作</h3><pre><code class="objc">// 监听登录按钮的点击,执行loginCommand[[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside]subscribeNext:^(id x) {// 执行登录    [self.loginViewModel.loginCommand execute:nil];}];</code></pre><h3 id="监听登录结果"><a href="#监听登录结果" class="headerlink" title="监听登录结果"></a>监听登录结果</h3><p>订阅<code>loginCommand</code>返回的信号，如果返回 success 就存储登录信息。</p><pre><code class="objc">[self.loginViewModel.loginCommand.executionSignals.switchToLatest subscribeNext:^(NSString* x) {    if ([x isEqualToString:@&quot;success&quot;]) {//  存储用户信息及登录状态，此处不能使用 realm 作数据库,realm 不允许在 observer 中 addObject。        NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];        [defaults setValue:_loginViewModel.user.phone_num forKey:@&quot;phone_num&quot;];        [defaults setValue:_loginViewModel.user.access_token forKey:@&quot;access_token&quot;];        [defaults setValue:[NSNumber numberWithInteger:_loginViewModel.user.user_id] forKey:@&quot;user_id&quot;];        [defaults setValue:[NSNumber numberWithBool:_loginViewModel.user.isLogin] forKey:@&quot;isLogin&quot;];        [defaults synchronize];        [self performSegueWithIdentifier:@&quot;toTabBarController&quot; sender:nil];    }}];</code></pre><blockquote><p>上述登录代码可<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">参考这里</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ReactiveCocoa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 热更新解读（三）—— JSPatch 之于 Swift</title>
      <link href="/2018/06/14/jspatch-swift/"/>
      <url>/2018/06/14/jspatch-swift/</url>
      <content type="html"><![CDATA[<p>本篇探索 jspatch 能否用于 swift 项目实现热更新。<br><a id="more"></a></p><h1 id="继承自-NSObject-的-Swift-类"><a href="#继承自-NSObject-的-Swift-类" class="headerlink" title="继承自 NSObject 的 Swift 类"></a>继承自 NSObject 的 Swift 类</h1><h2 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h2><p>新建 Swift 工程 <code>SwiftJSPatch</code>。<br><code>AppDelegate.swift</code>：</p><pre><code class="swift">// in AppDelegate.swift ----------------func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {        let path = NSBundle.mainBundle().pathForResource(&quot;main&quot;, ofType: &quot;js&quot;)        do {            let patch = try String(contentsOfFile: path!)            JPEngine.startEngine()            JPEngine.evaluateScript(patch)        } catch {}        return true    }</code></pre><p><code>ViewController</code>中设置两个自定义属性：<code>public</code>属性<code>a</code>，<code>private</code>属性<code>pa</code>：</p><pre><code class="swift">// in ViewController.swift ---------------------class ViewController: UIViewController {    var a = &quot;a&quot;    dynamic private var pa = &quot;pa&quot;    override func viewDidLoad() {        print(&quot;ORIG title:\(self.title!)&quot;)        print(&quot;ORIG a:\(a)&quot;)        print(&quot;ORIG pa:\(pa)&quot;)        super.viewDidLoad()    }    override func didReceiveMemoryWarning() {        super.didReceiveMemoryWarning()    }}</code></pre><p><code>main.js</code>中去获取这两个自定义属性并各自赋新值，此外为<code>ViewController</code>继承自父类<code>UIViewController</code>的属性<code>title</code>设置新值：</p><pre><code class="JavaScript">// in main.js --------------------------defineClass(&#39;SwiftJSPatch.ViewController&#39;, {    viewDidLoad: function() {        self.setTitle(&#39;NEW VC&#39;)        console.log(&#39;title: &#39;+self.title().toJS())        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.setA(&#39;new_a&#39;)        self.setPa(&#39;new_pa&#39;)        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.ORIGviewDidLoad();    }});</code></pre><p>运行结果输出：</p><pre><code class="Objective-c">2016-07-29 11:19:26.165 SwiftJSPatch[3789:222439] JSPatch.log: a: a2016-07-29 11:19:26.169 SwiftJSPatch[3789:222439] *** Assertion failure in _exceptionBlock_block_invoke(), /Users/Leon/Desktop/SwiftJSPatch/SwiftJSPatch/JPEngine.m:1422016-07-29 11:19:26.174 SwiftJSPatch[3789:222439] *** Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, reason: &#39;unrecognized selector pa for instance &lt;SwiftJSPatch.ViewController: 0x7a760bb0&gt;&#39;</code></pre><p><code>title</code>修改成功，<code>a</code>获取成功，<code>pa</code>访问失败：找不到<code>selector(pa)</code>，查看 OC 端调用堆栈：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgzj76mxj31kw0vj1fy" alt=""><br>js端调试：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgzr25pgj30tg0kigpi" alt=""><br>经过<code>_evaluateScript:withSourceURL:</code>处理，<code>main.js</code>中的方法都被替换成<code>__C(&#39;methodName&#39;)</code>。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgzxs7h8j31ii12onds" alt=""><br><code>defineClass</code>对js对象method的改写也没问题。<br>由以上信息可知，JSPatch 方法替换成功，方法调用环节js调用oc私有方法<code>pa()</code>也就是在<code>callSelector</code>环节出错，获取不到方法签名导致后续消息转发无法进行。<code>public</code>方法则可以成功替换实现并调用。</p><p>现在在<code>private</code>变量前声明<code>dynamic</code>：</p><pre><code class="Swift">dynamic private var pa = &quot;pa&quot;</code></pre><p>输出：</p><pre><code class="Objective-C">2016-07-29 14:54:01.374 SwiftJSPatch[5368:357904] JSPatch.log: title: NEW VC2016-07-29 14:54:01.381 SwiftJSPatch[5368:357904] JSPatch.log: a: a2016-07-29 14:54:01.382 SwiftJSPatch[5368:357904] JSPatch.log: pa: pa2016-07-29 14:54:01.384 SwiftJSPatch[5368:357904] JSPatch.log: a: new_a2016-07-29 14:54:01.384 SwiftJSPatch[5368:357904] JSPatch.log: pa: new_paORIG title:NEW VCORIG a:new_aORIG pa:new_pa</code></pre><p>变量都被成功修改，也就是说方法替换和调用都没问题。</p><blockquote><p>结论1：<code>JSPatch</code>作用于继承自<code>NSObject</code>的类，其继承自父类的属性／自定义<code>public</code>变量可以直接访问和修改，自定义<code>private</code>变量需要加上<code>dynamic</code>。</p></blockquote><h2 id="修改函数实现"><a href="#修改函数实现" class="headerlink" title="修改函数实现"></a>修改函数实现</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>从上个修改属性的案例已经看出对于继承自<code>NSObject</code>的类的<strong>继承自父类的方法</strong>，<code>JSPatch</code>实现热更新是没问题的。所以直接看自定义函数的情况。</p><p>在<code>ViewController</code>自定义两个函数，其中一个是<code>private</code>方法：</p><pre><code class="Swift">// in ViewController ---------------------class ViewController: UIViewController {    var a = &quot;a&quot;    dynamic private var pa = &quot;pa&quot;    override func viewDidLoad() {        super.viewDidLoad()        self.fun()        self.pfun()    }    func fun() {        print(&quot;ORIG fun self.a: \(self.a)&quot;)    }    private func pfun() {        print(&quot;ORIG pfun self.pa: \(self.pa)&quot;)    }}</code></pre><p><code>main.js</code>中对这两个自定义函数实现进行修改。<code>fun()</code>给a赋新值，<code>pfun()</code>给<code>pa</code>赋新值：</p><pre><code class="Javascript">// in main.js------------------------defineClass(&#39;SwiftJSPatch.ViewController&#39;, {    fun: function() {        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        self.setA(&#39;new_a&#39;)        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        self.ORIGfun();    },    pfun: function() {        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.setPa(&#39;new_pa&#39;)        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.ORIGpfun();    }});</code></pre><p>运行：</p><pre><code>ORIG fun self.a: aORIG pfun self.pa: pa</code></pre><p>热更新失败！<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrh066y9fj31ic12swvr" alt=""><br>从js调试结果看脚本是被执行过的，且「方法替换」成功，说明是OC端「方法调用」时<strong>没有走运行时的消息转发流程</strong>。<br>为两个函数添加<code>dynamic</code>声明：</p><pre><code class="Swift">dynamic func fun() {    print(&quot;ORIG fun self.a: \(self.a)&quot;)}dynamic private func pfun() {    print(&quot;ORIG pfun self.pa: \(self.pa)&quot;)}</code></pre><p>hook成功：</p><pre><code class="Swift">2016-07-29 15:49:14.903 SwiftJSPatch[5639:391073] JSPatch.log: a: a2016-07-29 15:49:14.906 SwiftJSPatch[5639:391073] JSPatch.log: a: new_aORIG fun self.a: new_a2016-07-29 15:49:14.909 SwiftJSPatch[5639:391073] JSPatch.log: pa: pa2016-07-29 15:49:14.910 SwiftJSPatch[5639:391073] JSPatch.log: pa: new_paORIG pfun self.pa: new_pa</code></pre><h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>Swift 中静态函数分两种：class 函数／static 函数：</p><pre><code class="Swift">override func viewDidLoad() {      super.viewDidLoad()      ViewController.sfun()      ViewController.cfun()    }    dynamic static func sfun() {        print(&quot;ORIG static func.&quot;)    }    dynamic class func cfun() {        print(&quot;ORIG class func.&quot;)    }</code></pre><p>从结果看出，class 函数得到替换并调用成功，static 函数调用时没有进行消息转发：</p><pre><code class="Swift">ORIG static func.2016-07-29 16:01:16.186 SwiftJSPatch[5701:398350] JSPatch.log: NEW class fun.</code></pre><h1 id="纯-Swift-类"><a href="#纯-Swift-类" class="headerlink" title="纯 Swift 类"></a>纯 Swift 类</h1><p>新建<code>Pure</code>类：</p><pre><code class="Swift">// in Pure.swift ---------------------------class Pure {    var a = &quot;a&quot;    dynamic private var pa = &quot;pa&quot;    func call() {        self.fun()        self.pfun()    }    dynamic func fun() {        print(&quot;ORIG fun self.a: \(self.a)&quot;)    }    dynamic private func pfun() {        print(&quot;ORIG pfun self.pa: \(self.pa)&quot;)    }}</code></pre><p><code>main.js</code>修改<code>fun()</code>和<code>pfun()</code>的实现：</p><pre><code class="Javascript">// in main.js ---------------------------defineClass(&#39;SwiftJSPatch.Pure&#39;, {    fun: function() {        console.log(&#39;NEW static fun.&#39;)    },    pfun: function() {        console.log(&#39;NEW class fun.&#39;)    }});</code></pre><p>调用<code>call()</code>结果：<br>直接崩溃：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrh18e6muj31kw0so19w" alt=""><br>由上图知，<code>JSPatch</code>在进行到<code>overrideMethod</code>进行方法实现IMP替换时要求<code>class</code>实现<code>NSCoping</code>协议，而不继承自<code>NSObject</code>的swift类是不遵循该协议的，因此崩溃。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrh0moletj31e411u7da" alt=""><br>回到崩溃代码:</p><pre><code class="Objective-C">if (!_JSOverideMethods[cls]) {        _JSOverideMethods[(id&lt;NSCopying&gt;)cls] = [[NSMutableDictionary alloc] init];    }</code></pre><p>此处<code>JSPatch</code>在初始化缓冲区的时候将<code>Class</code>作为<code>Dictionary</code>的<code>key</code>进行保存，而<code>Dictionary</code>在设置<code>key-value</code>时会拷贝 <code>key</code>值，所以会导致给一个不遵循<code>NSCoying</code>协议的对象发送了<code>copyWithZone:</code>消息，导致崩溃。</p><h1 id="Swift-原生类热修复难点"><a href="#Swift-原生类热修复难点" class="headerlink" title="Swift 原生类热修复难点"></a>Swift 原生类热修复难点</h1><p>到这里「方法替换」的步骤已经进行不下去了。<code>JSPatch</code>对<code>Swift</code>原生类的热修复已经无能为力了。但<code>Swift</code>热修复的真正难点其实并不在这里，假如我们越过<code>NSCoping</code>通过某种 <strong><em>swift style</em></strong> 的方式实现了对类中方法名和对应js实现的缓存，也就是完成「方法替换」的话，热修复就能成功了吗？</p><p>「方法调用」才是 swift 热修复中目前真正无解的地方，最大原因是<strong>swift中runtime相对OC中的runtime动态性大大减弱</strong>。</p><ul><li>纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。</li><li>继承自NSObject的Swift类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加dynamic修饰才可以获得动态性。</li><li>若方法的参数、属性类型为Swift特有、无法映射到Objective-C的类型(如Character、Tuple)，则此方法、属性无法添加dynamic修饰（会编译错误）</li><li>Swift类在Objective-C中会有模块前缀。</li></ul><p>另外最要命的一点：<code>objc_msgSend</code>函数无法用于 Swift object。这个导致<code>JSPatch</code>实现方法调用（消息转发）的基础机制在 Swift 中失效了。</p><p>总结一下 <code>Swift</code> 项目中使用<code>JSPatch</code>需要注意的几点：</p><ul><li>只支持调用继承自 NSObject 的 Swift 类。</li><li>继承自 NSObject 的 Swift 类，其继承自父类的方法和属性可以在 JS 调用，其他自定义方法和属性同样需要加 dynamic 关键字才行。</li><li>若方法的参数/属性类型为 Swift 特有(如 Character / Tuple)，则此方法和属性无法通过 JS 调用。</li></ul><blockquote><p>参考资料：<br><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=403153173&amp;idx=1&amp;sn=c631f95b28a0eb4b842a9494e43a30e5" target="_blank" rel="noopener">Swift Runtime分析：还像OC Runtime一样吗？</a><br><a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95#11-swift" target="_blank" rel="noopener">JSPatch Github Wiki</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> JSPatch </tag>
            
            <tag> 源码 </tag>
            
            <tag> 动态化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 热更新解读（二）—— JSPatch 源码解析</title>
      <link href="/2018/06/14/jspatch-sourcecode/"/>
      <url>/2018/06/14/jspatch-sourcecode/</url>
      <content type="html"><![CDATA[<p>了解了 JavaScriptCore 的使用方式，本篇从 demo 入手对 JSPatch 关键源码进行解读。<br><a id="more"></a></p><p>关于 JSPatch 的实现原理，JSPatch 作者本人 <a href="http://blog.cnbang.net/" target="_blank" rel="noopener">bang</a> 已经有一系列文章阐述:</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=1&amp;sn=c7d9ee27eff35688180bdc840d31120b&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;一&gt; 核心</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=2&amp;sn=44b62a84a122886b08874861df83d889&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;二&gt; 细节</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=3&amp;sn=9af2403895ff8e09bd7b7d767a34dd5e&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;三&gt; 扩展</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=4&amp;sn=03f7fcdb54ebc8cc49995bf690292ebb&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;四&gt; 新特性</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=5&amp;sn=22c304b6534b17c2ef36ee0afaa7576e&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;五&gt; 优化</a></li></ul><p>这些文章是对 JSPatch 内部实现原理和细节诸如“require实现”、“property实现”、“self/super 关键字”、“nil处理”、“内存问题”等具体设计思路和解决方案的阐述，并没有对 JSPatch 源码进行解读。在未接触源码、不清楚整个热修复流程的情况下去读这几篇文章难免一头雾水，最好的方法是边读源码边对照上述文章，代码中不理解的地方可以去文章中寻找答案。<br>本文将从一个小demo入手，跟踪代码执行流程，从Cocoa层、JavaScript层、Native层对热修复流程中涉及到的重要步骤和函数进行解析。</p><h1 id="JSPatch-使用流程"><a href="#JSPatch-使用流程" class="headerlink" title="JSPatch 使用流程"></a>JSPatch 使用流程</h1><p>引入JSPatch，JSPatch 核心部分只有三个文件，十分精巧：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwa5yc63m9j30f0052wei" alt=""><br>建立一个小demo，在<code>ViewController</code>屏幕中央放置一个button，button 点击事件为空:</p><pre><code class="Objective-C">// in ViewController.m ------------------ (IBAction)handle:(id)sender {}</code></pre><p>热修复js文件（main.js）内容就是添加这个点击事件（弹出一个<code>AlertView</code>）：</p><pre><code class="JavaScript">// in main.js ------------------------defineClass(&#39;ViewController&#39;, {  handle: function(sender) {    require(&#39;UIAlertView&#39;);    var alert = UIAlertView.alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(&quot;alert&quot;, null, null, &quot;ok&quot;, null, null);    alert.show();  }})</code></pre><blockquote><p>js 文件编写方法查看<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">JSPatch 基础用法</a>。</p></blockquote><p><code>didFinishLaunchingWithOptions:</code>中开启 JSPatch 引擎、执行 js 脚本：</p><pre><code class="Objective-C">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // 开启 JPEngine.    [JPEngine startEngine];    NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];    NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil];    // 执行js脚本代码.    [JPEngine evaluateScript:script];    return YES;}</code></pre><p>修复成功！<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgwu4hoqj30hu0rigml" alt=""></p><h1 id="修复-step-1：startEngine"><a href="#修复-step-1：startEngine" class="headerlink" title="修复 step 1：startEngine"></a>修复 step 1：startEngine</h1><pre><code class="Objective-C">[JPEngine startEngine];</code></pre><p>该方法向<code>JSContext</code>环境注册了一系列供js调用oc方法的block，这些 block 内部大多是 调用 <code>runtime</code> 相关接口的 static 函数。最终读取<code>JSPatch.js</code>中的代码到<code>JSContext</code>环境，使得<code>main.js</code>可以调用<code>JSPatch.js</code>中定义的方法。<br>调用关系大致如下：</p><pre><code>main.js ---&gt;  JSPatch.js ---&gt; OC Block ---&gt; runtime </code></pre><p><strong>源码解读：</strong></p><pre><code class="Objective-C">+ (void)startEngine{//    1.判断是否存在 JSContext 类. ---&gt; iOS 7.0 以下不支持 JavaScriptCore    if (![JSContext class] || _context) {        return;    }//    2.创建一个 JS 运行环境.    JSContext *context = [[JSContext alloc] init];//    3.为了使 JSPatch.js 可以访问 JPEngine 中定义的 C 函数，需为 context 注册 block.//    3.1 创建类.    context[@&quot;_OC_defineClass&quot;] = ^(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) {        return defineClass(classDeclaration, instanceMethods, classMethods);    };//    3.2 给类实现某协议.    context[@&quot;_OC_defineProtocol&quot;] = ^(NSString *protocolDeclaration, JSValue *instProtocol, JSValue *clsProtocol) {        return defineProtocol(protocolDeclaration, instProtocol,clsProtocol);    };//    3.3 js调用oc的实例方法.    context[@&quot;_OC_callI&quot;] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) {        return callSelector(nil, selectorName, arguments, obj, isSuper);    };//    3.4 js调用oc的类方法.    context[@&quot;_OC_callC&quot;] = ^id(NSString *className, NSString *selectorName, JSValue *arguments) {        return callSelector(className, selectorName, arguments, nil, NO);    };//    3.5 js 对象转 oc 对象.    context[@&quot;_OC_formatJSToOC&quot;] = ^id(JSValue *obj) {        return formatJSToOC(obj);    };//    3.6 oc 对象 转 js 对象.    context[@&quot;_OC_formatOCToJS&quot;] = ^id(JSValue *obj) {        return formatOCToJS([obj toObject]);    };//    3.7 获取对象的动态成员变量.    context[@&quot;_OC_getCustomProps&quot;] = ^id(JSValue *obj) {        id realObj = formatJSToOC(obj);        return objc_getAssociatedObject(realObj, kPropAssociatedObjectKey);    };//    3.8 给对象动态添加成员变量.    context[@&quot;_OC_setCustomProps&quot;] = ^(JSValue *obj, JSValue *val) {        id realObj = formatJSToOC(obj);        objc_setAssociatedObject(realObj, kPropAssociatedObjectKey, val, OBJC_ASSOCIATION_RETAIN_NONATOMIC);    };//    3.9 给 js 对象设置 weak.    context[@&quot;__weak&quot;] = ^id(JSValue *jsval) {        id obj = formatJSToOC(jsval);        return [[JSContext currentContext][@&quot;_formatOCToJS&quot;] callWithArguments:@[formatOCToJS([JPBoxing boxWeakObj:obj])]];    };//    3.10 给 js 对象设置 strong.    context[@&quot;__strong&quot;] = ^id(JSValue *jsval) {        id obj = formatJSToOC(jsval);        return [[JSContext currentContext][@&quot;_formatOCToJS&quot;] callWithArguments:@[formatOCToJS(obj)]];    };//    3.11 获取 oc 对象超类.    context[@&quot;_OC_superClsName&quot;] = ^(NSString *clsName) {        Class cls = NSClassFromString(clsName);        return NSStringFromClass([cls superclass]);    };//    3.12 是否自动转换类型.    context[@&quot;autoConvertOCType&quot;] = ^(BOOL autoConvert) {        _autoConvert = autoConvert;    };//    3.13 oc number 转换为 string.    context[@&quot;convertOCNumberToString&quot;] = ^(BOOL convertOCNumberToString) {        _convertOCNumberToString = convertOCNumberToString;    };//    3.14 在JS中调用include方法,可以在一个JS文件中加载其他JS文件.    context[@&quot;include&quot;] = ^(NSString *filePath) {        NSString *absolutePath = [_scriptRootDir stringByAppendingPathComponent:filePath];        if (!_runnedScript) {            _runnedScript = [[NSMutableSet alloc] init];        }        if (absolutePath &amp;&amp; ![_runnedScript containsObject:absolutePath]) {            [JPEngine _evaluateScriptWithPath:absolutePath];            [_runnedScript addObject:absolutePath];        }    };//    3.15 获取资源文件路径.    context[@&quot;resourcePath&quot;] = ^(NSString *filePath) {        return [_scriptRootDir stringByAppendingPathComponent:filePath];    };//    3.16 让 js 方法延迟执行.    context[@&quot;dispatch_after&quot;] = ^(double time, JSValue *func) {        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{            [func callWithArguments:nil];        });    };//    3.17 让js方法在 main queue dispatch async 执行.    context[@&quot;dispatch_async_main&quot;] = ^(JSValue *func) {        dispatch_async(dispatch_get_main_queue(), ^{            [func callWithArguments:nil];        });    };//    3.18 让js方法在 main queue dispatch sync 执行.    context[@&quot;dispatch_sync_main&quot;] = ^(JSValue *func) {        if ([NSThread currentThread].isMainThread) {            [func callWithArguments:nil];        } else {            dispatch_sync(dispatch_get_main_queue(), ^{                [func callWithArguments:nil];            });        }    };//    3.19 让js方法在 global queue dispatch async 执行.    context[@&quot;dispatch_async_global_queue&quot;] = ^(JSValue *func) {        dispatch_async(dispatch_get_global_queue(0, 0), ^{            [func callWithArguments:nil];        });    };//    3.20 释放js创建的oc对象.    context[@&quot;releaseTmpObj&quot;] = ^void(JSValue *jsVal) {        if ([[jsVal toObject] isKindOfClass:[NSDictionary class]]) {            void *pointer =  [(JPBoxing *)([jsVal toObject][@&quot;__obj&quot;]) unboxPointer];            id obj = *((__unsafe_unretained id *)pointer);            @synchronized(_TMPMemoryPool) {                [_TMPMemoryPool removeObjectForKey:[NSNumber numberWithInteger:[(NSObject*)obj hash]]];            }        }    };//    3.21 js调用oc方法进行打印.    context[@&quot;_OC_log&quot;] = ^() {        NSArray *args = [JSContext currentArguments];        for (JSValue *jsVal in args) {            id obj = formatJSToOC(jsVal);            NSLog(@&quot;JSPatch.log: %@&quot;, obj == _nilObj ? nil : (obj == _nullObj ? [NSNull null]: obj));        }    };//    3.22 将js捕捉到的异常交给oc方法处理.    context[@&quot;_OC_catch&quot;] = ^(JSValue *msg, JSValue *stack) {        _exceptionBlock([NSString stringWithFormat:@&quot;js exception, \nmsg: %@, \nstack: \n %@&quot;, [msg toObject], [stack toObject]]);    };//    4. 注册 JSContext 执行出现异常时的回调.    context.exceptionHandler = ^(JSContext *con, JSValue *exception) {        NSLog(@&quot;%@&quot;, exception);        _exceptionBlock([NSString stringWithFormat:@&quot;js exception: %@&quot;, exception]);    };//    5. 创建OC中的null对象，转换成js的null对象，并设置到JSContext实例让js代码可以获取.    _nullObj = [[NSObject alloc] init];    context[@&quot;_OC_null&quot;] = formatOCToJS(_nullObj);//    6. 保存 context.    _context = context;//    7. oc 中的 nil 对象.    _nilObj = [[NSObject alloc] init];//    8. 同步锁.    _JSMethodSignatureLock = [[NSLock alloc] init];    _JSMethodForwardCallLock = [[NSRecursiveLock alloc] init];//    9. 在 JSPatch 中注册过的结构体定义（键：结构体名）.    _registeredStruct = [[NSMutableDictionary alloc] init];//    10. 注册内存警告通知.#if TARGET_OS_IPHONE    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleMemoryWarning) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];#endif//    11. 读取JSPatch.js，方便传入的js代码中使用JSPatch.js提供的函数.    NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@&quot;JSPatch&quot; ofType:@&quot;js&quot;];    if (!path) _exceptionBlock(@&quot;can&#39;t find JSPatch.js&quot;);    NSString *jsCore = [[NSString alloc] initWithData:[[NSFileManager defaultManager] contentsAtPath:path] encoding:NSUTF8StringEncoding];//    12. 加载 JSPatch.js 中的所有 js 代码到JSContext.    if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) {        [_context evaluateScript:jsCore withSourceURL:[NSURL URLWithString:@&quot;JSPatch.js&quot;]];    } else {        [_context evaluateScript:jsCore];    }}</code></pre><p>一张图总结 JSPatch 的功能结构：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgx6km6jj31g20oejvf" alt=""></p><h1 id="修复-step-2：-c-元函数"><a href="#修复-step-2：-c-元函数" class="headerlink" title="修复 step 2：__c()元函数"></a>修复 step 2：__c()元函数</h1><p>接下来读取<code>main.js</code>代码后执行：</p><pre><code class="Objective-C">[JPEngine evaluateScript:script];</code></pre><p>该接口并非直接将<code>main.js</code>代码提交到<code>JSContext</code>环境执行，而是先调用<code>_evaluateScript: withSourceURL:</code>方法对<code>main.js</code>原始代码做些修改。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">+ (JSValue *)_evaluateScript:(NSString *)script withSourceURL:(NSURL *)resourceURL{//    1. script 不存在或当前 iOS 版本低于 7.0 退出.    if (!script || ![JSContext class]) {        _exceptionBlock(@&quot;script is nil&quot;);        return nil;    }    [self startEngine];//    2. 正则式构建 (?&lt;!\\\\)\\.\\s*(\\w+)\\s*\\(    if (!_regex) {        _regex = [NSRegularExpression regularExpressionWithPattern:_regexStr options:0 error:nil];    }//    3. 使用正则式处理 传入的 js代码 &gt;&gt;&gt; 将 alloc()这样的函数调用 替换成 __c(&quot;alloc&quot;)()    NSString *formatedScript = [NSString stringWithFormat:@&quot;;(function(){try{%@}catch(e){_OC_catch(e.message, e.stack)}})();&quot;, [_regex stringByReplacingMatchesInString:script options:0 range:NSMakeRange(0, script.length) withTemplate:_replaceStr]];//    4.将正则处理后的js代码加载到 context 执行.(进入 JavaScriptCore)    @try {        if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) {            return [_context evaluateScript:formatedScript withSourceURL:resourceURL];        } else {            return [_context evaluateScript:formatedScript];        }    }    @catch (NSException *exception) {        _exceptionBlock([NSString stringWithFormat:@&quot;%@&quot;, exception]);    }    return nil;}</code></pre><p>断点调试看一下<code>script</code>经正则处理之后的结果：</p><pre><code class="JavaScript">;(function(){try{defineClass(&#39;ViewController&#39;, {  pushAlertView: function(sender) {    require(&#39;UIAlertView&#39;);    var alert = UIAlertView.__c(&quot;alloc&quot;)().__c(&quot;initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles&quot;)(&quot;alert&quot;, null, null, &quot;ok&quot;, null, null);    alert.__c(&quot;show&quot;)();  }})}catch(e){_OC_catch(e.message, e.stack)}})();</code></pre><p>除了添加一些关键字和异常处理外，最大的变化在于所有函数调用变成了<code>__c(&quot;function&quot;)</code>的形式。据作者讲这是<code>JSPatch</code>开发过程中最核心的问题，该问题的解决方案也是<code>JSPatch</code>中最精妙之处。<br>我们进行热修复期望的效果是这样：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgxnadadj307008u75a" alt=""><br>但JS 对于调用没定义的属性/变量，只会马上抛出异常，而不像 OC/Lua/ruby 那样有转发机制。因此对于用户传入的js代码中，类似<code>UIView().alloc().init()</code>这样的代码，js其实根本没办法进行处理。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgxwfj9fj30dx01zgma" alt=""><br>一种解决方案是实现所有js类继承机制，每一个类和方法都事先定义好：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgy4x9ovj30hg0403zr" alt=""><br>这种方案是不太现实的，为了调用某个方法需要把该类的所有方法都引进来，占用内存极高（<code>NSObject</code>类有将近1000个方法）。</p><p>作者最终想出了第二种方案：</p><blockquote><p>在 OC 执行 JS 脚本前，通过正则把所有方法调用都改成调用 __c() 函数，再执行这个 JS 脚本，做到了类似 OC/Lua/Ruby 等的消息转发机制。</p></blockquote><pre><code class="JavaScript">UIView.alloc().init()-&gt;UIView.__c(&#39;alloc&#39;)().__c(&#39;init&#39;)()</code></pre><p><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgyd3gl2j30cf0b6dhf" alt=""><br>给 JS 对象基类 Object 的 <code>prototype</code> 加上 c 成员，这样所有对象都可以调用到 c，根据当前对象类型判断进行不同操作：</p><pre><code class="JavaScript">__c: function(methodName) {      ...      ...      return function(){        var args = Array.prototype.slice.call(arguments)        return _methodFunc(slf.__obj, slf.__clsName, methodName, args, slf.__isSuper)      }    }</code></pre><p><code>_methodFunc()</code> 把相关信息传给OC，OC用 Runtime 接口调用相应方法，返回结果值，这个调用就结束了。<br><strong>源码解读：</strong></p><pre><code class="JavaScript"> /**   *  instance: 对象   *  clsName: 类名   *  methodName: 方法名   *  args: 参数列表   *  isSuper: 是否调用super父类的方法   *  isPerformSelector:是否用performSelector方式调用   */  var _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) {    var selectorName = methodName    if (!isPerformSelector) {//  不是 performSelector方式的方法调用流程//  处理得到OC中的方法SEL      methodName = methodName.replace(/__/g, &quot;-&quot;)      selectorName = methodName.replace(/_/g, &quot;:&quot;).replace(/-/g, &quot;_&quot;)      var marchArr = selectorName.match(/:/g)      var numOfArgs = marchArr ? marchArr.length : 0      if (args.length &gt; numOfArgs) {        selectorName += &quot;:&quot;      }    }//  获取调用OC方法后的返回值//  如果是获取一个OC对象，那么ret = {&quot;__obj&quot;:OC对象},因为OC把对象返回给js之前会先包装成NSDictionary    var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):                         _OC_callC(clsName, selectorName, args)//  获取OC方法执行完毕的返回值，并转化成JS对象    return _formatOCToJS(ret)  }</code></pre><h1 id="修复-step-3：global-defineClass"><a href="#修复-step-3：global-defineClass" class="headerlink" title="修复 step 3：global.defineClass"></a>修复 step 3：global.defineClass</h1><p>原脚本代码经过正则处理后交由<code>JSContext</code>环境去执行：</p><pre><code class="Objective-C">[_context evaluateScript:formatedScript withSourceURL:resourceURL];</code></pre><p>回过头看<code>main.js</code>的代码（处理后的）：</p><pre><code class="JavaScript">defineClass(`ViewController`,{instaceMethods...},{classMethods...})</code></pre><p>参数依次为类名、实例方法列表、类方法列表。阅读<code>global.defineClass</code>源码会发现<code>defineClass</code>首先会分别对两个方法列表调用<code>_formatDefineMethods</code>，该方法参数有三个：方法列表（js对象）、空js对象、真实类名：</p><pre><code class="Javascript">  var _formatDefineMethods = function(methods, newMethods, realClsName) {    for (var methodName in methods) {      if (!(methods[methodName] instanceof Function)) return;      (function(){        var originMethod = methods[methodName]        newMethods[methodName] = [originMethod.length, function() {          try {            var args = _formatOCToJS(Array.prototype.slice.call(arguments))            var lastSelf = global.self            global.self = args[0]            if (global.self) global.self.__realClsName = realClsName            args.splice(0,1)            var ret = originMethod.apply(originMethod, args)            global.self = lastSelf            return ret          } catch(e) {            _OC_catch(e.message, e.stack)          }        }]      })()    }  }</code></pre><p>该段代码遍历方法列表对象的方法名，向js空对象中添加属性：方法名为键，一个数组为值。数组第一个元素为对应实现函数的参数个数，第二个元素是方法的具体实现。也就是说，<code>_formatDefineMethods</code>将 <code>defineClass</code>传递过来的js对象进行了修改：</p><pre><code class="JavaScript">{    methodName:function(args...){...}}--&gt;{    methodName:[argCount,function(args...){...新实现}]}</code></pre><p><strong><em>1. 为什么要传递参数个数？</em></strong><br>因为<code>runtime</code>修复类的时候无法直接解析js实现函数，也就无法知道参数个数，但方法替换的过程需要生成方法签名，所以只能从js端拿到js函数的参数个数，并传递给OC。</p><p><strong><em>2. 为什么要修改方法实现？</em></strong></p><ul><li>参数转化为js对象。这涉及到对象生命周期的管理，具体查看<a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=1&amp;sn=c7d9ee27eff35688180bdc840d31120b&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">&lt;实现原理一&gt;</a>4.对象持有／转换。</li><li>self 处理。使得js修复代码中我们可以像在 OC 中一样使用self，具体查看<a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=1&amp;sn=c7d9ee27eff35688180bdc840d31120b&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">&lt;实现原理一&gt;</a>6.self 关键字。</li><li><code>args.splice(0,1)</code>删除前两个参数：<br>OC中进行消息转发，前两个参数是<code>self</code>和<code>selector</code>，实际调用js的具体实现的时候，需要把这两个参数删除。</li></ul><p>我们可以使用 safari 对 JSPatch.js 进行调试（<a href="https://github.com/bang590/JSPatch/wiki/JS-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95" target="_blank" rel="noopener">JS 断点调试</a>）看看处理之后的<code>newInstMethods</code>：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgyn54lfj30r80opn5m" alt=""></p><p>回到<code>defineClass</code>，调用<code>_formatDefineMethods</code>之后，拿着要重写的类名和经过处理的js对象，调用<code>_OC_defineClass</code>，也就是OC端定义的block方法。</p><h1 id="修复-step-4：-OC-defineClass"><a href="#修复-step-4：-OC-defineClass" class="headerlink" title="修复 step 4：_OC_defineClass"></a>修复 step 4：_OC_defineClass</h1><p><code>JPEngine</code>中的<code>defineClass</code>对类进行真正的重写操作，将类名、<code>selector</code>、方法实现（IMP）、方法签名等<code>runtime</code>重写方法所需的基本元素提取出来。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  定义一个类／覆盖或新增一个方法. * *  @param classDeclaration 类的声明（需要替换或者新增的类名:继承的父类名 &lt;实现的协议1，实现的协议2&gt;） *  @param instanceMethods  {实例方法} *  @param classMethods     {类方法} * *  @return 返回@{@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName} */static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods){//    1.使用 NSScanner 分离 classDeclaration.    NSScanner *scanner = [NSScanner scannerWithString:classDeclaration];    NSString *className;        //类名    NSString *superClassName;   //父类名    NSString *protocolNames;    //实现的协议名    [scanner scanUpToString:@&quot;:&quot; intoString:&amp;className];    if (!scanner.isAtEnd) {        scanner.scanLocation = scanner.scanLocation + 1;        [scanner scanUpToString:@&quot;&lt;&quot; intoString:&amp;superClassName];        if (!scanner.isAtEnd) {            scanner.scanLocation = scanner.scanLocation + 1;            [scanner scanUpToString:@&quot;&gt;&quot; intoString:&amp;protocolNames];        }    }    if (!superClassName) superClassName = @&quot;NSObject&quot;;    className = trim(className);    superClassName = trim(superClassName);    NSArray *protocols = [protocolNames length] ? [protocolNames componentsSeparatedByString:@&quot;,&quot;] : nil;//    2.获取该Class对象.    Class cls = NSClassFromString(className);    if (!cls) {        Class superCls = NSClassFromString(superClassName);        if (!superCls) {            _exceptionBlock([NSString stringWithFormat:@&quot;can&#39;t find the super class %@&quot;, superClassName]);            return @{@&quot;cls&quot;: className};        }//        2.1 该Class对象为nil，为JS端添加一个新的类.        cls = objc_allocateClassPair(superCls, className.UTF8String, 0);        objc_registerClassPair(cls);    }    if (protocols.count &gt; 0) {        for (NSString* protocolName in protocols) {            Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:NSUTF8StringEncoding]);            class_addProtocol (cls, protocol);        }    }    for (int i = 0; i &lt; 2; i ++) {        BOOL isInstance = i == 0;        JSValue *jsMethods = isInstance ? instanceMethods: classMethods;//        3.若是添加实例方法，直接使用Class对象；//          若是添加类方法，需要获取元类.        Class currCls = isInstance ? cls: objc_getMetaClass(className.UTF8String);//      把js对象转换成OC的字典，从而可以取到方法名、参数个数、具体实现.        NSDictionary *methodDict = [jsMethods toDictionary];        for (NSString *jsMethodName in methodDict.allKeys) {//            遍历字典的key，即方法名，根据方法名取出的值还是JSValue对象，它代表的是数组，第一个值是参数的个数，第二个值是函数的实现.            JSValue *jsMethodArr = [jsMethods valueForProperty:jsMethodName];            int numberOfArg = [jsMethodArr[0] toInt32];            NSString *selectorName = convertJPSelectorString(jsMethodName);            if ([selectorName componentsSeparatedByString:@&quot;:&quot;].count - 1 &lt; numberOfArg) {                selectorName = [selectorName stringByAppendingString:@&quot;:&quot;];            }            JSValue *jsMethod = jsMethodArr[1];            if (class_respondsToSelector(currCls, NSSelectorFromString(selectorName))) {//                4.如果要替换的类已经定义了该方法，直接对该方法替换和实现消息转发.                overrideMethod(currCls, selectorName, jsMethod, !isInstance, NULL);            } else {                BOOL overrided = NO;                for (NSString *protocolName in protocols) {//                    5.1 遍历protocolsNames，依次获取协议对象和协议方法中的type和name                    char *types = methodTypesInProtocol(protocolName, selectorName, isInstance, YES);                    if (!types) types = methodTypesInProtocol(protocolName, selectorName, isInstance, NO);                    if (types) {//                        对协议方法实现消息转发.                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, types);                        free(types);                        overrided = YES;                        break;                    }                }                if (!overrided) {//                    5.2 上述两种情况都不满足.js端请求添加一个新的方法.                    if (![[jsMethodName substringToIndex:1] isEqualToString:@&quot;_&quot;]) {//                      方法名的处理：_改为:                        NSMutableString *typeDescStr = [@&quot;@@:&quot; mutableCopy];                        for (int i = 0; i &lt; numberOfArg; i ++) {                            [typeDescStr appendString:@&quot;@&quot;];                        }//                        构造一个typeDescription为&quot;@@:\@*&quot;的IMP.将这个IMP添加到类中.                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, [typeDescStr cStringUsingEncoding:NSUTF8StringEncoding]);                    }                }            }        }    }//    6.为该类添加两个方法，使js脚本拥有设置property的方法.#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;    class_addMethod(cls, @selector(getProp:), (IMP)getPropIMP, &quot;@@:@&quot;);    class_addMethod(cls, @selector(setProp:forKey:), (IMP)setPropIMP, &quot;v@:@@&quot;);#pragma clang diagnostic pop//    7.返回字典给js脚本    return @{@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName};}</code></pre><p>由源码可见，方法名、实现等处理好之后最终执行<code>overrideMethod</code>方法。</p><p>#修复 step 5：overrideMethod<br><code>overrideMethod</code>是实现<strong>“替换”</strong>的最后一步。通过调用一系列runtime 方法增加／替换实现的api，使用<code>jsvalue</code>中将要替换的方法实现来替换oc类中的方法实现。<br>该函数做的事情比较多，一张图概括如下：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgyvh58sj313o0u0785" alt=""><br><strong><em>4.向class添加名为ORIG＋selector，对应原始selector的IMP。</em></strong><br>这一步是为了让js通过这个方法调用原来的实现。</p><p><strong><em>5.向class添加名为<code>ORIGforwardInvocation</code>的方法，实现是原始的<code>forwardInvocation</code>的IMP。</em></strong><br>这一步是为了保存<code>forwardInvocation</code>的旧有实现，在新的实现中做判断，如果转发的方法是欲改写的，就走新逻辑，反之走原来的流程。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  使用jsvalue中将要替换的方法实现来替换oc类中的方法实现 * *  @param cls             被替换的类 *  @param selectorName    被替换实现的SEL *  @param function        在js中定义的将要替换的新的实现 *  @param isClassMethod   是否类方法（如果是--&gt;寻找MetaClass） *  @param typeDescription 被替换的实现方法的编码 */static void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription){//    1. 要重写的方法的SEL.    SEL selector = NSSelectorFromString(selectorName);//    2. 获取重写方法的具体实现函数的格式编码.    if (!typeDescription) {        Method method = class_getInstanceMethod(cls, selector);        typeDescription = (char *)method_getTypeEncoding(method);    }//    3.获取 class 中被重写 SEL 对应的原始IMP.    IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : NULL;//    4.准备进入消息转发处理的系统函数实现IMP.    IMP msgForwardIMP = _objc_msgForward;//    5.针对“非 arm64”架构，消息转发应使用 _objc_msgForward_stret 系统函数.//      因为_objc_msgForward函数在cpu架构不是 arm64 时，处理返回值是一些特殊 struct 时可能造成 crash.    #if !defined(__arm64__)        if (typeDescription[0] == &#39;{&#39;) {            //In some cases that returns struct, we should use the &#39;_stret&#39; API:            //http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html            //NSMethodSignature knows the detail but has no API to return, we can only get the info from debugDescription.            NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:typeDescription];            if ([methodSignature.debugDescription rangeOfString:@&quot;is special struct return? YES&quot;].location != NSNotFound) {                msgForwardIMP = (IMP)_objc_msgForward_stret;            }        }    #endif#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;    if (class_getMethodImplementation(cls, @selector(forwardInvocation:)) != (IMP)JPForwardInvocation) {//     6.将cls中原来 forwardInvocaiton: 的实现替换成 JPForwardInvocation:函数实现.//       class_replaceMethod()返回的是替换之前的 IMP.        IMP originalForwardImp = class_replaceMethod(cls, @selector(forwardInvocation:), (IMP)JPForwardInvocation, &quot;v@:@&quot;);        if (originalForwardImp) {//     7.为cls添加新的SEL(ORIGforwardInvocation:)，指向原始 forwardInvocation: 的实现IMP.            class_addMethod(cls, @selector(ORIGforwardInvocation:), originalForwardImp, &quot;v@:@&quot;);        }    }#pragma clang diagnostic pop    [cls jp_fixMethodSignature];    if (class_respondsToSelector(cls, selector)) {        NSString *originalSelectorName = [NSString stringWithFormat:@&quot;ORIG%@&quot;, selectorName];        SEL originalSelector = NSSelectorFromString(originalSelectorName);        if(!class_respondsToSelector(cls, originalSelector)) {//      8.为cls添加新的SEL(ORIG...:)指向被替换方法的原始实现IMP.            class_addMethod(cls, originalSelector, originalImp, typeDescription);        }    }//      9.构造替换实现后的新SEL:(JP...)    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];//     10.记录新SEL对应js传过来的待替换目标方法的实现.    _initJPOverideMethods(cls);    _JSOverideMethods[cls][JPSelectorName] = function;//    11.替换原SEL的实现IMP为msgForwardIMP//       让被替换的方法调用时，直接进入“消息转发”流程（_objc_msgForward 或 _objc_msgForward_stret）//       这一步放到最后是为了避免在 overrideMethod 过程中调用原sel导致的线程问题.    class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);}</code></pre><p>至此，<code>selector</code>具体实现 IMP 的替换工作已经完成了。接下来便可以分析一下点击button后的<code>handle</code>事件。</p><p>#调用 step 1：JPForwardInvocation<br>经过上一步处理，<code>handle:</code>直接走<code>objc_msgForward</code>进行消息转发环节。当点击button，调用<code>handle:</code>的时候，函数调用的参数会被封装到<code>NSInvocation</code>对象，走到<code>forwardInvocation</code>方法。上一步中<code>forwardInvocation</code>方法的实现替换成了<code>JPForwardInvocation</code>，<strong>负责拦截系统消息转发函数传入的<code>NSInvocation</code>并从中获取到所有的方法执行参数值，是实现替换和新增方法的核心</strong>。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  替换原有的forwarInvocation:方法 * *  @param assignSlf  self *  @param selector   原始SEL *  @param invocation 封装了函数调用参数的NSInvocation对象 */static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation){//    1.表示oc对象是否已经被释放    BOOL deallocFlag = NO;    id slf = assignSlf;//    2.获取invocation中参数的数量    NSMethodSignature *methodSignature = [invocation methodSignature];    NSInteger numberOfArguments = [methodSignature numberOfArguments];//    3.转化调用的SEL为JPSEL（这是JSPatch中缓存JSValue* function的key格式）    NSString *selectorName = NSStringFromSelector(invocation.selector);    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];//    4.判断JPSEL是否有对应的js函数的实现，如果没有就走原始方法的消息转发的流程.    JSValue *jsFunc = getJSFunctionInObjectHierachy(slf, JPSelectorName);    if (!jsFunc) {        JPExecuteORIGForwardInvocation(slf, selector, invocation);        return;    }//    5.从NSInvocation中获取调用的参数，把self与相应的参数都转换成js对象并封装到一个集合中//      js端重写的函数，传递过来是JSValue类型，用callWithArgument:调用js方法，参数也要是js对象.//    5.1 初始化数组，存储NSInvacation中获取的参数列表，传给对应的js函数    NSMutableArray *argList = [[NSMutableArray alloc] init];    if ([slf class] == slf) {//        5.2 类方法：设置__clsName标识表明这是一个类对象        [argList addObject:[JSValue valueWithObject:@{@&quot;__clsName&quot;: NSStringFromClass([slf class])} inContext:_context]];    } else if ([selectorName isEqualToString:@&quot;dealloc&quot;]) {//        5.3 要被释放的对象：使用assign来保存self指针        [argList addObject:[JPBoxing boxAssignObj:slf]];        deallocFlag = YES;    } else {//        5.4 使用 weak 保存self 指针        [argList addObject:[JPBoxing boxWeakObj:slf]];    }//    5.5 NSInvocation 对象的前两个参数是self和_cmd（http://stackoverflow.com/questions/5788346/calling-a-selector-with-unknown-number-of-arguments-using-reflection-introspec）//    所以直接从第3个参数开始获取    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];//        返回值如果是const，获取encoding来判断类型.        switch(argumentType[0] == &#39;r&#39; ? argumentType[1] : argumentType[0]) {//                从invocation中获取参数，添加到argList中.            #define JP_FWD_ARG_CASE(_typeChar, _type) \            case _typeChar: {   \                _type arg;  \                [invocation getArgument:&amp;arg atIndex:i];    \                [argList addObject:@(arg)]; \                break;  \            }            JP_FWD_ARG_CASE(&#39;c&#39;, char)            JP_FWD_ARG_CASE(&#39;C&#39;, unsigned char)            JP_FWD_ARG_CASE(&#39;s&#39;, short)            JP_FWD_ARG_CASE(&#39;S&#39;, unsigned short)            JP_FWD_ARG_CASE(&#39;i&#39;, int)            JP_FWD_ARG_CASE(&#39;I&#39;, unsigned int)            JP_FWD_ARG_CASE(&#39;l&#39;, long)            JP_FWD_ARG_CASE(&#39;L&#39;, unsigned long)            JP_FWD_ARG_CASE(&#39;q&#39;, long long)            JP_FWD_ARG_CASE(&#39;Q&#39;, unsigned long long)            JP_FWD_ARG_CASE(&#39;f&#39;, float)            JP_FWD_ARG_CASE(&#39;d&#39;, double)            JP_FWD_ARG_CASE(&#39;B&#39;, BOOL)            case &#39;@&#39;: {//                id类型参数使用__unsafe__unretained                __unsafe_unretained id arg;                [invocation getArgument:&amp;arg atIndex:i];//                block参数使用copy，_nilObj表示nil                if ([arg isKindOfClass:NSClassFromString(@&quot;NSBlock&quot;)]) {                    [argList addObject:(arg ? [arg copy]: _nilObj)];                } else {                    [argList addObject:(arg ? arg: _nilObj)];                }                break;            }            case &#39;{&#39;: {//                处理结构体类型参数//                获取结构体类型名称，把参数包装成JSValue类型                NSString *typeString = extractStructName([NSString stringWithUTF8String:argumentType]);                #define JP_FWD_ARG_STRUCT(_type, _transFunc) \                if ([typeString rangeOfString:@#_type].location != NSNotFound) {    \                    _type arg; \                    [invocation getArgument:&amp;arg atIndex:i];    \                    [argList addObject:[JSValue _transFunc:arg inContext:_context]];  \                    break; \                }                JP_FWD_ARG_STRUCT(CGRect, valueWithRect)                JP_FWD_ARG_STRUCT(CGPoint, valueWithPoint)                JP_FWD_ARG_STRUCT(CGSize, valueWithSize)                JP_FWD_ARG_STRUCT(NSRange, valueWithRange)//                自定义类型的结构体处理                @synchronized (_context) {                    NSDictionary *structDefine = _registeredStruct[typeString];                    if (structDefine) {                        size_t size = sizeOfStructTypes(structDefine[@&quot;types&quot;]);                        if (size) {                            void *ret = malloc(size);                            [invocation getArgument:ret atIndex:i];                            NSDictionary *dict = getDictOfStruct(ret, structDefine);                            [argList addObject:[JSValue valueWithObject:dict inContext:_context]];                            free(ret);                            break;                        }                    }                }                break;            }            case &#39;:&#39;: {//                selector类型处理                SEL selector;                [invocation getArgument:&amp;selector atIndex:i];                NSString *selectorName = NSStringFromSelector(selector);                [argList addObject:(selectorName ? selectorName: _nilObj)];                break;            }            case &#39;^&#39;:            case &#39;*&#39;: {//                指针类型处理                void *arg;                [invocation getArgument:&amp;arg atIndex:i];                [argList addObject:[JPBoxing boxPointer:arg]];                break;            }            case &#39;#&#39;: {//                Class类型                Class arg;                [invocation getArgument:&amp;arg atIndex:i];                [argList addObject:[JPBoxing boxClass:arg]];                break;            }            default: {                NSLog(@&quot;error type %s&quot;, argumentType);                break;            }        }    }    if (_currInvokeSuperClsName) {        Class cls = NSClassFromString(_currInvokeSuperClsName);        NSString *tmpSelectorName = [[selectorName stringByReplacingOccurrencesOfString:@&quot;_JPSUPER_&quot; withString:@&quot;_JP&quot;] stringByReplacingOccurrencesOfString:@&quot;SUPER_&quot; withString:@&quot;_JP&quot;];        if (!_JSOverideMethods[cls][tmpSelectorName]) {            NSString *ORIGSelectorName = [selectorName stringByReplacingOccurrencesOfString:@&quot;SUPER_&quot; withString:@&quot;ORIG&quot;];            [argList removeObjectAtIndex:0];            id retObj = callSelector(_currInvokeSuperClsName, ORIGSelectorName, [JSValue valueWithObject:argList inContext:_context], [JSValue valueWithObject:@{@&quot;__obj&quot;: slf, @&quot;__realClsName&quot;: @&quot;&quot;} inContext:_context], NO);            id __autoreleasing ret = formatJSToOC([JSValue valueWithObject:retObj inContext:_context]);            [invocation setReturnValue:&amp;ret];            return;        }    }//    6.将上面获得的参数列表数组转化为对应的js对象数组    NSArray *params = _formatOCToJSList(argList);    char returnType[255];//    7.获取返回值类型    strcpy(returnType, [methodSignature methodReturnType]);    // Restore the return type    if (strcmp(returnType, @encode(JPDouble)) == 0) {        strcpy(returnType, @encode(double));    }    if (strcmp(returnType, @encode(JPFloat)) == 0) {        strcpy(returnType, @encode(float));    }//    7.1 返回值是否为const，如果是，获取后面的encoding来判断类型    switch (returnType[0] == &#39;r&#39; ? returnType[1] : returnType[0]) {    ...(返回值的其它封装规则，具体看源码)    }    if (_pointersToRelease) {        for (NSValue *val in _pointersToRelease) {            void *pointer = NULL;            [val getValue:&amp;pointer];            CFRelease(pointer);        }        _pointersToRelease = nil;    }//    8.待替换的方法是 delloc 需要特殊处理：    if (deallocFlag) {        slf = nil;        Class instClass = object_getClass(assignSlf);        Method deallocMethod = class_getInstanceMethod(instClass, NSSelectorFromString(@&quot;ORIGdealloc&quot;));        //获取原delloc imp 指针，调用delloc，防止内存泄漏.        void (*originalDealloc)(__unsafe_unretained id, SEL) = (__typeof__(originalDealloc))method_getImplementation(deallocMethod);        originalDealloc(assignSlf, NSSelectorFromString(@&quot;dealloc&quot;));    }}</code></pre><p>接下来执行JS中定义的方法实现。“修复 step 2”中已经讨论过，现在main.js中所有的函数都被替换成名为<code>__c(&#39;methodName&#39;)</code>的函数调用，<code>__c</code>调用了<code>_methodFunc</code>函数，<code>_methodFunc</code>会根据方法类型调用<code>_OC_call</code>：</p><pre><code class="JavaScript">var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):                         _OC_callC(clsName, selectorName, args)</code></pre><p><code>_OC_callI</code>或<code>_OC_callC</code>最终都会调用一个<code>static</code>函数<code>callSelector</code>。</p><h1 id="调用-step-2：callSelector"><a href="#调用-step-2：callSelector" class="headerlink" title="调用 step 2：callSelector"></a>调用 step 2：callSelector</h1><p><code>main.js</code>中类似<code>UIAlertView.alloc().init()</code>实际是通过<code>callSelector</code>调用 OC 的方法。</p><ul><li>将 js 对象和参数转化为 OC 对象；</li><li>判断是否调用的是父类的方法，如果是，就走父类的方法实现；</li><li>把参数等信息封装成NSInvocation对象，并执行，然后返回结果。</li></ul><p><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  完成oc中的方法调用 * *  @param className    类名（nil --&gt; 表示实例方法） *  @param selectorName 方法SEL值 *  @param arguments    方法执行参数 *  @param instance     对象（js对象中的变量，如: var UIAlertView = { __clsName : &#39;UIAlertView&#39;}） *  @param isSuper      是否调用的是父类方法 * *  @return 方法执行后的结果值，返回给js代码中. */static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper){    NSString *realClsName = [[instance valueForProperty:@&quot;__realClsName&quot;] toString];    if (instance) {//    1.将js封装的instance对象进行拆装，得到oc对象.        instance = formatJSToOC(instance);        if (!instance || instance == _nilObj || [instance isKindOfClass:[JPBoxing class]]) return @{@&quot;__isNil&quot;: @(YES)};    }//    2.将js封装的参数列表转为oc类型.    id argumentsObj = formatJSToOC(arguments);    if (instance &amp;&amp; [selectorName isEqualToString:@&quot;toJS&quot;]) {//      3.如果要执行的方法是&quot;toJS&quot;，即转化为js类型，对于NSString/NSDictory/NSArray/NSData需进行特殊处理//        因为JSPatch中需使用JPBoxing包装OC中的上述对象，防止JavaScriptCore.framework转换类型.        if ([instance isKindOfClass:[NSString class]] || [instance isKindOfClass:[NSDictionary class]] || [instance isKindOfClass:[NSArray class]] || [instance isKindOfClass:[NSDate class]]) {            return _unboxOCObjectToJS(instance);        }    }//    4.根据类名与selectorName获得对应的类对象与selector    Class cls = instance ? [instance class] : NSClassFromString(className);    SEL selector = NSSelectorFromString(selectorName);    NSString *superClassName = nil;//    5.判断是否调用的是父类的方法，如果是，走父类的方法实现    if (isSuper) {//        5.1 定义新的SEL:SUPERSEL        NSString *superSelectorName = [NSString stringWithFormat:@&quot;SUPER_%@&quot;, selectorName];        SEL superSelector = NSSelectorFromString(superSelectorName);        Class superCls;        if (realClsName.length) {            Class defineClass = NSClassFromString(realClsName);            superCls = defineClass ? [defineClass superclass] : [cls superclass];        } else {            superCls = [cls superclass];        }        Method superMethod = class_getInstanceMethod(superCls, selector);        IMP superIMP = method_getImplementation(superMethod);//        5.2  将SUPERSEL指向superIMP的实现        class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod));//        5.3  查找父类中是否有添加JPSEL的实现        NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];        JSValue *overideFunction = _JSOverideMethods[superCls][JPSelectorName];        if (overideFunction) {//            如果有，进行imp替换            overrideMethod(cls, superSelectorName, overideFunction, NO, NULL);        }        selector = superSelector;        superClassName = NSStringFromClass(superCls);    }    NSMutableArray *_markArray;//    6.通过类对象与selector构造对应的NSMethodSignature签名    NSInvocation *invocation;    NSMethodSignature *methodSignature;    if (!_JSMethodSignatureCache) {        _JSMethodSignatureCache = [[NSMutableDictionary alloc]init];    }    if (instance) {        [_JSMethodSignatureLock lock];        if (!_JSMethodSignatureCache[cls]) {            _JSMethodSignatureCache[(id&lt;NSCopying&gt;)cls] = [[NSMutableDictionary alloc]init];        }        methodSignature = _JSMethodSignatureCache[cls][selectorName];        if (!methodSignature) {            methodSignature = [cls instanceMethodSignatureForSelector:selector];            methodSignature = fixSignature(methodSignature);            _JSMethodSignatureCache[cls][selectorName] = methodSignature;        }        [_JSMethodSignatureLock unlock];        if (!methodSignature) {            _exceptionBlock([NSString stringWithFormat:@&quot;unrecognized selector %@ for instance %@&quot;, selectorName, instance]);            return nil;        }//        7.根据签名构造NSInvocation对象        invocation = [NSInvocation invocationWithMethodSignature:methodSignature];//        8.为invocation对象设置target        [invocation setTarget:instance];    } else {        methodSignature = [cls methodSignatureForSelector:selector];        methodSignature = fixSignature(methodSignature);        if (!methodSignature) {            _exceptionBlock([NSString stringWithFormat:@&quot;unrecognized selector %@ for class %@&quot;, selectorName, className]);            return nil;        }        invocation= [NSInvocation invocationWithMethodSignature:methodSignature];        [invocation setTarget:cls];    }//        9.为invocation对象设置selector    [invocation setSelector:selector];//    10.根据签名得知每个参数的实际类型    NSUInteger numberOfArguments = methodSignature.numberOfArguments;    NSInteger inputArguments = [(NSArray *)argumentsObj count];    if (inputArguments &gt; numberOfArguments - 2) {//        10.1 多参数方法仅支持 id 类型参数和 id 类型返回,直接revoke并返回.        id sender = instance != nil ? instance : cls;        id result = invokeVariableParameterMethod(argumentsObj, methodSignature, sender, selector);        return formatOCToJS(result);    }//    10.2 将JS传递过来的参数进行对应的转换(如 NSNumber -&gt; int)，转换后为 NSInvocation 对象设置参数.    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];        id valObj = argumentsObj[i-2];        switch (argumentType[0] == &#39;r&#39; ? argumentType[1] : argumentType[0]) {            //...(具体转换规则看源代码)        }    }    if (superClassName) _currInvokeSuperClsName = superClassName;//    11.执行 invoke 方法,并且传递指定的参数    [invocation invoke];    if (superClassName) _currInvokeSuperClsName = nil;    if ([_markArray count] &gt; 0) {        for (JPBoxing *box in _markArray) {            void *pointer = [box unboxPointer];            id obj = *((__unsafe_unretained id *)pointer);            if (obj) {                @synchronized(_TMPMemoryPool) {                    [_TMPMemoryPool setObject:obj forKey:[NSNumber numberWithInteger:[(NSObject*)obj hash]]];                }            }        }    }    char returnType[255];    strcpy(returnType, [methodSignature methodReturnType]);    // Restore the return type    if (strcmp(returnType, @encode(JPDouble)) == 0) {        strcpy(returnType, @encode(double));    }    if (strcmp(returnType, @encode(JPFloat)) == 0) {        strcpy(returnType, @encode(float));    }    id returnValue;    if (strncmp(returnType, &quot;v&quot;, 1) != 0) {        if (strncmp(returnType, &quot;@&quot;, 1) == 0) {            void *result;//            12. 获取 invocation 运行返回值.            [invocation getReturnValue:&amp;result];//            13. 将返回值封装成JS对应的对象并返回.            //For performance, ignore the other methods prefix with alloc/new/copy/mutableCopy            if ([selectorName isEqualToString:@&quot;alloc&quot;] || [selectorName isEqualToString:@&quot;new&quot;] ||                [selectorName isEqualToString:@&quot;copy&quot;] || [selectorName isEqualToString:@&quot;mutableCopy&quot;]) {                returnValue = (__bridge_transfer id)result;            } else {                returnValue = (__bridge id)result;            }            return formatOCToJS(returnValue);        } else {            switch (returnType[0] == &#39;r&#39; ? returnType[1] : returnType[0]) {            //...（具体转换规则见源代码）            return returnValue;        }    }    return nil;}</code></pre><p>至此，JSPatch 热修复核心步骤<strong>方法替换</strong>和<strong>方法调用</strong>就结束了。</p><p>#总结<br>JSPatch 基于<code>JavaScriptCore.framework</code>和Objective-C中的runtime技术。</p><ul><li>采用 iOS7 后引入的 <code>JavaScriptCore.framework</code>作为 JavaScript 引擎解析js脚本，执行js代码并与OC端代码进行桥接。</li><li>使用Objective-C <code>runtime</code>中的<code>method swizzling</code>方式达到使用js脚本动态替换原有OC方法的目的，并利用<code>forwardInvocation</code>消息转发机制使得在js脚本中调用OC的方法成为可能。</li></ul><p>JSPatch 实现过程中还有许多细节问题诸如 Special Struct、内存管理、<code>JPBoxing</code>、<code>nil</code>处理等，更多详细内容可以阅读作者的原理详解系列文章以及<a href="https://github.com/bang590/JSPatch/wiki" target="_blank" rel="noopener">GitHub wiki</a>。学习 JSPatch 不仅可以弄清 iOS 热修复机制，也可以体会到如何利用 runtime 这一 OC 最重要的特性来实现一些强大的功能。这里不得不佩服作者深厚的编程功底和各种精彩的奇思妙想。<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwrgz3wjngj30h30ckmzt" alt=""></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> JSPatch </tag>
            
            <tag> 源码 </tag>
            
            <tag> 动态化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 热更新解读（一）APatch &amp; JavaScriptCore</title>
      <link href="/2018/06/14/jspatch-apatch&amp;javascriptcore/"/>
      <url>/2018/06/14/jspatch-apatch&amp;javascriptcore/</url>
      <content type="html"><![CDATA[<p>之前在手淘实习负责过百川<a href="http://baichuan.taobao.com/product/hotfix.htm?infoq=01" target="_blank" rel="noopener">Hotfix能力</a>的建设，Android 端采用阿里自研 <a href="https://mp.weixin.qq.com/s/5KjSPvUflbg0pVRIjtLiRA" target="_blank" rel="noopener">Sophix</a>，iOS 端采用 JSPatch，解读 JSPatch 前有必要先了解 Objective-C 与 JavaScript 的互相调用。<br><a id="more"></a></p><h1 id="iOS-动态更新的几种方案"><a href="#iOS-动态更新的几种方案" class="headerlink" title="iOS 动态更新的几种方案"></a>iOS 动态更新的几种方案</h1><ul><li>WebView 加载 HTML5 动态更新。</li><li>React Native/weex js 动态更新。</li><li>lua 脚本文件控制动态更新（代表框架 <a href="https://github.com/mmin18/WaxPatch" target="_blank" rel="noopener">WaxPatch</a> ）。</li><li>js 脚本文件控制动态更新（代表框架 <a href="https://github.com/bang590/JSPatch/" target="_blank" rel="noopener">JSPatch</a>）。</li><li><a href="http://blog.csdn.net/like7xiaoben/article/details/44081257" target="_blank" rel="noopener">framework 实现功能模块动态更新</a>。</li></ul><p>其中 WaxPatch 和 JSPatch 是使用较广泛的两种热修复方案。而苹果 review guideline 提到只允通过<code>JavaScriptCore.framework</code>或<code>WebKit</code>执行脚本，因此 JSPatch 是真正被 Apple 官方支持的。此外鉴于<code>JavaScript</code>比<code>lua</code>语言更亲民，使用系统内置的 <code>JavaScriptCore.framework</code>而无需内嵌lua脚本引擎来解释运行lua代码，JSPatch 便成为目前 iOS 热修复使用最多，效果也最佳的方案。</p><blockquote><p>有关上述几种热修复方案的比较可阅读这两篇文章：<br><a href="http://awhisper.github.io/2016/07/22/Weex-ReactNative-JSPatch/" target="_blank" rel="noopener">Weex &amp; ReactNative &amp; JSPatch</a><br><a href="https://blog.cnbang.net/works/2767/" target="_blank" rel="noopener">WaxPatch与JSPatch对比</a></p></blockquote><h1 id="APatch-与-JSPatch-的关系"><a href="#APatch-与-JSPatch-的关系" class="headerlink" title="APatch 与 JSPatch 的关系"></a>APatch 与 JSPatch 的关系</h1><p>JSPatch 使用时需要一个后台下发和管理脚本。阿里百川 HotFix 平台帮助开发者做了这些事。通过提供脚本托管、版本管理、脚本文件及传输过程加密等服务，让开发者无需搭建后台和关心部署操作，只需引入一个 SDK 即可直接使用 JSPatch 进行热修复。这个 SDK 就是 <a href="http://baichuan.taobao.com/docs/doc.htm?spm=a3c0d.7629140.0.0.qm0FoS&amp;treeId=234&amp;articleId=105670&amp;docType=1" target="_blank" rel="noopener">APatch（iOS）</a>。<br><img src="https://img.alicdn.com/tps/TB12.jYMVXXXXX0XFXXXXXXXXXX-611-521.png" alt=""><br>APatch 在 JSPatch 核心代码的基础上封装了向 HotFix 平台请求脚本／传输解密／脚本管理／本地调试等功能，是配合阿里百川 HotFix 平台一起使用的。</p><h1 id="APatch-工作流程"><a href="#APatch-工作流程" class="headerlink" title="APatch 工作流程"></a>APatch 工作流程</h1><p><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwa5u3lronj30ot0guwg8" alt=""><br>JSPatch 脚本执行权限很高，若被第三方篡改会<a href="http://www.ibtimes.co.uk/ios-over-1000-apps-that-use-jspatch-technology-put-users-risk-1540734" target="_blank" rel="noopener">带来很大安全问题</a>。因此 APatch 和 HotFix 平台都对安全问题考虑良多。</p><h2 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h2><p>从上图可看出，客户端从服务器下载 Patch 之前先要下载指定 Patch 配置信息即<code>PatchInfo</code>，其中包含了 Patch 文件密钥 <code>file_token</code>。<br>服务端：</p><ul><li>对 <code>file_token</code> 用 RSA 公钥加密。</li><li>对 <code>PatchInfo</code> 原始数据采用 HMacSha1 算法计算的哈希值，并将原始数据和哈希值<code>serviceToken</code>放在同一消息中传送给客户端。</li></ul><p>客户端：</p><ul><li>使用 <code>secret</code> 计算所接收数据的哈希值。</li><li>检查计算所得的 HMAC 是否与传送的 HMAC 匹配。</li><li>只有<code>PatchInfo</code>通过校验匹配后才会去下载<code>Patch</code>。</li></ul><p>另外，update patch 的接口已迁至 https，进一步保证了数据传输的安全。</p><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>本地存储的脚本被篡改的机会小很多，只在越狱机器上有点风险，对此 APatch SDK 对下载的脚本进行了AES对称加密，每次读取时：</p><ul><li>客户端使用 RSA 私钥解密 <code>PatchInfo.file_token</code> 获取 <code>key</code> 和 <code>iv</code>。</li><li>使用 <code>key</code> 和 <code>iv</code> 进行 AES 解密。</li></ul><p>解密成功后的数据存储在 <code>script</code> 中，然后会调用 JSPatch 运行js脚本的接口：</p><pre><code class="Objective-C">[JPEngine evaluateScript:script];</code></pre><p>至此，APatch 的工作已经完成，接下来具体的热修复工作就交给 JSPatch 了。</p><h1 id="JSPatch-——-基于-JavaScriptCore-framework"><a href="#JSPatch-——-基于-JavaScriptCore-framework" class="headerlink" title="JSPatch —— 基于 JavaScriptCore.framework"></a>JSPatch —— 基于 JavaScriptCore.framework</h1><blockquote><p>JSPatch 是一个开源项目(<a href="https://github.com/bang590/JSPatch/" target="_blank" rel="noopener">Github链接</a>)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。<br>–<em>摘自 JSPatch wiki</em></p></blockquote><p>“极小的引擎文件”指的就是 JavaScriptCore。OS X Mavericks 和 iOS 7 引入了 JavaScriptCore 库，它把 WebKit 的 JavaScript 引擎用 Objective-C 封装，提供了简单、快速、安全的方式接入世界上最流行的语言：</p><ul><li>在 Objective-C 代码中直接执行 JavaScript 代码段；</li><li>在 JavaScript 语言环境里调用 Objective-C 公开给 JavaScript的 方法；</li><li>内存管理和线程封装。</li></ul><p>如果未接触过 JavaScriptCore，在深入学习 JSPatch 之前有必要先了解一下这个js引擎怎么使用。</p><h2 id="OC-调用-JS"><a href="#OC-调用-JS" class="headerlink" title="OC 调用 JS"></a>OC 调用 JS</h2><p><code>JSContext</code> 是运行 JavaScript 代码的环境。可以在 <code>JSContext</code>中创建变量、计算、定义方法等：</p><pre><code class="Objective-C">JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;var num = 5 + 5&quot;];[context evaluateScript:@&quot;var names = [&#39;Grace&#39;, &#39;Ada&#39;, &#39;Margaret&#39;]&quot;];[context evaluateScript:@&quot;var triple = function(value) { return value * 3 }&quot;];</code></pre><p><code>JSValue</code>包装了每一个可能的 JavaScript 值，任何出自 <code>JSContext</code> 的值都被包裹在一个 <code>JSValue</code> 对象中：</p><pre><code class="Objective-C">JSValue *tripleNum = [context evaluateScript:@&quot;triple(num)&quot;];//取出jsvalue中的值NSLog(@&quot;Tripled: %d&quot;, [tripleNum toInt32]);//30</code></pre><p>对 <code>JSContext</code> 和 <code>JSValue</code> 实例使用下标可以访问之前创建的 context 的任何值。<code>JSContext</code> 需要一个字符串下标，<code>JSValue</code> 使用字符串或整数下标来得到里面的对象和数组：</p><pre><code class="Objective-C">JSValue *names = context[@&quot;names&quot;];JSValue *initialName = names[0];NSLog(@&quot;The first name: %@&quot;, [initialName toString]);//Grace</code></pre><p>调用JS方法需要使用<code>callWithArguments:</code>传递参数：</p><pre><code class="Objective-C">JSValue *tripleFunction = context[@&quot;triple&quot;];JSValue *result = [tripleFunction callWithArguments:@[@5]];NSLog(@&quot;five tripled:%d&quot;,[result toInt32]);</code></pre><p>这里使用 Foundation 类型<code>NSArray</code>作为参数来直接调用该函数。JavaScriptCore 可以 很轻松地处理这个桥接。<br>以上js代码都以字符串形式直接出现在oc代码中，实际中也可以在项目中引入.js文件，执行js文件中的内容。即：</p><pre><code class="Objective-C">NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];NSString *jsCore = [[NSString alloc] initWithData:[[NSFileManager defaultManager] contentsAtPath:path] encoding:NSUTF8StringEncoding];[context evaluateScript:jsCore];</code></pre><h2 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h2><p>从JS访问在OC中定义的对象和方法有两种方式：</p><h3 id="方式一：-JSContext注册NSBlock对象："><a href="#方式一：-JSContext注册NSBlock对象：" class="headerlink" title="方式一： JSContext注册NSBlock对象："></a>方式一： <code>JSContext</code>注册<code>NSBlock</code>对象：</h3><pre><code class="Objective-C">context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b) {            NSLog(@&quot;add result:%@&quot;, @(a + b));        };context.exceptionHandler = ^(JSContext *con, JSValue *exception) {            NSLog(@&quot;%@&quot;, exception);            con.exception = exception;            //异常处理...        };[context evaluateScript:@&quot;add(2,3)&quot;];//5</code></pre><h3 id="方式二：OC对象实现JSExport协议"><a href="#方式二：OC对象实现JSExport协议" class="headerlink" title="方式二：OC对象实现JSExport协议:"></a>方式二：OC对象实现<code>JSExport</code>协议:</h3><p>定义一个<code>Test</code>类，遵循 <code>JSExport</code>协议：</p><pre><code class="Objective-C">// in Test.h -----------------//定义一个JSExport子协议，暴露OC方法定义@protocol TestJSExports &lt;JSExport&gt;- (void)log:(id)value;- (void)addX:(int)x withY:(int)y;@end@interface Test : NSObject &lt;TestJSExports&gt;- (void)callOC;@end// in Test.m -----------------@implementation Test- (void)callOC {    JSContext *context = [[JSContext alloc] init];    //将实现了上面定义的协议的对象设置给JSContext    context[@&quot;Test&quot;] = self;    //执行在JSContext中的JS代码，即可以执行传入的对象的JSExport协议中定义的方法    [context evaluateScript:@&quot;Test.log(&#39;Hello JavaScript&#39;)&quot;];    [context evaluateScript:@&quot;Test.addXWithY(1, 2);&quot;];}- (void)log:(id)value {    NSLog(@&quot;value = %@&quot;, value);}- (void)addX:(int)x withY:(int)y {    NSLog(@&quot;x + y = %d&quot;, x + y);}@end</code></pre><p>测试：</p><pre><code class="Objective-C">Test *test = [[Test alloc]init];[test callOC];//&quot;value = Hello JavaScript&quot;,&quot;x + y = 3&quot;</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> JSPatch </tag>
            
            <tag> 源码 </tag>
            
            <tag> 动态化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iPhone &amp; Android 换机通信方案分析</title>
      <link href="/2018/06/13/ios-android-transfer/"/>
      <url>/2018/06/13/ios-android-transfer/</url>
      <content type="html"><![CDATA[<p>目前市面上的换机产品（QQ同步助手、闪电换机等）都是支持 Android to Android 的场景，如果在 iPhone 作为旧机，安卓做新机，可将 libmobiledevice 库（目前支持Mac、Windows、Linux平台）移植到安卓，拿到 iPhone 手机的本地应用信息、多媒体文件、通讯录等，从而进行换机操作。<br><a id="more"></a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f9itoognq5j30nq0bwju0.jpg" alt=""><br>如图，通过某种方式将 iOS 与 Android 设备相连，在 Android 设备上读取 iPhone 手机上的通讯录、图片、音乐、视频、app 等信息，进一步实现：</p><ol><li>在两台设备间实现数据迁移。</li><li>通过 Android 设备给 iPhone 分发下载应用。 </li></ol><p>可以简单理解为安卓手机上实现类似 iTunes 的功能。</p><h1 id="现在市场上有没有类似应用"><a href="#现在市场上有没有类似应用" class="headerlink" title="现在市场上有没有类似应用"></a>现在市场上有没有类似应用</h1><p>有的。</p><h2 id="借助-PC-端通信"><a href="#借助-PC-端通信" class="headerlink" title="借助 PC 端通信"></a>借助 PC 端通信</h2><p><a href="http://www.itools.cn/" target="_blank" rel="noopener">iTools</a> / <a href="http://www.25pp.com/" target="_blank" rel="noopener">PP助手</a> / <a href="http://www.kuaiyong.com/" target="_blank" rel="noopener">快用</a> 等都是 有着“无需越狱，即可同步”功能类似 itunes 的苹果设备同步管理软件。均提供 PC 端和手机端应用。从官网描述看，这些应用可以提供的服务主要有两个：</p><ol><li>数据管理、同步与备份（短信、联系人、照片、音乐等）。</li><li>和 iTunes 一样进行 iOS 应用程序的安装与卸载（<strong>这种功能是违反苹果规定的</strong>）。</li></ol><p><img src="https://4.bp.blogspot.com/-E2wAUHVmKqw/Whgk4bPYF6I/AAAAAAAB468/VSAVGPxKmVMovRNDjSRUMRTtzV8aGWSKQCLcBGAs/s1600/iTools_2017-11-24_214021.png" alt=""></p><h2 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h2><p>诸如 <a href="https://play.google.com/store/apps/details?id=com.sec.android.easyMover&amp;hl=en" target="_blank" rel="noopener">Samsung Smart Switch Mobile</a> 或 <a href="https://play.google.com/store/apps/details?id=com.sonymobile.xperiatransfermobile&amp;hl=en" target="_blank" rel="noopener">Xperia™ Transfer Mobile</a> 均提供两台设备间数据传输的功能，初衷是为了满足换机用户将旧手机里的所有资料、数据、应用导入新手机的需求。既支持 Android -&gt; Android，也支持 iOS -&gt; Android。具体用法<a href="http://www.samsung.com/hk_en/support/smartswitch/" target="_blank" rel="noopener">看这里</a>。</p><h1 id="获取-iDevice-数据可能的途径"><a href="#获取-iDevice-数据可能的途径" class="headerlink" title="获取 iDevice 数据可能的途径"></a>获取 iDevice 数据可能的途径</h1><h2 id="iTunes"><a href="#iTunes" class="headerlink" title="iTunes"></a>iTunes</h2><p><a href="http://www.apple.com/cn//itunes/download/" target="_blank" rel="noopener">iTunes</a> 既是一款媒体播放器，也是苹果官方提供的用于管理 iOS 设备的主要工具。通过 iTunes 可同步和备份 iPhone 上的音乐、视频、录音、电子书等。<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f9ivq6q6qcj30xk07q76t.jpg" alt=""><br>此外还可以<a href="http://stackoverflow.com/questions/26720764/install-ipa-with-itunes-12" target="_blank" rel="noopener">通过 iTunes 向 iOS 设备安装 ipa 文件</a>。</p><h2 id="iCloud"><a href="#iCloud" class="headerlink" title="iCloud"></a>iCloud</h2><p><a href="https://www.icloud.com/" target="_blank" rel="noopener">iCloud</a> 是苹果公司所提供的云存储和云计算服务。用户能在 iCloud 中存储音乐、照片、App、联系人和日历等，并将无线推送到用户所有支持 iCloud 同步的设备上，这也是它和 iTunes 提供的同步功能不同的一点 —— 不用使用连接线。<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9iw0q1pnij30xw0aotb6.jpg" alt=""></p><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>参考 iTunes 和 iCloud 工作方式，可以猜想实现 iPhone 与安卓设备数据同步的方式有两种（不借助 PC 端，Samsung Smart Switch Mobile 确实提供了这两种同步方式）：</p><ol><li><a href="https://www.youtube.com/watch?v=KbV5Qkl8xl0" target="_blank" rel="noopener">有线</a>。（通过 Micro USB 相连，iPhone 识别相连设备并信任后，打开安卓应用直接进行同步）。</li><li><a href="https://www.youtube.com/watch?v=Oz4chv6gRw8" target="_blank" rel="noopener">无线</a>。（在安卓应用输入 iCloud 账号和密码，登录后获取 iCloud 中的备份数据并同步）。</li></ol><p>而如果要在安卓设备进行 iOS 应用的管理（获取现有应用列表、安装、卸载），则只能是通过有线的方式实现。</p><h1 id="libimobiledevice"><a href="#libimobiledevice" class="headerlink" title="libimobiledevice"></a>libimobiledevice</h1><p>苹果官方提供了 iTunes 的 Mac 版和 windows 版，不支持Linux系统。一些 Linux 高手不能忍受因为要连接 iOS 设备就换用操作系统，因此就有人逆向出 <strong>iOS 设备与 Windows/Mac Host 接口的<a href="http://www.libimobiledevice.org/docs/mobilesync.html" target="_blank" rel="noopener">通讯协议</a></strong>，最终成就了横跨三大桌面平台的非官方版本 USB 接口 library —— <a href="http://www.libimobiledevice.org/" target="_blank" rel="noopener">libimobiledevice</a>。官方描述：</p><blockquote><p>libimobiledevice is a cross-platform software library that talks the protocols to support iPhone®, iPod Touch®, iPad® and Apple TV® devices. Unlike other projects, it does not depend on using any existing proprietary libraries and does not require jailbreaking. It allows other software to easily access the device’s filesystem, retrieve information about the device and it’s internals, backup/restore the device, manage SpringBoard® icons, manage installed applications, retrieve addressbook/calendars/notes and bookmarks and (using libgpod) synchronize music and video to the device. The library is in development since August 2007 with the goal to bring support for these devices to the Linux Desktop.</p></blockquote><p>简而言之就是它不依赖于第三方库，跨平台的实现了 iPhone，iPod Touch，iPad 等苹果设备的通讯协议。可以看作和 iTools 一样，都是可以替代iTunes，进行 iOS 设备管理的工具。因为<a href="https://github.com/libimobiledevice" target="_blank" rel="noopener">源码是开放的</a>，可以自行编译，众多开发者便利用这个库开发出了各种基于不同平台的 iOS 设备管理工具。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iPhone </tag>
            
            <tag> Android </tag>
            
            <tag> 换机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 10 通知更新详解</title>
      <link href="/2018/06/13/ios10-notification/"/>
      <url>/2018/06/13/ios10-notification/</url>
      <content type="html"><![CDATA[<p>关于「通知」iOS 10 新增了一个框架 <a href="https://developer.apple.com/reference/usernotifications?language=objc" target="_blank" rel="noopener">UserNotifications.framework</a>，即“用户通知框架”，推送 “Push” 只是「通知」触发的一种方式，而「通知」是操作系统层面的一种UI展示。<br><a id="more"></a><br>苹果官方文档中 Notification 分为两类：</p><ul><li>Remote (远程，即 Push 方式)</li><li>Local (本地，通知由本地事件触发，iOS 10 中有三种不同的触发 “Trigger” 方式，下文有详细说明)</li></ul><p>所以，「推送」只是「通知」的一种触发方式，从 iOS 迭代更新的历史特征中看，「通知」一直是被苹果作为重点内容来延展的。iOS 10 中新增了独立框架（之前一直存在于 UIKit Framework 中）还有丰富的特性更新。</p><h1 id="更新概览"><a href="#更新概览" class="headerlink" title="更新概览"></a>更新概览</h1><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><ol><li>Familiar API with feature parity</li><li>Expanded content</li><li>Same code path for local and remote notification handling</li><li>Simplified delegate methods</li><li>Better notification management</li><li>In-app presentation option</li><li>Schedule and handle notifications in extensions</li><li>Notification Extensions</li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li>相同的特性使用类似API（之前的功能API使用方法类似但是还是稍有改变）</li><li>内容扩展（支持附件和展示更多内容）</li><li>本地通知和远程通知操作代码在相同调用路径（合并代理方法）</li><li>简化代理方法</li><li>更好的通知管理（支持通知查、改、删；增强本地通知管理，增加日历与地理位置事件的触发）</li><li>应用内通知展示（之前App在前台的情况下收到通知不会UI展示）</li><li>在Extensions中规划和操作通知（使更新通知内容和删除误发或过期的通知内容成为可能，另一个重要场景为端到端加密）</li><li>引入通知Extensions</li></ol><h1 id="用-UserNotifications-Framework-实现通知"><a href="#用-UserNotifications-Framework-实现通知" class="headerlink" title="用 UserNotifications Framework 实现通知"></a>用 UserNotifications Framework 实现通知</h1><h2 id="在-Xcode-中启用推送通知"><a href="#在-Xcode-中启用推送通知" class="headerlink" title="在 Xcode 中启用推送通知"></a>在 Xcode 中启用推送通知</h2><p>要使用 UserNotifications Framework 需在 Xcode 项目中开启推送通知：<br>Project Target –&gt; Capabilities –&gt; Push Notifications<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f7sxvwcvu0j30go0cidgz.jpg" alt=""></p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><pre><code class="Objective-C">#import &lt;UserNotifications/UserNotifications.h&gt;</code></pre><h2 id="注册推送"><a href="#注册推送" class="headerlink" title="注册推送"></a>注册推送</h2><pre><code class="Objective-C">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // iOS 10 before    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];    [application registerUserNotificationSettings:settings];    // iOS 10    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];    [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) {        if (!error) {            NSLog(@&quot;request authorization succeeded!&quot;);        }    }];    return YES;}</code></pre><h2 id="Token-Registration"><a href="#Token-Registration" class="headerlink" title="Token Registration"></a>Token Registration</h2><p>跟之前一样：</p><pre><code class="Objective-C">[[UIApplication sharedApplication] registerForRemoteNotifications];</code></pre><h2 id="Notification-Settings"><a href="#Notification-Settings" class="headerlink" title="Notification Settings"></a>Notification Settings</h2><p>之前注册推送服务，首次安装 APP 后弹出授权推送通知框，用户点击了同意还是不同意，以及用户之后又做了怎样的更改我们是无从得知的，现在 apple 开放了这个 API，我们可以直接获取到用户的设定信息了。</p><pre><code class="Objective-C">[center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {        NSLog(@&quot;%@&quot;,settings);}];</code></pre><p>打印 settings 如下：</p><pre><code class="Objective-C">&lt;UNNotificationSettings: 0x16567310; authorizationStatus: Authorized, notificationCenterSetting: Enabled, soundSetting: Enabled, badgeSetting: Enabled, lockScreenSetting: Enabled, alertSetting: NotSupported,carPlaySetting: Enabled, alertStyle: Banner&gt;</code></pre><p><code>settings.authorizationStatus</code>有三个值：</p><pre><code class="Objective-C">typedef NS_ENUM(NSInteger, UNAuthorizationStatus) {    // 用户还没决定是否允许开启推送通知.    UNAuthorizationStatusNotDetermined = 0,    // 不允许开启通知.    UNAuthorizationStatusDenied,    // 允许开启.    UNAuthorizationStatusAuthorized} __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);</code></pre><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>以前只能展示一条文字，现在可以有 title 、subtitle 以及 body.<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f7syzclsj2j30og0dcmz8.jpg" alt=""><br>定制方法：</p><pre><code class="Objective-C">//Local NotificationUNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];content.title = @&quot;Introduction to Notifications&quot;;content.subtitle = @&quot;Session 707&quot;;content.body = @&quot;Woah! These new notifications look amazing! Don’t you agree?&quot;;content.badge = @1;//Remote Notification{&quot;aps&quot; : {    &quot;alert&quot; : {          &quot;title&quot; : &quot;Introduction to Notifications&quot;,          &quot;subtitle&quot; : &quot;Session 707&quot;,                  &quot;body&quot; : &quot;Woah! These new notifications look amazing! Don’t you agree?&quot;                },    &quot;badge&quot; : 1        },}</code></pre><h2 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h2><p>本地通知新增了两种新的 Triggers —— 日历和地理位置。日历 Triggers 让开发者可以根据指定的日期和时间来展示本地通知，并且支持循环条件，如“每周二上午十一点”这种条件。地理位置 Triggers 可以在进入或者离开指定区域时触发本地通知，如“某品牌App在你进入该品牌线下店铺的范围内即展示最新优惠信息”等。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f7t4uo402xj30og0dc75e.jpg" alt=""><br>Triggers 有三种值：</p><ul><li>UNTimeIntervalNotificationTrigger</li><li>UNCalendarNotificationTrigger</li><li>UNLocationNotificationTrigger</li></ul><pre><code class="Objective-C">//2 分钟后提醒UNTimeIntervalNotificationTrigger *trigger1 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:120 repeats:NO];//每小时重复 1 次（循环）UNTimeIntervalNotificationTrigger *trigger2 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:3600 repeats:YES];//每周一早上 8：00 提醒我NSDateComponents *components = [[NSDateComponents alloc] init];components.weekday = 2;components.hour = 8;UNCalendarNotificationTrigger *trigger3 = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES];//#import &lt;CoreLocation/CoreLocation.h&gt;//一到麦当劳就喊我下车CLRegion *region = [[CLRegion alloc] init];UNLocationNotificationTrigger *trigger4 = [UNLocationNotificationTrigger triggerWithRegion:region repeats:NO];</code></pre><h2 id="Add-Request"><a href="#Add-Request" class="headerlink" title="Add Request"></a>Add Request</h2><pre><code class="Objective-C">NSString *requestIdentifier = @&quot;sampleRequest&quot;;UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifier                                                                          content:content                                                                          trigger:trigger1];[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {}];</code></pre><h2 id="通知实现小结"><a href="#通知实现小结" class="headerlink" title="通知实现小结"></a>通知实现小结</h2><ul><li>Local Notifications:<ol><li>定义 <code>Content</code>. </li><li>定义 <code>Trigger</code>.</li><li>向 <code>UNUserNotificationCenter</code> 发送 <code>request</code>.</li></ol></li></ul><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t52xcybqj30op0d6766.jpg" alt=""></p><ul><li>Remote Notifications: 向 APNs 发送 <code>Notification Payload</code>.</li></ul><h1 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h1><h2 id="UNUserNotificationCenterDelegate"><a href="#UNUserNotificationCenterDelegate" class="headerlink" title="UNUserNotificationCenterDelegate"></a>UNUserNotificationCenterDelegate</h2><p><code>UNUserNotificationCenterDelegate</code>提供了两个方法：</p><ul><li>在应用内展示通知。App 处于前台时捕捉并处理即将触发的推送：</li></ul><pre><code class="Objective-C">@interface AppDelegate () &lt;UNUserNotificationCenterDelegate&gt;-(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler{    completionHandler(UNNotificationPresentationOptionAlert | UNNotificationPresentationOptionSound);}</code></pre><ul><li>收到通知响应时的处理工作。用户与你推送的通知进行交互时被调用：</li></ul><pre><code class="Objective-C">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler{      completionHandler()//什么也不做}</code></pre><h2 id="Notification-Management"><a href="#Notification-Management" class="headerlink" title="Notification Management"></a>Notification Management</h2><p>可以对通知执行查、改、删操作。实现该功能需要有一个必要参数<code>identifer</code>，后续的查改删操作都是根据此参数去执行的。</p><ul><li>Local Notification：通过更新 request.</li><li>Remote Notification 通过新的字段 <code>apns-collapse-id</code>.</li></ul><p>更新原有推送：</p><pre><code class="Objective-C">NSString *requestIdentifier = @&quot;sampleRequest&quot;;UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifier                                                                      content:newContent                                                                      trigger:newTrigger1];[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {}];</code></pre><p>删除推送：</p><pre><code class="Objective-C">[center removePendingNotificationRequestsWithIdentifiers:@[requestIdentifier]];</code></pre><p>典型应用场景：</p><ul><li>赛事比分更新</li><li>撤回通知<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t9swwyxqj30og0dcta2.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t9t2wnu3j30og0dcgmw.jpg" alt=""></li></ul><h1 id="Notification-Extension"><a href="#Notification-Extension" class="headerlink" title="Notification Extension"></a>Notification Extension</h1><p><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f7xzisvg36j30l80fc0vp.jpg" alt=""></p><h2 id="Service-Extension"><a href="#Service-Extension" class="headerlink" title="Service Extension"></a>Service Extension</h2><p>Service Extension允许在收到远程推送的通知后，展示之前对通知内容进行修改。</p><pre><code class="Swift">class NotificationService: UNNotificationServiceExtension {    var contentHandler: ((UNNotificationContent) -&gt; Void)?    var bestAttemptContent: UNMutableNotificationContent?    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {        self.contentHandler = contentHandler        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)        if let bestAttemptContent = bestAttemptContent {            if request.identifier == &quot;mutableContent&quot; {                bestAttemptContent.body = &quot;\(bestAttemptContent.body),tuneszhao&quot;            }            contentHandler(bestAttemptContent)        }    }    override func serviceExtensionTimeWillExpire() {        // Called just before the extension will be terminated by the system.        // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used.        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {            contentHandler(bestAttemptContent)        }    }}</code></pre><ul><li><code>didReceive:</code>方法中通过修改请求的<code>content</code>内容，然后在限制的时间内将修改后的内容调用通过 <code>contentHandler</code> 返还给系统，就可以显示这个修改过的通知了。<br>(本例中在原有 content 之后添加了字符串 “tuneszhao”)。</li><li><code>serviceExtensionTimeWillExpire:</code>：在一定时间内没有调用 <code>contentHandler</code> 的话，系统会调用这个方法。可以选择什么都不做，系统将当作什么都没发生，简单地显示原来的通知。可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用 contentHandler 来显示一个变更“中途”的通知。</li></ul><p><code>Service Extension</code>只对远程推送的通知有效，启用内容修改要在推送<code>payload</code>中设置<code>mutable-content</code>值为1：</p><pre><code class="Java">{  &quot;aps&quot;:{    &quot;alert&quot;:{      &quot;title&quot;:&quot;Greetings&quot;,      &quot;body&quot;:&quot;Long time no see&quot;    },    &quot;mutable-content&quot;:1  }}</code></pre><p>该特性可用于推送内容加密。服务器推送 <code>payload</code> 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密，然后显示。这样可以保证传递内容的安全。</p><h2 id="Media-Attachments"><a href="#Media-Attachments" class="headerlink" title="Media Attachments"></a>Media Attachments</h2><p>iOS 10 的另一个亮眼功能是多媒体的推送，开发者可以在通知中嵌入图片或视频。</p><h3 id="为本地通知添加图片／视频"><a href="#为本地通知添加图片／视频" class="headerlink" title="为本地通知添加图片／视频"></a>为本地通知添加图片／视频</h3><p>通过本地磁盘上的文件 URL 创建一个 <code>UNNotificationAttachment</code> 对象，然后将这个对象放到数组中赋值给 <code>content</code> 的 <code>attachments</code> 属性：</p><pre><code class="Swift">let content = UNMutableNotificationContent()  content.title = &quot;Hey guys&quot;content.body = &quot;What&#39;s going on here?&quot;if let imageURL = Bundle.main.url(forResource: &quot;image&quot;, withExtension: &quot;jpg&quot;),   let attachment = try? UNNotificationAttachment(identifier: &quot;imageAttachment&quot;, url: imageURL, options: nil){    content.attachments = [attachment]}</code></pre><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f7xlo99zmsj30og0dc402.jpg" alt=""></p><h3 id="为远程推送添加多媒体内容"><a href="#为远程推送添加多媒体内容" class="headerlink" title="为远程推送添加多媒体内容"></a>为远程推送添加多媒体内容</h3><p>需要借助上面提到的<code>Notification Service Extension</code>。</p><ul><li><code>payload</code> 中指定需要加载的图片资源地址，这个地址可以是应用 bundle 内已经存在的资源，也可以是网络的资源。</li><li>如果多媒体不在本地的话，需要先将其下载到本地。</li><li>创建 <code>UNNotificationAttachment</code>,之后和本地通知一样，将多媒体资源设置给 <code>attachments</code> 属性，然后调用<code>contentHandler</code>。</li></ul><pre><code class="Java">{  &quot;aps&quot;:{    &quot;alert&quot;:{      &quot;title&quot;:&quot;Image Notification&quot;,      &quot;body&quot;:&quot;Show me an image from web!&quot;    },    &quot;mutable-content&quot;:1  },  &quot;image&quot;: &quot;http://ww2.sinaimg.cn/large/005tGCqhgw1f7xlo99zmsj30og0dc402.jpg&quot;}</code></pre><p>下载图片代码：</p><pre><code class="Swift">private func downloadAndSave(url: URL, handler: @escaping (_ localURL: URL?) -&gt; Void) {    let task = URLSession.shared.dataTask(with: url, completionHandler: {        data, res, error in        var localURL: URL? = nil        if let data = data {            let ext = (url.absoluteString as NSString).pathExtension            let cacheURL = URL(fileURLWithPath: FileManager.default.cachesDirectory)            let url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)            if let _ = try? data.write(to: url) {                localURL = url            }        }        handler(localURL)    })    task.resume()}</code></pre><p><code>didReceive:</code>中接收通知获取图片地址后下载，并创建<code>attachment</code>展示：</p><pre><code class="Swift">if let imageURLString = bestAttemptContent.userInfo[&quot;image&quot;] as? String,   let URL = URL(string: imageURLString){    downloadAndSave(url: URL) { localURL in        if let localURL = localURL {            do {                let attachment = try UNNotificationAttachment(identifier: &quot;image_downloaded&quot;, url: localURL, options: nil)                bestAttemptContent.attachments = [attachment]            } catch {                print(error)            }        }        contentHandler(bestAttemptContent)    }}</code></pre><h1 id="关于适配"><a href="#关于适配" class="headerlink" title="关于适配"></a>关于适配</h1><p>关于通知原来的 API 已被标为弃用。但如果需要支持 iOS 10 之前的系统，还是需要使用原来的 API。若要针对 iOS 10 进行新通知的适配，为应用通知带来更多新特性，可以使用：</p><pre><code class="Swift">if #available(iOS 10.0, *) {    // 使用 UserNotification}</code></pre><h1 id="官方链接及实例代码"><a href="#官方链接及实例代码" class="headerlink" title="官方链接及实例代码"></a>官方链接及实例代码</h1><blockquote><p><a href="https://developer.apple.com/videos/play/wwdc2016/707/" target="_blank" rel="noopener">Introduction to Notifications</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/708/" target="_blank" rel="noopener">Advanced Notifications</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/724/" target="_blank" rel="noopener">What’s New in the Apple Push Notification Service</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 通知 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 10 之 Messages framework</title>
      <link href="/2018/06/13/ios10-messages-framework/"/>
      <url>/2018/06/13/ios10-messages-framework/</url>
      <content type="html"><![CDATA[<p>iMessage App 是一种全新的应用扩展，载体是 iOS 系统的 Message 应用，通过 iMessage App，用户可以发送更加丰富的消息内容，享受更具交互性的会话体验。<br>从 iOS 10 开始，消息扩展（Messages Extension）可以独立于宿主App(Container App) 开发，并提供了全新的消息模式。用户可以通过 Message 发送文本、表情包（sticker）、多媒体文件，以及其他可交互消息。<br><a id="more"></a></p><h1 id="Messages-App-Store"><a href="#Messages-App-Store" class="headerlink" title="Messages App Store"></a>Messages App Store</h1><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80b81p95wj309y024jrb.jpg" alt=""><br>Messages App Store 独立于之前的 App Store，只存在于系统的 Message 中，这里只显示 <strong>iMessage-related 应用</strong>。它可以干什么呢？</p><ul><li>显示iMessage App;</li><li>为未安装应用的用户提供安装途径(Inline App Attribution);</li><li>提供iap，Apple Pay和访问相机功能。<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80bdctvjej30ku112wkv.jpg" alt=""></li></ul><p>iMessage App 可以独立开发（iOS 10之后），也可以作为 Extension 添加在现有项目中。</p><ul><li>在现有项目中添加：File-&gt;New-&gt;Target-&gt;Application Extension-&gt;Sticker Pack Extension/iMessage Extension</li><li>独立开发：File-&gt;New-&gt;Project-&gt;Application-&gt;Sticker Pack Application/iMessage Application</li></ul><h1 id="基本表情包-Sticker-Packs"><a href="#基本表情包-Sticker-Packs" class="headerlink" title="基本表情包 (Sticker Packs)"></a>基本表情包 (Sticker Packs)</h1><p>Sticker 是 iOS 10 iMessage 引入的一种新的交互方式，可以当做消息发送，也可以附加在已有消息上。创建表情包不需要任何代码。图片文件需满足以下条件：</p><ul><li>图片格式：PNG, APNG, GIF, JPEG;</li><li>文件大小：小于 500 KB;</li><li>图片大小区间：[100 x 100,206 x 206]</li></ul><p>只需提供最大像素图片(@3x,[300 x 300,618 x 618])，系统会在需要的时候自动完成缩放。</p><p>苹果建议的表情文件大小：</p><ul><li>Small: 100 x 100 pt @3x scale (300 x 300 pixel image)</li><li>Medium: 136 x 136 pt @3x scale (378 x 378 pixel image)</li><li>Large: 206 x 206 pt @3x scale (618 x 618 pixel image)</li></ul><p>打开 Xcode，创建新工程 BasicStickerPack：<em>File-&gt;New-&gt;Project-&gt;Application-&gt;Sticker Pack Application</em>。<br>左边侧栏有个<code>Stickers.xcstickers</code>，包含了iMessage APP的icon 和表情，添加一组图片。如果要更改表情包默认名称和大小，可在右侧Attributes inspector 中更改。<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f80c1a8yuuj31kw085mzu.jpg" alt=""><br>运行，表情包将在 Message 的 Message App Store 打开，点击任何一个表情即可添加到当前信息并发送：<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80cwi8ozbj30ku112422.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80cdyjxegj30ku112dhr.jpg" alt=""></p><h1 id="自定义表情包"><a href="#自定义表情包" class="headerlink" title="自定义表情包"></a>自定义表情包</h1><p>基本的表情应用程序提供的模板可能不完全满足需求，我们创建一个较复杂的表情包应用程序 CustomStickerPack，选择 iMessage Application 模版。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80d9jz8moj30ek0ik40n.jpg" alt=""><br>创建好的工程相比上面的 Sticker Pack Application 多了 MessagesExtension 文件夹。该文件夹包含四个部分：</p><ul><li>MessagesViewController.swift : iMessage app的程序入口;</li><li>MainInterface.storyboard: 可视化操作;</li><li>Assets.xcassets: 图片集合;</li><li>Info.plist : 配置一些扩展信息;</li></ul><p><code>MessagesViewController</code>是 <code>MSMessagesAppViewController</code> 的子类，它是用来展示消息扩展(Message Extension)的界面。自定义 Sticker 需要自定义<code>MSStickerBrowserViewController</code>。<code>MSStickerBrowserViewController</code>是用来显示 Sticker 的，它有两个协议方法需要实现：</p><pre><code class="Objective-C">@protocol MSStickerBrowserViewDataSource &lt;NSObject&gt;- (NSInteger)numberOfStickersInStickerBrowserView:(MSStickerBrowserView *)stickerBrowserView;//返回Sticker数量- (MSSticker *)stickerBrowserView:(MSStickerBrowserView *)stickerBrowserView stickerAtIndex:(NSInteger)index;//返回MSSticker对象</code></pre><p><code>MSStickerBrowserViewController</code>用法跟<code>UITableViewDataSource</code>很像，有一个<code>stickerBrowserView</code>对象：</p><pre><code class="Objective-C">@property (nonatomic, strong, readonly) MSStickerBrowserView *stickerBrowserView;</code></pre><p>刷新数据，调用：</p><pre><code class="Objective-C">[stickerBrowserView reloadData];</code></pre><p>一张图说明一下上述几个对象的关系：<br><img src="http://upload-images.jianshu.io/upload_images/1415843-cc9571b08a155105.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""><br>将 sticker 放入 MessagesExtension 文件夹，创建一个 <code>MSSticker</code> 数组存储表情包，并写一个加载表情包的方法：</p><pre><code class="swift">var stickers = [MSSticker]()func loadStickers() {    for i in 1...2 {        if let url = Bundle.main.url(forResource: &quot;Sticker \(i)&quot;, withExtension: &quot;png&quot;){            do {                let sticker = try MSSticker(contentsOfFileURL: url, localizedDescription: &quot;&quot;)                stickers.append(sticker)            } catch {                print(error)            }        }    }}</code></pre><p>实现<code>createStickerBrowser</code>方法, 初始化<code>MSStickerBrowserViewController</code>作为根视图, 并设置宽高约束:</p><pre><code class="swift">func createStickerBrowser() {    let controller = MSStickerBrowserViewController(stickerSize: .large)    addChildViewController(controller)    view.addSubview(controller.view)    controller.stickerBrowserView.backgroundColor = UIColor.blue    controller.stickerBrowserView.dataSource = self    view.topAnchor.constraint(equalTo: controller.view.topAnchor).isActive = true    view.bottomAnchor.constraint(equalTo: controller.view.bottomAnchor).isActive = true    view.leftAnchor.constraint(equalTo: controller.view.leftAnchor).isActive = true    view.rightAnchor.constraint(equalTo: controller.view.rightAnchor).isActive = true}</code></pre><p>实现<code>MSStickerBrowserViewDataSource</code>的代理方法：</p><pre><code class="swift">func numberOfStickers(in stickerBrowserView: MSStickerBrowserView) -&gt; Int {    return stickers.count}func stickerBrowserView(_ stickerBrowserView: MSStickerBrowserView, stickerAt index: Int) -&gt; MSSticker {    return stickers[index]}</code></pre><p><code>viewDidLoad</code> 中加载 sticker 、创建 MSStickerBrowserViewController：</p><pre><code class="swift">override func viewDidLoad() {    super.viewDidLoad()    loadStickers()    createStickerBrowser()}</code></pre><p>运行，跟上一个表情包差不多，但背景换成了自定义的颜色。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80dm1uafej30ku112q69.jpg" alt=""></p><h1 id="自定义-APP"><a href="#自定义-APP" class="headerlink" title="自定义 APP"></a>自定义 APP</h1><p>本例将利用 iMessage App 创建一个独特的可交互消息。<br>创建 iMessage Application <code>MessageApp</code>，在<code>MainInterface.storyboard</code>添加一个 stepper 和 button：<br><img src="http://upload-images.jianshu.io/upload_images/326255-0dce497fdcdbe7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>选择 stepper 打开 Attributes inspector, 改变最小最大值为0和10:<br><img src="http://upload-images.jianshu.io/upload_images/326255-bf8a7f349311fcb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>介绍几个关键对象：</p><h2 id="MSConversation"><a href="#MSConversation" class="headerlink" title="MSConversation"></a>MSConversation</h2><p>指当前打开的会话，可以通过 MSConversation 插入消息。<br>在<code>MSMessagesAppViewController</code>中可以通过成员变量<code>activeConversatio</code>n获取当前的<code>MSConversation</code>，随后可调用以下方法插入不同的消息：</p><pre><code class="swift">// 添加交互型消息.open func insert(_ message: MSMessage, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加 sticker.open func insert(_ sticker: MSSticker, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加文本.open func insertText(_ text: String, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加多媒体（音视频）.open func insertAttachment(_ URL: URL, withAlternateFilename filename: String?, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1415843-bb2627708998cfe4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><h2 id="MSMessage"><a href="#MSMessage" class="headerlink" title="MSMessage"></a>MSMessage</h2><p>代表单个消息体，包含两个部分：</p><ul><li><code>MSSession</code>：用来描述消息如何发送;</li><li><code>MSMessageLayout</code>：用来描述消息如何展示。<br>在 iMessage 中自定义 MSMessage 必须要设置两个属性：<code>layout</code> 和 <code>url</code>。 url 是链接某个 web 页面的一些内容, 这样 MacOS 用户可以看到 iMessage 的内容。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1415843-8f7716fc63e26aea.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><p><code>MSMessageLayout</code>是一个抽象类，目前系统只提供了一种展现方法<code>MSMessageTemplateLayout</code>，里边有许多属性和空间用来自定义message;：<br><img src="https://docs-assets.developer.apple.com/published/af521ba258/MSMessageTemplateLayout_2x_93d9e9b7-b99c-4def-a8e1-2df50a710a52.png" alt=""><br> 左上角的空间是展示icon， 所有的属性都是可选的，提供任何标题字符串将摆脱底部部分的布局。<br>添加<code>createImageForMessage()</code>方法，将当前的stepper的数值显示到圆形的label中, 然后将label放在UIImage对象中。</p><pre><code class="swift">func createImageForMessage() -&gt; UIImage? {    let background = UIView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))    background.backgroundColor = UIColor.white    let label = UILabel(frame: CGRect(x: 75, y: 75, width: 150, height: 150))    label.font = UIFont.systemFont(ofSize: 56.0)    label.backgroundColor = UIColor.red    label.textColor = UIColor.white    label.text = &quot;\(Int(stepper.value))&quot;    label.textAlignment = .center    label.layer.cornerRadius = label.frame.size.width/2.0    label.clipsToBounds = true    background.addSubview(label)    background.frame.origin = CGPoint(x: view.frame.size.width, y: view.frame.size.height)    view.addSubview(background)    UIGraphicsBeginImageContextWithOptions(background.frame.size, false, UIScreen.main.scale)    background.drawHierarchy(in: background.bounds, afterScreenUpdates: true)    let image = UIGraphicsGetImageFromCurrentImageContext()    UIGraphicsEndImageContext()    background.removeFromSuperview()    return image}</code></pre><p>设置 button 点击方法<code>didPress</code>，该方法中先创建message的布局, 并且设置 image 和 caption, 接着创建 MSMessage 对象并插入到会话中：</p><pre><code class="swift">@IBAction func didPress(button sender: AnyObject) {    if let image = createImageForMessage(), let conversation = activeConversation {        let layout = MSMessageTemplateLayout()        layout.image = image        layout.caption = &quot;Stepper Value&quot;        let message = MSMessage()        message.layout = layout        message.url = URL(string: &quot;emptyURL&quot;)        conversation.insert(message, completionHandler: { (error) in            print(error)        })    }}</code></pre><p>在这个例子中, 我们只是创建了简单的字符 url，如果用户点击该消息并且 url 是 http(s) 类型的，系统会通过浏览器打开相应的页面。<br>运行 App：<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f80fc9xq3ej30ku112td8.jpg" alt=""><br>点击 button 发送消息：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80fcp6fl0j30ku112q57.jpg" alt=""><br>stepper+2：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80fd9slruj30ku112mzf.jpg" alt=""></p><h1 id="iMessage-App-LifeCycle"><a href="#iMessage-App-LifeCycle" class="headerlink" title="iMessage App LifeCycle"></a>iMessage App LifeCycle</h1><p>看下 iMessage App 的生命周期。</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><pre><code class="objc">// Message Extension启动。- (void)didBecomeActiveWithConversation:(MSConversation *)conversation;- (void)viewWillAppear:(BOOL)animated;- (void)viewDidAppear:(BOOL)animated;</code></pre><h2 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h2><pre><code class="objc">- (void)viewWillDisappear:(BOOL)animated;- (void)viewDidDisappear:(BOOL)animated;- (void)willResignActiveWithConversation:(MSConversation *)conversation;// Message Extension被系统销毁。</code></pre><h2 id="唤起过程"><a href="#唤起过程" class="headerlink" title="唤起过程"></a>唤起过程</h2><pre><code class="objc">-(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;-(void)didTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;</code></pre><p>上面列出的回调方法均出现在<code>MSMessagesAppViewController</code>中，因此，iMessage App 的生命周期就是<code>MSMessagesAppViewController</code>的生命周期。</p><blockquote><p><a href="https://developer.apple.com/reference/messages" target="_blank" rel="noopener">官方文档 Messages Framework Reference</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/204/" target="_blank" rel="noopener">WWDC Session1</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/224/" target="_blank" rel="noopener">WWDC Session2</a><br><a href="https://developer.apple.com/library/prerelease/content/samplecode/IceCreamBuilder/Introduction/Intro.html" target="_blank" rel="noopener">官方 demo</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Messages </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 程序证书及签名机制</title>
      <link href="/2018/06/13/iosapp-certificate-signature/"/>
      <url>/2018/06/13/iosapp-certificate-signature/</url>
      <content type="html"><![CDATA[<p>最近在研究除了 Apple 官方途径，iPhone手机上安装应用的其他途径。顺便总结下 iOS 开发中涉及的一套证书及签名机制。<br><a id="more"></a></p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是非对称加密和摘要算法的结合。防止中途篡改文本内容，保证文本的完整性，以及文本是由指定的权限者发的。<br>发布方加密过程:<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9n5536maxj307k0gwjru.jpg" alt=""><br>接收方验证过程：<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9n560603pj30hw0ja407.jpg" alt=""></p><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>数字证书就是通过数字签名实现的数字化的证书。简单讲数字证书包含以下信息:</p><ul><li>签发机构：CA（苹果公司）</li><li>被签发人：企业 / 开发者</li><li>验证方：iOS 设备</li><li>验证过程：固化在 iOS 系统中</li><li>证书链：根是苹果的CA</li></ul><h1 id="iOS-开发：证书申请、签名打包"><a href="#iOS-开发：证书申请、签名打包" class="headerlink" title="iOS 开发：证书申请、签名打包"></a>iOS 开发：证书申请、签名打包</h1><p><img src="http://pchou.qiniudn.com/iOS%E8%AF%81%E4%B9%A6%E5%92%8C%E6%A0%A1%E9%AA%8C.png" alt=""><br>这张图阐述了，开发iOS应用程序时，从申请证书，到打包的大致过程。简单总结如下：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9nxlzvnsvj31kw0g678v.jpg" alt=""><br><strong>数字证书的作用：</strong><br>证明app的所属以及app的完整性，保证app本身是安全的。</p><h1 id="iOS授权和描述文件"><a href="#iOS授权和描述文件" class="headerlink" title="iOS授权和描述文件"></a>iOS授权和描述文件</h1><p><code>mobileprovision</code>是为了证明 app 所使用的某些服务是被苹果认可的，如 Push 证书。<br><code>mobileprovision</code>包含：</p><ul><li>AppId。</li><li>使用哪些证书。</li><li>功能授权列表。</li><li>可安装的设备列表（UDID）。</li><li>苹果签名。</li></ul><h1 id="ipa文件"><a href="#ipa文件" class="headerlink" title=".ipa文件"></a>.ipa文件</h1><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9nzfmyp6uj30n204imxu.jpg" alt=""><br><code>.iTunesMetadata.plist</code>文件用来记录app的基本信息，例如购买者的appleID，app购买时间、app支持的设备体系结构，app的版本、app标识符等。<br>解压/payload中的.app文件可看到.ipa主要的文件结构：<br><img src="http://pchou.qiniudn.com/ipa%E7%BB%84%E6%88%90.png" alt=""></p><ul><li>_CodeSignature/CodeResources：程序包中（除 Frameworks）所有文件的签名。</li><li>embedded.mobileprovision：打包时使用。</li><li>SC_Info(图中未列出)：包含两个文件<ol><li>appname.sinf 为 metadata 文件</li><li>appname.supp 为解密可执行文件的密钥</li></ol></li></ul><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9nzic64qtj30w80i6tb7.jpg" alt=""><br>Xcode 打包生成 ipa 文件过程中利用当前证书私钥进行代码、资源文件的数字签名，将其存放在_CodeSignature文件夹下。</p><h1 id="关于-iTunes-授权"><a href="#关于-iTunes-授权" class="headerlink" title="关于 iTunes 授权"></a>关于 iTunes 授权</h1><p>每个 Apple ID 最多授权5台电脑（用来登录iTunes下载app和管理同步手机）。5的限制是通过扫描硬盘序列号来确认。<br>iTunes 授权时，需要连接 Apple 服务器进行验证，通过验证后，会将授权信息以加密文件的形式，存放在<a href="https://discussions.apple.com/thread/1715932?tstart=0" target="_blank" rel="noopener">SC_Info</a>文件夹。这些文件是隐藏的，可通过<a href="http://www.bresink.com/osx/TinkerTool.html" target="_blank" rel="noopener">TinkerTool</a>查看。<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9o6jx1dq8j30j402oab9.jpg" alt=""><br>iTunes 授权后，即可登录 Apple ID 并将该账号下购买过的应用同步到 iPhone 中。XX 助手工具便通过“欺骗授权”的方式，为每个用户修改或虚拟出一个相同的硬盘序列号，接着，“这台电脑”取得一个公共 id 的授权，然后把公共id买过的 app 装到某 iOS 设备中。达到一个账号给多台设备（5台以上）共享使用的目的。</p><h1 id="账号共享分发"><a href="#账号共享分发" class="headerlink" title="账号共享分发"></a>账号共享分发</h1><p><a href="http://www.pc6.com/edu/53793.html" target="_blank" rel="noopener">这篇文章</a>讲到在 windows 平台下使用账号共享分发app的方法。简单总结如下：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f9o8njxtpoj312a0acdhu.jpg" alt=""><br>同步授权后可以使用iTunes，也可以使用itools安装分享者另外发布出来的所有应用。</p><h1 id="ipa-文件安装后的校验过程"><a href="#ipa-文件安装后的校验过程" class="headerlink" title="ipa 文件安装后的校验过程"></a>ipa 文件安装后的校验过程</h1><p>App安装到ios系统上时，系统首先通过描述文件找到数字证书，通过证书里的苹果数字签名，验证证书的有效性。如果证书有效，取出证书中的开发者公钥，解密App的数字签名。如果发现摘要一致，则验证通过，App成功安装在手机上，其中一个环节有问题，验证工作就失败。</p><blockquote><p><a href="http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html" target="_blank" rel="noopener">漫谈iOS程序的证书和签名机制</a><br><a href="http://e-intuit.hk/kuaiyong-piracy.html" target="_blank" rel="noopener">iTools第三方市场分发原理</a><br><a href="https://objccn.io/issue-17-2/" target="_blank" rel="noopener">代码签名探析</a><br><a href="https://xiuchundao.me/post/code-resources-and-embedded-mobileprovision-included-in-ipa-file" target="_blank" rel="noopener">签过名的ipa文件</a><br><a href="http://www.pc6.com/edu/53793.html" target="_blank" rel="noopener">多个授权文件共存的正确方法</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器人操作系统（ROS/Android）对比</title>
      <link href="/2018/06/13/robot-operating-system-intro/"/>
      <url>/2018/06/13/robot-operating-system-intro/</url>
      <content type="html"><![CDATA[<p>目前很多互联网公司都在开发自己的硬件产品（小米的小爱同学，腾讯听听音箱、叮当等），包括深圳这边一家非常有名的人形机器人公司<a href="https://www.ubtrobot.com/cn/" target="_blank" rel="noopener">优必选</a>，有的机器人产品注重屏幕和交互，有的则注重路径、物体、语音及人脸识别等高级算法，除了安卓，还有不少人形机器人是基于 ROS 开发的。<br><a id="more"></a></p><h1 id="ROS"><a href="#ROS" class="headerlink" title="ROS"></a>ROS</h1><p>ROS(Robot Operating System) 是一个在计算机上对机器人进行操作的一个开源系统（严格来讲是一种操作系统中间件）。它提供类似操作系统所提供的功能，包含硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间的消息传递、程序发行包管理，它也提供一些工具程序和库用于获取、建立、编写和运行多机整合的程序。支持多种语言，C++、Python、Octave和LISP，也支持多种语言混合使用。</p><h1 id="基本框架和概念"><a href="#基本框架和概念" class="headerlink" title="基本框架和概念"></a>基本框架和概念</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li>main：核心部分，提供一些分布式计算的基本工具，以及整个ROS的核心部分。</li><li>universe：一种是库的代码，如OpenCV、PCL等；库的上一层是从功能角度提供的代码，如人脸识别，他们调用下层的库；最上层的代码是应用级的代码，让机器人完成某一确定的功能。</li></ul><h2 id="三个级别"><a href="#三个级别" class="headerlink" title="三个级别"></a>三个级别</h2><p>计算图级—&gt;文件系统级—&gt;社区级。</p><h3 id="计算图级"><a href="#计算图级" class="headerlink" title="计算图级"></a>计算图级</h3><p>计算图是ROS处理数据的一种点对点的网络形式。程序运行时，所有进程以及他们所进行的数据处理，将会通过一种点对点的网络形式表现出来。<br><img src="http://images.ncnynl.com/ros/2016/1365775358_7354.png" alt=""></p><ul><li>节点：执行运算任务的进程。</li><li>消息：节点之间是通过传送消息进行通讯的（标准数据类型或嵌套结构和数组）。</li><li>主题：消息以一种发布/订阅的方式传递。一个节点可以在一个给定的主题中发布消息。一个节点针对某个主题关注与订阅特定类型的数据。<br><img src="http://images.ncnynl.com/ros/2016/1365775624_5015.png" alt=""></li><li>服务：主题是广播式的。单播（同步传输模式）用服务，服务以一个字符串和一对严格规范的消息定义：一个用于请求，一个用于回应。</li><li>ROS 控制器：给ROS的节点存储了主题和服务的注册信息，是一个超级管理员，管理系统中所有节点，包括节点之间的相互通信。</li></ul><p>ROS 系统基本结构：<br><img src="https://pic2.zhimg.com/c455a744b61037c6472ae5f724adbb3d_b.png" alt=""><br>举例：机器人上有一个摄像头，我们希望能够从机器人图像处理单元以及另外一台计算机上观察摄像头的图像。<br><img src="https://pic3.zhimg.com/2bbba65b21edd83177b4e8a8c24bd7ee_b.png" alt=""></p><ol><li>需要一个管理员 ROS Master 管理整个系统，然后建立三个节点，分别是摄像头节点、机器人中的图像处理节点以及计算机上的显示节点。</li><li>在ROS Master的管理下，摄像头节点(Camera Node)发起一个主题(Topic)发送图像信息，同时，另外两个节点订阅这个主题(Topic)。</li><li>当摄像头节点从摄像头获得一帧新的图像时，它将立刻将获得的图像发送给另外两个节点（基于TCP/IP）。</li><li>如果机器人图像处理节点需要在某一个特定的时刻向摄像头节点请求一个信息，这种情况采用服务。图像处理节点可以告诉ROS Master，我需要向摄像头节点请求一项服务，然后ROS Master 将在摄像头节点和图像处理节点之间建立一个请求服务/应答的联系通道。图像处理节点将首先请求图像信息，然后摄像头节点将收集所需要的信息发送给图像处理节点。<br><img src="https://pic2.zhimg.com/73c32ee87d2d30c4c6674202ed24f28d_b.png" alt=""></li></ol><h3 id="文件系统级"><a href="#文件系统级" class="headerlink" title="文件系统级"></a>文件系统级</h3><p>在硬盘上面查看的ROS源代码的组织形式。<br><img src="http://images.ncnynl.com/ros/2016/1365776297_4808.png" alt=""><br>ROS的软件以包的方式组织起来。包包含节点、ROS依赖库、数据套、配置文件、第三方软件、或者任何其他逻辑构成。<br>堆是包的集合，它提供一个完整的功能，像“navigation stack”。<br><img src="http://images.ncnynl.com/ros/2016/1365776550_5049.png" alt=""></p><h2 id="对ros的一些理解"><a href="#对ros的一些理解" class="headerlink" title="对ros的一些理解"></a>对ros的一些理解</h2><p>根据<a href="http://courses.cs.washington.edu/courses/cse466/11au/calendar/ros_cc_1_intro-jrsedit.pdf" target="_blank" rel="noopener">这个教程</a>，ROS 虽然号称是操作系统，但实际并不是传统意义上的操作系统。它只是一个通信的架构、一个代码管理的框架。操作系统的功能：任务的时序规划和CPU资源分配等等工作都是依靠linux来实现的，因此ROS不可能脱离linux，他们是一体的。</p><p>机器人的核心平台——多传感器和处理器之间的通信、处理器和执行器之间的通信，这些通信必须有统一的时钟，比如做传感器数据融合，如果从传感器抓回来的数据时间上都不同步，那融合根本没法做。ROS的通信架构，主要解决的就是这个问题：让设备之间的通信有一个统一的调度中枢(roscore)，通过这个调度中枢不但可以让信号传递更好控制，还能够通过构建通信设备之间的关系来让开发者明白自己的机器人内部在干什么。</p><p>综上总结：我们可以把ros理解成一套基于Linux的能够协调各种传感器和CPU工作的开发框架。</p><h1 id="基于安卓系统的机器人开发"><a href="#基于安卓系统的机器人开发" class="headerlink" title="基于安卓系统的机器人开发"></a>基于安卓系统的机器人开发</h1><p>在安卓进行机器人开发没有像在 Ubuntu 上ROS一样被广泛使用的开发框架。从网上看到的一些例子来看，基于安卓的机器人开发主要涉及以下内容：</p><ul><li>硬件平台：器件选型以及主要运动模块的制作和实现。</li><li>软件平台：Linux 内核和<br>Android 操作系统在实体机上的编译，往实验平台上烧写在实体<br>机中编译的 Linux 内核镜像和 Android 操作系统镜像。</li><li>针对实际需要对实验平台的硬件接口进行功能重设：设计编写硬件驱动程序，并将其在 Linux 内核中进行编译识别，最后为新编译的驱动设计编写硬件驱动层和硬件访问服务层的实现程序，使得 Android 应用程序中能够使用这些硬件。</li><li>安卓应用程序开发。可以是开发板应用软件，也可以有远程控制端软件，实现对机器人的运动控制。</li></ul><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ol><li>Ubuntu 和 Android 都可以看做基于Linux内核的不同版本。Ubuntu是机器人领域里开发最受欢迎的一个版本，就是因为ROS。80%的ROS都是运行在Ubuntu上的。从官方信息看，ros移植到安卓上是可行的，官网也有一些不成熟的教程。（有人做了这样的尝试：<a href="https://en.wikipedia.org/wiki/Robot_Operating_System" target="_blank" rel="noopener">文章来源</a>）。<blockquote><p>The native Java ROS client library, rosjava, has enabled ROS-based software to be written for the Android OS.</p></blockquote></li><li>ROS能够支持多种语言，如C++、python、Octave和LISP，甚至支持多种语言混合使用。Android支持Java和C++（NDK层）。</li><li>如果只是一个交互，像触摸屏，让它发声，Android是没有问题的，但如果让机器人做人脸、声音、路径识别，这些算法自己来实现是很困难的，而ros有很多人会把库贡献在这个平台上，为开发者提供了很多方便。</li><li>如果产品是重交互，轻路径、人脸识别，或者人工智能这样场景的产品，安卓比较好；但是如果产品有更多的机会用到一些复杂算法，则 Ubuntu+ROS 应该是更好的选择。</li></ol><h1 id="其他机器人系统"><a href="#其他机器人系统" class="headerlink" title="其他机器人系统"></a>其他机器人系统</h1><ul><li><a href="http://36kr.com/p/211741.html" target="_blank" rel="noopener">V-sido</a>：日本一家公司开发的系统，做的是类似于ros的事情。</li></ul><blockquote><p>参考资料：<br><a href="http://www.fabiao.net/content-43-2074548-1.html" target="_blank" rel="noopener">基于Android的双目视觉机器人运动平台无线网络控制系统</a><br><a href="http://download.farsight.com.cn/download/pdf/Farsight120317bj-2-Android.pdf" target="_blank" rel="noopener">基于Android机器人–智能家居</a><br><a href="http://v.youku.com/v_show/id_XMTc4MDgxOTg1Ng==.html?f=28518141&amp;o=0" target="_blank" rel="noopener">Ubuntu Core 和SNAP 开发技术介绍</a><br><a href="https://zhuanlan.zhihu.com/p/20769823" target="_blank" rel="noopener">Programming Robots with ROS</a><br><a href="http://www.ncnynl.com/archives/201609/838.html" target="_blank" rel="noopener">ros教程</a><br><a href="http://www.devstore.cn/new/newInfo/19371.html" target="_blank" rel="noopener">机器人开源项目盘点</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ROS </tag>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TableView 动态 cell 高度自适应方案</title>
      <link href="/2018/06/13/dynamic-height-cell/"/>
      <url>/2018/06/13/dynamic-height-cell/</url>
      <content type="html"><![CDATA[<p>相比安卓 ListView/RecylerView，iOS 中 TableViewCell 高度自适应是需要开发者自己想办法解决的，原因在于 tableview 的渲染机制默认是先获取 cell 高度，然后再去绘制 cell 体。由于 label/textview 等通常是高度不定的，cell 高度动态化是个很常见的需求。<br><a id="more"></a></p><h1 id="方案一：高度固定"><a href="#方案一：高度固定" class="headerlink" title="方案一：高度固定"></a>方案一：高度固定</h1><p>针对所有 Cell 具有固定高度的情况：</p><ol><li><code>self.tableView.rowHeight = 88;</code></li><li>实现协议方法 <code>heightForRowAtIndexPath:</code>。</li></ol><p><strong>缺点：</strong>不支持动态高度。</p><h1 id="方案二：cell-预估高度（iOS-7-）"><a href="#方案二：cell-预估高度（iOS-7-）" class="headerlink" title="方案二：cell 预估高度（iOS 7+）"></a>方案二：cell 预估高度（iOS 7+）</h1><p><strong>设计思路：</strong><br>加载 tableview 时一次性计算所有 cell 高度太耗性能。所以把计算 height 的任务从 load time 转移到 scrolling time。只有滑动到的 cell 会计算，屏幕外边的不会计算。<br>方法：<code>tableView: estimatedHeightForRowAtIndexPath:</code><br>这是 iOS 7.0 出现的 UITableViewDelegate 中的方法,表示返回某行 cell 的预估高度。这个方法改变了 TableView 代理方法的调用顺序。<br>未调用<code>estimatedHeightForRow...</code>方法时：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwa5hooy28j30f105z75c" alt=""><br>调用<code>estimatedHeightForRow...</code>后：<br><img src="https://ww1.sinaimg.cn/large/005YhI8igy1fwa5i5kg83j30fb03t0th" alt=""><br>此时 tableView 工作原理：</p><ol><li>tableView 先向代理拿得到每个 cell 的预估高度(<code>estimatedHeightForRow...</code>方法)，并且拿这个高度去计算整个 tableView 应该显示的范围。</li><li>根据每行预估的高度，算出一屏显示的 cell 的个数，并先对这些 cell(调用<code>cellForRow...</code>方法)进行绘制。</li><li>绘制时拿到 cell 的真实高度,然后放在<code>heightForRow...</code>方法里面拿给 tabelView 去用。</li><li>屏幕滚动(有 cell 进入屏幕)的时候,仍然会调用绘制以及获取真实高度的方法。</li></ol><p>简单点说，预估高度用来让 tableView 心里有个底，把 cell 先绘制出来，但最后实际的 cell 高度还是会从<code>heightForRow...</code>方法中获取。</p><p><strong>缺点：</strong></p><ol><li>设置估算高度后，<code>tableview.contentSize.height</code>根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</li><li>估算高度使加载速度更快，但侵害滑动流畅性，cell较多情况下滑动时实时计算高度带来的卡顿是明显能体验到的。</li></ol><h1 id="方案三：self-sizing-cell-（iOS-8-）"><a href="#方案三：self-sizing-cell-（iOS-8-）" class="headerlink" title="方案三：self-sizing cell （iOS 8+）"></a>方案三：self-sizing cell （iOS 8+）</h1><p><strong>设计思路：</strong><br>如图，row123 是已经在屏幕上被展示的cell, 而 row4 是下一个会被展示的cell, 这时 row4 这个 cell 的 rowHeight 是预先为其设置的 estimated height， 又或者是  UITableViewDelegate 中返回的 height。<br>当用户滚动的时候，首先 cell 会被创建或重用，然后 cell 会被调用调整 size 的方法， 接着 cell 会根据 tableView 的size去调整自身的 contentSize，最后cell被展示出来。<br><img src="http://ww2.sinaimg.cn/mw690/005tGCqhjw1f9fwywhi35j308p07zq31.jpg" alt=""><br>如何让一个cell去调整自己的高度？</p><ol><li>cell 要使用 Autolayout 布局；</li><li>在 tableView 中启动动态布局, 告诉 tableView 用新的方法来布局行高.而不是 rowHeight 或者 delegate 方法。<br><code>tableView.rowHeight = UITableViewAutomaticDimension;</code></li></ol><p><strong>缺点：</strong></p><ol><li>仅支持iOS 8+；</li><li>高度没有缓存。iOS 7 计算高度后有”缓存“机制，不会重复计算；iOS 8 不论何时都会重新计算 cell 高度。</li></ol><h1 id="方案四：FDTemplateLayoutCell（iOS-6-）"><a href="#方案四：FDTemplateLayoutCell（iOS-6-）" class="headerlink" title="方案四：FDTemplateLayoutCell（iOS 6+）"></a>方案四：FDTemplateLayoutCell（iOS 6+）</h1><p>好处：既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。</p><ol><li>根据 autolayout 约束自动计算高度。使用了系统在 iOS6 提供的 API：<code>-systemLayoutSizeFittingSize:</code></li><li>根据 indexPath 的一套高度缓存机制。<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了多余计算。</li><li>自动的缓存失效机制。<br>UITableView 刷新时，已有的高度缓存将以最小的代价失效。如删除一个 indexPath 为 [0:5] 的 cell，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li><li>预缓存机制（通过 runloop 实现）。<br>UITableView 没有滑动的空闲时刻会计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性。</li></ol><p><strong>缺点：</strong><br>要求约束设置完整准确，保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。（这个实际上是<code>systemLayoutSizeFittingSize:</code>的要求）。</p><p>从易用性、性能、高度自适应效果、适配 iOS 最低版本综合来看，方案四是最佳的。但需要引入第三方库，同时要保证 autolayout 约束完整准确才行，关于这点<a href="https://www.jianshu.com/p/386b792054b1" target="_blank" rel="noopener">《UITableViewCell高度自适应的关键点》</a>总结得很好：</p><blockquote><p>Cell 内部的 Constraints 一定要有一条从 Cell 顶部到底部的一条可联通线。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为 ViewControllers 瘦身</title>
      <link href="/2018/05/30/light-viewcontrollers/"/>
      <url>/2018/05/30/light-viewcontrollers/</url>
      <content type="html"><![CDATA[<p>目标：写可维护的代码。<br><a id="more"></a></p><h2 id="把-TableView-从-VC-中抽离"><a href="#把-TableView-从-VC-中抽离" class="headerlink" title="把 TableView 从 VC 中抽离"></a>把 TableView 从 VC 中抽离</h2><p>UITableView 可以说是 iOS 界面开发中用的最广泛的组件，就我自己做过的项目而言，绝大部份 ViewController 都是在围绕 UITableViewDelegate 和 UITableViewDataSource 中的方法打交道。但说到底这些函数都是 View 层面的，全部在 VC 中处理显得不太合适，也不利于日后的维护和扩展，所以关于瘦身 VC 很容易想到一点是从 VC 中抽离 tableView 的表示逻辑。这种思想其实与最近火热的<a href="http://www.cnblogs.com/ludashi/p/4211556.html" target="_blank" rel="noopener">MVVM</a>设计模式相通。核心是<strong>把逻辑代码尽量移到 model 层</strong>, 你可以认为它是一个中间层 , 逻辑代码可以是各种 delegate,网络请求,缓存,数据库,coredata 等, 而 controller 正是用来组织串联他们，使得整个程序走通。</p><h3 id="把-Data-Source-分离出来"><a href="#把-Data-Source-分离出来" class="headerlink" title="把 Data Source 分离出来"></a>把 Data Source 分离出来</h3><p>举例:当需要将一个数组映射到一个 tableView 进行显示，这种一一对应关系可以单独写一个类<code>ArrayDataSource</code>，使用 block 或者 delegate 设置 cell。ArrayDataSource 类完全可以复用到任何需要将一个数组的内容映射到一个 tableView 的场景。<br>ArrayDataSource 中声明 <code>block(cell,item)</code> 来初始化 cell，block实现方式（item 和 cell 如何对应）则可以在 cell+Configure 的 category 中声明。<br>使用<code>ArrayDataSource</code>，在<code>ViewController</code>中执行<code>setUpTableView</code>即可。<code>setUpTableView</code>中实现 block（可以是执行 configure 方法的方式）。使用 cell 类 category 的方式是为了避免向 dataSource 暴露 cell 的设计,说白了是为了更好得分离 view 和 model 层。</p><blockquote><p><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank" rel="noopener">1.1 参考项目看这里</a></p></blockquote><h3 id="把-Data-Source-和-Delegate-都分离出来"><a href="#把-Data-Source-和-Delegate-都分离出来" class="headerlink" title="把 Data Source 和 Delegate 都分离出来"></a>把 Data Source 和 Delegate 都分离出来</h3><p>1.1中的方法是在<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a>一文中提到的。但该文讲的只是把<code>UITableViewDataSource</code>中的方法提取到一个单独的类，从结果来看，是把<code>numberOfRowsInSection</code>和<code>cellForRowAtIndexPath</code>从 VC 中提取出去。但实际上<code>UITableViewDelegate</code>也是可以抽象出去的。例如 cell 的生成, cell 行高, 点击事件等等。这里用 block 实现回调。<br>处理类<code>TableViewDataSourceDelegate.h</code></p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void    (^TableViewCellConfigureBlock)(NSIndexPath *indexPath, id item, XTRootCustomCell *cell) ;typedef CGFloat (^CellHeightBlock)(NSIndexPath *indexPath, id item) ;typedef void    (^DidSelectCellBlock)(NSIndexPath *indexPath, id item) ;@interface TableViewDataSourceDelegate : NSObject &lt;UITableViewDelegate,UITableViewDataSource&gt;//初始化方法: 传数据源, cellIdentifier, 三个block分别对应配置, 行高, 点击。- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock ;//将UITableViewDataSource和UITableViewDelegate设于TableViewDataSourceDelegate。- (void)handleTableViewDatasourceAndDelegate:(UITableView *)table ;//默认indexPath.row对应每个dataSource相应返回item。- (id)itemAtIndexPath:(NSIndexPath *)indexPath ;@end</code></pre><p>在 1.1 中为了避免 model 和 view 的耦合，将 cell 的配置用 category 方法处理。但使用的方式是每一个<code>UITableViewCell</code>都做了扩展，实际上可以做得更彻底 ——直接对这些子类的父类<code>UITableViewCell</code>进行扩展。这样做的好处是比 1.1 的扩展方法更加灵活，可以提供多个 configure 方法，针对不同类型的 model 进行数据展示，同时也增强 cell 的移植性。<br>为 UITableViewCell 提供扩展<code>UITableViewCell+Extension.h</code></p><pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;@interface UITableViewCell (Extension)//实际是tableView reigister nib，由于是与cell(view)紧密相关的方法，故在cell本身进行实现，而非在vc中。+(void) registerTable:(UITableView*)table        nibIdentifier:(NSString*)identifier;//根据数据源配置并绘制cell 子类需重写该方法-(void)configure:(UITableViewCell*)cell       customObj:(id)obj       indexPath:(NSIndexPath*)indexPath;//根据数据源计算cell的高度 子类可重写该方法, 若不写为默认值44.0+(CGFloat)getCellHeightWithCustomObj:(id)obj                        indexPath:(NSIndexPath*)indexPath;@end</code></pre><p>如此，对于每一个 cell 子类，实现两个新方法:</p><pre><code class="objc">- (void)configure:(UITableViewCell *)cell        customObj:(id)obj        indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}+ (CGFloat)getCellHeightWithCustomObj:(id)obj                            indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}</code></pre><p>OK,做了这么多工作，返回 VC 看一下最后的成果吧！瘦身后的 viewController 对于 tableView 的所有处理都只需要一个方法<code>setUpTableView</code></p><pre><code class="objc">- (void)setupTableView{    TableViewCellConfigureBlock configureCell = ^(NSIndexPath *indexPath, MyObj *obj, XTRootCustomCell *cell) {        [cell configure:cell customObj:obj indexPath:indexPath] ;    } ;    CellHeightBlock heightBlock = ^CGFloat(NSIndexPath *indexPath, id item) {        return [MyCell getCellHeightWithCustomObj:item indexPath:indexPath] ;    } ;    DidSelectCellBlock selectedBlock = ^(NSIndexPath *indexPath, id item) {        NSLog(@&quot;click row : %@&quot;,@(indexPath.row)) ;    } ;    self.tableHandler = [[TableDataDelegate alloc] initWithItems:self.list                                                   cellIdentifier:MyCellIdentifier                                               configureCellBlock:configureCell                                                  cellHeightBlock:heightBlock                                                   didSelectBlock:selectedBlock] ;    [self.tableHander handleTableViewDatasourceAndDelegate:self.table] ;}</code></pre><blockquote><p>1.2 <a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">参考项目看这里</a></p></blockquote><h3 id="抽离-TableView-终极版"><a href="#抽离-TableView-终极版" class="headerlink" title="抽离 TableView 终极版"></a>抽离 TableView 终极版</h3><p>经过 1.2 的处理，<code>UITableViewDelegate</code> 和 <code>UITableViewDataSource</code> 的方法都已经移到<code>TableViewDataSourceDelegate</code>这个类中处理，但根据<br><a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">1.2参考项目</a>可以发现1.2的处理方式有局限性，我们观察<code>TableViewDataSourceDelegate</code>中的核心方法:</p><pre><code class="objc">- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock;</code></pre><p><code>TableViewDataSourceDelegate</code>进行初始化时需传递参数<code>CellIdentifier</code>和<code>aHeightBlock</code>,实际开发工作中这两者通常是和<code>UITableViewCell</code>类紧密相关的。一类 <code>UITableViewCell</code>往往对应一个它自己的 <code>CellIdentifier</code> 和 <code>cellHeight</code>，如果初始化<code>TableViewDataSourceDelegate</code>对象时就指定这两个属性，则<code>TableViewDataSourceDelegate</code>仅局限于被一种 tableView 复用:cell种类都相同，也就是用一个tableView展示一个数组( indexPath.row 对应数组下标)。如图：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezscp180r2j30af0hz755.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005tGCqhjw1ezscrw6qbyj30ah0icgnm.jpg" alt=""><br>这些 cell 都是同一种类，但实际开发中往往面临着更复杂的 cell 样式，如我在开发<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">校友圈</a>时：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezsd219avzj30ag0ikaau.jpg" alt=""><br>这种情况怎么使用<code>TableViewDataSourceDelegate</code>呢？修改<code>TableViewDataSourceDelegate</code>的 init 方法：</p><pre><code class="objc">(id)initWithItems:(NSDictionary *)anItemsconfigureCellBlock:(TableViewCellConfigureCellBlock)aConfigureCellBlock   cellHeightBlock:(CellHeightBlock)aHeightBlock    didSelectBlock:(DidSelectCellBlock)aDidSelectBlock;</code></pre><h2 id="业务逻辑移到-model-中"><a href="#业务逻辑移到-model-中" class="headerlink" title="业务逻辑移到 model 中"></a>业务逻辑移到 model 中</h2><p>尽管 viewController 最主要功能是处理业务逻辑，但对于一些和 model 联系紧密，和 view 关系不大（即不是 model 和 view 进行交互的逻辑）的代码应移到 model 中，通常是用 category 的处理方法，更加清晰。</p><h2 id="网络请求逻辑移到-model"><a href="#网络请求逻辑移到-model" class="headerlink" title="网络请求逻辑移到 model"></a>网络请求逻辑移到 model</h2><p>用 category 方式处理。viewController 使用 block 回调请求网络。</p><h2 id="view-代码移到-view-层"><a href="#view-代码移到-view-层" class="headerlink" title="view 代码移到 view 层"></a>view 代码移到 view 层</h2><p>不要在 viewController 中构建复杂的 view 层次结构。<br>要注意的是，IB 并非只能和 viewControllers 一起使用，可以加载单独的 nib 文件到自定义的 view 中。</p><blockquote><p>参考：<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
