<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iPhone &amp; Android 换机通信方案分析</title>
      <link href="/2018/06/13/ios-android-transfer/"/>
      <url>/2018/06/13/ios-android-transfer/</url>
      <content type="html"><![CDATA[<p>目前市面上的换机产品（QQ同步助手、闪电换机等）都是支持 Android to Android 的场景，如果在 iPhone 作为旧机，安卓做新机，可将 libmobiledevice 库（目前支持Mac、Windows、Linux平台）移植到安卓，拿到 iPhone 手机的本地应用信息、多媒体文件、通讯录等，从而进行换机操作。<br><a id="more"></a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f9itoognq5j30nq0bwju0.jpg" alt=""><br>如图，通过某种方式将 iOS 与 Android 设备相连，在 Android 设备上读取 iPhone 手机上的通讯录、图片、音乐、视频、app 等信息，进一步实现：</p><ol><li>在两台设备间实现数据迁移。</li><li>通过 Android 设备给 iPhone 分发下载应用。 </li></ol><p>可以简单理解为安卓手机上实现类似 iTunes 的功能。</p><h1 id="现在市场上有没有类似应用"><a href="#现在市场上有没有类似应用" class="headerlink" title="现在市场上有没有类似应用"></a>现在市场上有没有类似应用</h1><p>有的。</p><h2 id="借助-PC-端通信"><a href="#借助-PC-端通信" class="headerlink" title="借助 PC 端通信"></a>借助 PC 端通信</h2><p><a href="http://www.itools.cn/" target="_blank" rel="noopener">iTools</a> / <a href="http://www.25pp.com/" target="_blank" rel="noopener">PP助手</a> / <a href="http://www.kuaiyong.com/" target="_blank" rel="noopener">快用</a> 等都是 有着“无需越狱，即可同步”功能类似 itunes 的苹果设备同步管理软件。均提供 PC 端和手机端应用。从官网描述看，这些应用可以提供的服务主要有两个：</p><ol><li>数据管理、同步与备份（短信、联系人、照片、音乐等）。</li><li>和 iTunes 一样进行 iOS 应用程序的安装与卸载（<strong>这种功能是违反苹果规定的</strong>）。</li></ol><p><img src="http://seuzl.qiniudn.com/md/1528949604337.png" alt=""></p><h2 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h2><p>诸如 <a href="https://play.google.com/store/apps/details?id=com.sec.android.easyMover&amp;hl=en" target="_blank" rel="noopener">Samsung Smart Switch Mobile</a> 或 <a href="https://play.google.com/store/apps/details?id=com.sonymobile.xperiatransfermobile&amp;hl=en" target="_blank" rel="noopener">Xperia™ Transfer Mobile</a> 均提供两台设备间数据传输的功能，初衷是为了满足换机用户将旧手机里的所有资料、数据、应用导入新手机的需求。既支持 Android -&gt; Android，也支持 iOS -&gt; Android。具体用法<a href="http://www.samsung.com/hk_en/support/smartswitch/" target="_blank" rel="noopener">看这里</a>。</p><h1 id="获取-iDevice-数据可能的途径"><a href="#获取-iDevice-数据可能的途径" class="headerlink" title="获取 iDevice 数据可能的途径"></a>获取 iDevice 数据可能的途径</h1><h2 id="iTunes"><a href="#iTunes" class="headerlink" title="iTunes"></a>iTunes</h2><p><a href="http://www.apple.com/cn//itunes/download/" target="_blank" rel="noopener">iTunes</a> 既是一款媒体播放器，也是苹果官方提供的用于管理 iOS 设备的主要工具。通过 iTunes 可同步和备份 iPhone 上的音乐、视频、录音、电子书等。<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f9ivq6q6qcj30xk07q76t.jpg" alt=""><br>此外还可以<a href="http://stackoverflow.com/questions/26720764/install-ipa-with-itunes-12" target="_blank" rel="noopener">通过 iTunes 向 iOS 设备安装 ipa 文件</a>。</p><h2 id="iCloud"><a href="#iCloud" class="headerlink" title="iCloud"></a>iCloud</h2><p><a href="https://www.icloud.com/" target="_blank" rel="noopener">iCloud</a> 是苹果公司所提供的云存储和云计算服务。用户能在 iCloud 中存储音乐、照片、App、联系人和日历等，并将无线推送到用户所有支持 iCloud 同步的设备上，这也是它和 iTunes 提供的同步功能不同的一点 —— 不用使用连接线。<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9iw0q1pnij30xw0aotb6.jpg" alt=""></p><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>参考 iTunes 和 iCloud 工作方式，可以猜想实现 iPhone 与安卓设备数据同步的方式有两种（不借助 PC 端，Samsung Smart Switch Mobile 确实提供了这两种同步方式）：</p><ol><li><a href="https://www.youtube.com/watch?v=KbV5Qkl8xl0" target="_blank" rel="noopener">有线</a>。（通过 Micro USB 相连，iPhone 识别相连设备并信任后，打开安卓应用直接进行同步）。</li><li><a href="https://www.youtube.com/watch?v=Oz4chv6gRw8" target="_blank" rel="noopener">无线</a>。（在安卓应用输入 iCloud 账号和密码，登录后获取 iCloud 中的备份数据并同步）。</li></ol><p>而如果要在安卓设备进行 iOS 应用的管理（获取现有应用列表、安装、卸载），则只能是通过有线的方式实现。</p><h1 id="libimobiledevice"><a href="#libimobiledevice" class="headerlink" title="libimobiledevice"></a>libimobiledevice</h1><p>苹果官方提供了 iTunes 的 Mac 版和 windows 版，不支持Linux系统。一些 Linux 高手不能忍受因为要连接 iOS 设备就换用操作系统，因此就有人逆向出 <strong>iOS 设备与 Windows/Mac Host 接口的<a href="http://www.libimobiledevice.org/docs/mobilesync.html" target="_blank" rel="noopener">通讯协议</a></strong>，最终成就了横跨三大桌面平台的非官方版本 USB 接口 library —— <a href="http://www.libimobiledevice.org/" target="_blank" rel="noopener">libimobiledevice</a>。官方描述：</p><blockquote><p>libimobiledevice is a cross-platform software library that talks the protocols to support iPhone®, iPod Touch®, iPad® and Apple TV® devices. Unlike other projects, it does not depend on using any existing proprietary libraries and does not require jailbreaking. It allows other software to easily access the device’s filesystem, retrieve information about the device and it’s internals, backup/restore the device, manage SpringBoard® icons, manage installed applications, retrieve addressbook/calendars/notes and bookmarks and (using libgpod) synchronize music and video to the device. The library is in development since August 2007 with the goal to bring support for these devices to the Linux Desktop.</p></blockquote><p>简而言之就是它不依赖于第三方库，跨平台的实现了 iPhone，iPod Touch，iPad 等苹果设备的通讯协议。可以看作和 iTools 一样，都是可以替代iTunes，进行 iOS 设备管理的工具。因为<a href="https://github.com/libimobiledevice" target="_blank" rel="noopener">源码是开放的</a>，可以自行编译，众多开发者便利用这个库开发出了各种基于不同平台的 iOS 设备管理工具。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iPhone </tag>
            
            <tag> Android </tag>
            
            <tag> 换机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 10 通知更新详解</title>
      <link href="/2018/06/13/ios10-notification/"/>
      <url>/2018/06/13/ios10-notification/</url>
      <content type="html"><![CDATA[<p>关于「通知」iOS 10 新增了一个框架 <a href="https://developer.apple.com/reference/usernotifications?language=objc" target="_blank" rel="noopener">UserNotifications.framework</a>，即“用户通知框架”，推送 “Push” 只是「通知」触发的一种方式，而「通知」是操作系统层面的一种UI展示。<br><a id="more"></a><br>苹果官方文档中 Notification 分为两类：</p><ul><li>Remote (远程，即 Push 方式)</li><li>Local (本地，通知由本地事件触发，iOS 10 中有三种不同的触发 “Trigger” 方式，下文有详细说明)</li></ul><p>所以，「推送」只是「通知」的一种触发方式，从 iOS 迭代更新的历史特征中看，「通知」一直是被苹果作为重点内容来延展的。iOS 10 中新增了独立框架（之前一直存在于 UIKit Framework 中）还有丰富的特性更新。</p><h1 id="更新概览"><a href="#更新概览" class="headerlink" title="更新概览"></a>更新概览</h1><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><ol><li>Familiar API with feature parity</li><li>Expanded content</li><li>Same code path for local and remote notification handling</li><li>Simplified delegate methods</li><li>Better notification management</li><li>In-app presentation option</li><li>Schedule and handle notifications in extensions</li><li>Notification Extensions</li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li>相同的特性使用类似API（之前的功能API使用方法类似但是还是稍有改变）</li><li>内容扩展（支持附件和展示更多内容）</li><li>本地通知和远程通知操作代码在相同调用路径（合并代理方法）</li><li>简化代理方法</li><li>更好的通知管理（支持通知查、改、删；增强本地通知管理，增加日历与地理位置事件的触发）</li><li>应用内通知展示（之前App在前台的情况下收到通知不会UI展示）</li><li>在Extensions中规划和操作通知（使更新通知内容和删除误发或过期的通知内容成为可能，另一个重要场景为端到端加密）</li><li>引入通知Extensions</li></ol><h1 id="用-UserNotifications-Framework-实现通知"><a href="#用-UserNotifications-Framework-实现通知" class="headerlink" title="用 UserNotifications Framework 实现通知"></a>用 UserNotifications Framework 实现通知</h1><h2 id="在-Xcode-中启用推送通知"><a href="#在-Xcode-中启用推送通知" class="headerlink" title="在 Xcode 中启用推送通知"></a>在 Xcode 中启用推送通知</h2><p>要使用 UserNotifications Framework 需在 Xcode 项目中开启推送通知：<br>Project Target –&gt; Capabilities –&gt; Push Notifications<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f7sxvwcvu0j30go0cidgz.jpg" alt=""></p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><pre><code class="Objective-C">#import &lt;UserNotifications/UserNotifications.h&gt;</code></pre><h2 id="注册推送"><a href="#注册推送" class="headerlink" title="注册推送"></a>注册推送</h2><pre><code class="Objective-C">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // iOS 10 before    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];    [application registerUserNotificationSettings:settings];    // iOS 10    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];    [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) {        if (!error) {            NSLog(@&quot;request authorization succeeded!&quot;);        }    }];    return YES;}</code></pre><h2 id="Token-Registration"><a href="#Token-Registration" class="headerlink" title="Token Registration"></a>Token Registration</h2><p>跟之前一样：</p><pre><code class="Objective-C">[[UIApplication sharedApplication] registerForRemoteNotifications];</code></pre><h2 id="Notification-Settings"><a href="#Notification-Settings" class="headerlink" title="Notification Settings"></a>Notification Settings</h2><p>之前注册推送服务，首次安装 APP 后弹出授权推送通知框，用户点击了同意还是不同意，以及用户之后又做了怎样的更改我们是无从得知的，现在 apple 开放了这个 API，我们可以直接获取到用户的设定信息了。</p><pre><code class="Objective-C">[center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {        NSLog(@&quot;%@&quot;,settings);}];</code></pre><p>打印 settings 如下：</p><pre><code class="Objective-C">&lt;UNNotificationSettings: 0x16567310; authorizationStatus: Authorized, notificationCenterSetting: Enabled, soundSetting: Enabled, badgeSetting: Enabled, lockScreenSetting: Enabled, alertSetting: NotSupported,carPlaySetting: Enabled, alertStyle: Banner&gt;</code></pre><p><code>settings.authorizationStatus</code>有三个值：</p><pre><code class="Objective-C">typedef NS_ENUM(NSInteger, UNAuthorizationStatus) {    // 用户还没决定是否允许开启推送通知.    UNAuthorizationStatusNotDetermined = 0,    // 不允许开启通知.    UNAuthorizationStatusDenied,    // 允许开启.    UNAuthorizationStatusAuthorized} __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);</code></pre><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>以前只能展示一条文字，现在可以有 title 、subtitle 以及 body.<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f7syzclsj2j30og0dcmz8.jpg" alt=""><br>定制方法：</p><pre><code class="Objective-C">//Local NotificationUNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];content.title = @&quot;Introduction to Notifications&quot;;content.subtitle = @&quot;Session 707&quot;;content.body = @&quot;Woah! These new notifications look amazing! Don’t you agree?&quot;;content.badge = @1;//Remote Notification{&quot;aps&quot; : {    &quot;alert&quot; : {          &quot;title&quot; : &quot;Introduction to Notifications&quot;,          &quot;subtitle&quot; : &quot;Session 707&quot;,                  &quot;body&quot; : &quot;Woah! These new notifications look amazing! Don’t you agree?&quot;                },    &quot;badge&quot; : 1        },}</code></pre><h2 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h2><p>本地通知新增了两种新的 Triggers —— 日历和地理位置。日历 Triggers 让开发者可以根据指定的日期和时间来展示本地通知，并且支持循环条件，如“每周二上午十一点”这种条件。地理位置 Triggers 可以在进入或者离开指定区域时触发本地通知，如“某品牌App在你进入该品牌线下店铺的范围内即展示最新优惠信息”等。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f7t4uo402xj30og0dc75e.jpg" alt=""><br>Triggers 有三种值：</p><ul><li>UNTimeIntervalNotificationTrigger</li><li>UNCalendarNotificationTrigger</li><li>UNLocationNotificationTrigger</li></ul><pre><code class="Objective-C">//2 分钟后提醒UNTimeIntervalNotificationTrigger *trigger1 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:120 repeats:NO];//每小时重复 1 次（循环）UNTimeIntervalNotificationTrigger *trigger2 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:3600 repeats:YES];//每周一早上 8：00 提醒我NSDateComponents *components = [[NSDateComponents alloc] init];components.weekday = 2;components.hour = 8;UNCalendarNotificationTrigger *trigger3 = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES];//#import &lt;CoreLocation/CoreLocation.h&gt;//一到麦当劳就喊我下车CLRegion *region = [[CLRegion alloc] init];UNLocationNotificationTrigger *trigger4 = [UNLocationNotificationTrigger triggerWithRegion:region repeats:NO];</code></pre><h2 id="Add-Request"><a href="#Add-Request" class="headerlink" title="Add Request"></a>Add Request</h2><pre><code class="Objective-C">NSString *requestIdentifier = @&quot;sampleRequest&quot;;UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifier                                                                          content:content                                                                          trigger:trigger1];[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {}];</code></pre><h2 id="通知实现小结"><a href="#通知实现小结" class="headerlink" title="通知实现小结"></a>通知实现小结</h2><ul><li>Local Notifications:<ol><li>定义 <code>Content</code>. </li><li>定义 <code>Trigger</code>.</li><li>向 <code>UNUserNotificationCenter</code> 发送 <code>request</code>.</li></ol></li></ul><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t52xcybqj30op0d6766.jpg" alt=""></p><ul><li>Remote Notifications: 向 APNs 发送 <code>Notification Payload</code>.</li></ul><h1 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h1><h2 id="UNUserNotificationCenterDelegate"><a href="#UNUserNotificationCenterDelegate" class="headerlink" title="UNUserNotificationCenterDelegate"></a>UNUserNotificationCenterDelegate</h2><p><code>UNUserNotificationCenterDelegate</code>提供了两个方法：</p><ul><li>在应用内展示通知。App 处于前台时捕捉并处理即将触发的推送：</li></ul><pre><code class="Objective-C">@interface AppDelegate () &lt;UNUserNotificationCenterDelegate&gt;-(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler{    completionHandler(UNNotificationPresentationOptionAlert | UNNotificationPresentationOptionSound);}</code></pre><ul><li>收到通知响应时的处理工作。用户与你推送的通知进行交互时被调用：</li></ul><pre><code class="Objective-C">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler{      completionHandler()//什么也不做}</code></pre><h2 id="Notification-Management"><a href="#Notification-Management" class="headerlink" title="Notification Management"></a>Notification Management</h2><p>可以对通知执行查、改、删操作。实现该功能需要有一个必要参数<code>identifer</code>，后续的查改删操作都是根据此参数去执行的。</p><ul><li>Local Notification：通过更新 request.</li><li>Remote Notification 通过新的字段 <code>apns-collapse-id</code>.</li></ul><p>更新原有推送：</p><pre><code class="Objective-C">NSString *requestIdentifier = @&quot;sampleRequest&quot;;UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifier                                                                      content:newContent                                                                      trigger:newTrigger1];[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {}];</code></pre><p>删除推送：</p><pre><code class="Objective-C">[center removePendingNotificationRequestsWithIdentifiers:@[requestIdentifier]];</code></pre><p>典型应用场景：</p><ul><li>赛事比分更新</li><li>撤回通知<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t9swwyxqj30og0dcta2.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t9t2wnu3j30og0dcgmw.jpg" alt=""></li></ul><h1 id="Notification-Extension"><a href="#Notification-Extension" class="headerlink" title="Notification Extension"></a>Notification Extension</h1><p><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f7xzisvg36j30l80fc0vp.jpg" alt=""></p><h2 id="Service-Extension"><a href="#Service-Extension" class="headerlink" title="Service Extension"></a>Service Extension</h2><p>Service Extension允许在收到远程推送的通知后，展示之前对通知内容进行修改。</p><pre><code class="Swift">class NotificationService: UNNotificationServiceExtension {    var contentHandler: ((UNNotificationContent) -&gt; Void)?    var bestAttemptContent: UNMutableNotificationContent?    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {        self.contentHandler = contentHandler        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)        if let bestAttemptContent = bestAttemptContent {            if request.identifier == &quot;mutableContent&quot; {                bestAttemptContent.body = &quot;\(bestAttemptContent.body),tuneszhao&quot;            }            contentHandler(bestAttemptContent)        }    }    override func serviceExtensionTimeWillExpire() {        // Called just before the extension will be terminated by the system.        // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used.        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {            contentHandler(bestAttemptContent)        }    }}</code></pre><ul><li><code>didReceive:</code>方法中通过修改请求的<code>content</code>内容，然后在限制的时间内将修改后的内容调用通过 <code>contentHandler</code> 返还给系统，就可以显示这个修改过的通知了。<br>(本例中在原有 content 之后添加了字符串 “tuneszhao”)。</li><li><code>serviceExtensionTimeWillExpire:</code>：在一定时间内没有调用 <code>contentHandler</code> 的话，系统会调用这个方法。可以选择什么都不做，系统将当作什么都没发生，简单地显示原来的通知。可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用 contentHandler 来显示一个变更“中途”的通知。</li></ul><p><code>Service Extension</code>只对远程推送的通知有效，启用内容修改要在推送<code>payload</code>中设置<code>mutable-content</code>值为1：</p><pre><code class="Java">{  &quot;aps&quot;:{    &quot;alert&quot;:{      &quot;title&quot;:&quot;Greetings&quot;,      &quot;body&quot;:&quot;Long time no see&quot;    },    &quot;mutable-content&quot;:1  }}</code></pre><p>该特性可用于推送内容加密。服务器推送 <code>payload</code> 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密，然后显示。这样可以保证传递内容的安全。</p><h2 id="Media-Attachments"><a href="#Media-Attachments" class="headerlink" title="Media Attachments"></a>Media Attachments</h2><p>iOS 10 的另一个亮眼功能是多媒体的推送，开发者可以在通知中嵌入图片或视频。</p><h3 id="为本地通知添加图片／视频"><a href="#为本地通知添加图片／视频" class="headerlink" title="为本地通知添加图片／视频"></a>为本地通知添加图片／视频</h3><p>通过本地磁盘上的文件 URL 创建一个 <code>UNNotificationAttachment</code> 对象，然后将这个对象放到数组中赋值给 <code>content</code> 的 <code>attachments</code> 属性：</p><pre><code class="Swift">let content = UNMutableNotificationContent()  content.title = &quot;Hey guys&quot;content.body = &quot;What&#39;s going on here?&quot;if let imageURL = Bundle.main.url(forResource: &quot;image&quot;, withExtension: &quot;jpg&quot;),   let attachment = try? UNNotificationAttachment(identifier: &quot;imageAttachment&quot;, url: imageURL, options: nil){    content.attachments = [attachment]}</code></pre><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f7xlo99zmsj30og0dc402.jpg" alt=""></p><h3 id="为远程推送添加多媒体内容"><a href="#为远程推送添加多媒体内容" class="headerlink" title="为远程推送添加多媒体内容"></a>为远程推送添加多媒体内容</h3><p>需要借助上面提到的<code>Notification Service Extension</code>。</p><ul><li><code>payload</code> 中指定需要加载的图片资源地址，这个地址可以是应用 bundle 内已经存在的资源，也可以是网络的资源。</li><li>如果多媒体不在本地的话，需要先将其下载到本地。</li><li>创建 <code>UNNotificationAttachment</code>,之后和本地通知一样，将多媒体资源设置给 <code>attachments</code> 属性，然后调用<code>contentHandler</code>。</li></ul><pre><code class="Java">{  &quot;aps&quot;:{    &quot;alert&quot;:{      &quot;title&quot;:&quot;Image Notification&quot;,      &quot;body&quot;:&quot;Show me an image from web!&quot;    },    &quot;mutable-content&quot;:1  },  &quot;image&quot;: &quot;http://ww2.sinaimg.cn/large/005tGCqhgw1f7xlo99zmsj30og0dc402.jpg&quot;}</code></pre><p>下载图片代码：</p><pre><code class="Swift">private func downloadAndSave(url: URL, handler: @escaping (_ localURL: URL?) -&gt; Void) {    let task = URLSession.shared.dataTask(with: url, completionHandler: {        data, res, error in        var localURL: URL? = nil        if let data = data {            let ext = (url.absoluteString as NSString).pathExtension            let cacheURL = URL(fileURLWithPath: FileManager.default.cachesDirectory)            let url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)            if let _ = try? data.write(to: url) {                localURL = url            }        }        handler(localURL)    })    task.resume()}</code></pre><p><code>didReceive:</code>中接收通知获取图片地址后下载，并创建<code>attachment</code>展示：</p><pre><code class="Swift">if let imageURLString = bestAttemptContent.userInfo[&quot;image&quot;] as? String,   let URL = URL(string: imageURLString){    downloadAndSave(url: URL) { localURL in        if let localURL = localURL {            do {                let attachment = try UNNotificationAttachment(identifier: &quot;image_downloaded&quot;, url: localURL, options: nil)                bestAttemptContent.attachments = [attachment]            } catch {                print(error)            }        }        contentHandler(bestAttemptContent)    }}</code></pre><h1 id="关于适配"><a href="#关于适配" class="headerlink" title="关于适配"></a>关于适配</h1><p>关于通知原来的 API 已被标为弃用。但如果需要支持 iOS 10 之前的系统，还是需要使用原来的 API。若要针对 iOS 10 进行新通知的适配，为应用通知带来更多新特性，可以使用：</p><pre><code class="Swift">if #available(iOS 10.0, *) {    // 使用 UserNotification}</code></pre><h1 id="官方链接及实例代码"><a href="#官方链接及实例代码" class="headerlink" title="官方链接及实例代码"></a>官方链接及实例代码</h1><blockquote><p><a href="https://developer.apple.com/videos/play/wwdc2016/707/" target="_blank" rel="noopener">Introduction to Notifications</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/708/" target="_blank" rel="noopener">Advanced Notifications</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/724/" target="_blank" rel="noopener">What’s New in the Apple Push Notification Service</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 通知 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 10 之 Messages framework</title>
      <link href="/2018/06/13/ios10-messages-framework/"/>
      <url>/2018/06/13/ios10-messages-framework/</url>
      <content type="html"><![CDATA[<p>iMessage App 是一种全新的应用扩展，载体是 iOS 系统的 Message 应用，通过 iMessage App，用户可以发送更加丰富的消息内容，享受更具交互性的会话体验。<br>从 iOS 10 开始，消息扩展（Messages Extension）可以独立于宿主App(Container App) 开发，并提供了全新的消息模式。用户可以通过 Message 发送文本、表情包（sticker）、多媒体文件，以及其他可交互消息。<br><a id="more"></a></p><h1 id="Messages-App-Store"><a href="#Messages-App-Store" class="headerlink" title="Messages App Store"></a>Messages App Store</h1><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80b81p95wj309y024jrb.jpg" alt=""><br>Messages App Store 独立于之前的 App Store，只存在于系统的 Message 中，这里只显示 <strong>iMessage-related 应用</strong>。它可以干什么呢？</p><ul><li>显示iMessage App;</li><li>为未安装应用的用户提供安装途径(Inline App Attribution);</li><li>提供iap，Apple Pay和访问相机功能。<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80bdctvjej30ku112wkv.jpg" alt=""></li></ul><p>iMessage App 可以独立开发（iOS 10之后），也可以作为 Extension 添加在现有项目中。</p><ul><li>在现有项目中添加：File-&gt;New-&gt;Target-&gt;Application Extension-&gt;Sticker Pack Extension/iMessage Extension</li><li>独立开发：File-&gt;New-&gt;Project-&gt;Application-&gt;Sticker Pack Application/iMessage Application</li></ul><h1 id="基本表情包-Sticker-Packs"><a href="#基本表情包-Sticker-Packs" class="headerlink" title="基本表情包 (Sticker Packs)"></a>基本表情包 (Sticker Packs)</h1><p>Sticker 是 iOS 10 iMessage 引入的一种新的交互方式，可以当做消息发送，也可以附加在已有消息上。创建表情包不需要任何代码。图片文件需满足以下条件：</p><ul><li>图片格式：PNG, APNG, GIF, JPEG;</li><li>文件大小：小于 500 KB;</li><li>图片大小区间：[100 x 100,206 x 206]</li></ul><p>只需提供最大像素图片(@3x,[300 x 300,618 x 618])，系统会在需要的时候自动完成缩放。</p><p>苹果建议的表情文件大小：</p><ul><li>Small: 100 x 100 pt @3x scale (300 x 300 pixel image)</li><li>Medium: 136 x 136 pt @3x scale (378 x 378 pixel image)</li><li>Large: 206 x 206 pt @3x scale (618 x 618 pixel image)</li></ul><p>打开 Xcode，创建新工程 BasicStickerPack：<em>File-&gt;New-&gt;Project-&gt;Application-&gt;Sticker Pack Application</em>。<br>左边侧栏有个<code>Stickers.xcstickers</code>，包含了iMessage APP的icon 和表情，添加一组图片。如果要更改表情包默认名称和大小，可在右侧Attributes inspector 中更改。<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f80c1a8yuuj31kw085mzu.jpg" alt=""><br>运行，表情包将在 Message 的 Message App Store 打开，点击任何一个表情即可添加到当前信息并发送：<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80cwi8ozbj30ku112422.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80cdyjxegj30ku112dhr.jpg" alt=""></p><h1 id="自定义表情包"><a href="#自定义表情包" class="headerlink" title="自定义表情包"></a>自定义表情包</h1><p>基本的表情应用程序提供的模板可能不完全满足需求，我们创建一个较复杂的表情包应用程序 CustomStickerPack，选择 iMessage Application 模版。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80d9jz8moj30ek0ik40n.jpg" alt=""><br>创建好的工程相比上面的 Sticker Pack Application 多了 MessagesExtension 文件夹。该文件夹包含四个部分：</p><ul><li>MessagesViewController.swift : iMessage app的程序入口;</li><li>MainInterface.storyboard: 可视化操作;</li><li>Assets.xcassets: 图片集合;</li><li>Info.plist : 配置一些扩展信息;</li></ul><p><code>MessagesViewController</code>是 <code>MSMessagesAppViewController</code> 的子类，它是用来展示消息扩展(Message Extension)的界面。自定义 Sticker 需要自定义<code>MSStickerBrowserViewController</code>。<code>MSStickerBrowserViewController</code>是用来显示 Sticker 的，它有两个协议方法需要实现：</p><pre><code class="Objective-C">@protocol MSStickerBrowserViewDataSource &lt;NSObject&gt;- (NSInteger)numberOfStickersInStickerBrowserView:(MSStickerBrowserView *)stickerBrowserView;//返回Sticker数量- (MSSticker *)stickerBrowserView:(MSStickerBrowserView *)stickerBrowserView stickerAtIndex:(NSInteger)index;//返回MSSticker对象</code></pre><p><code>MSStickerBrowserViewController</code>用法跟<code>UITableViewDataSource</code>很像，有一个<code>stickerBrowserView</code>对象：</p><pre><code class="Objective-C">@property (nonatomic, strong, readonly) MSStickerBrowserView *stickerBrowserView;</code></pre><p>刷新数据，调用：</p><pre><code class="Objective-C">[stickerBrowserView reloadData];</code></pre><p>一张图说明一下上述几个对象的关系：<br><img src="http://upload-images.jianshu.io/upload_images/1415843-cc9571b08a155105.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""><br>将 sticker 放入 MessagesExtension 文件夹，创建一个 <code>MSSticker</code> 数组存储表情包，并写一个加载表情包的方法：</p><pre><code class="swift">var stickers = [MSSticker]()func loadStickers() {    for i in 1...2 {        if let url = Bundle.main.url(forResource: &quot;Sticker \(i)&quot;, withExtension: &quot;png&quot;){            do {                let sticker = try MSSticker(contentsOfFileURL: url, localizedDescription: &quot;&quot;)                stickers.append(sticker)            } catch {                print(error)            }        }    }}</code></pre><p>实现<code>createStickerBrowser</code>方法, 初始化<code>MSStickerBrowserViewController</code>作为根视图, 并设置宽高约束:</p><pre><code class="swift">func createStickerBrowser() {    let controller = MSStickerBrowserViewController(stickerSize: .large)    addChildViewController(controller)    view.addSubview(controller.view)    controller.stickerBrowserView.backgroundColor = UIColor.blue    controller.stickerBrowserView.dataSource = self    view.topAnchor.constraint(equalTo: controller.view.topAnchor).isActive = true    view.bottomAnchor.constraint(equalTo: controller.view.bottomAnchor).isActive = true    view.leftAnchor.constraint(equalTo: controller.view.leftAnchor).isActive = true    view.rightAnchor.constraint(equalTo: controller.view.rightAnchor).isActive = true}</code></pre><p>实现<code>MSStickerBrowserViewDataSource</code>的代理方法：</p><pre><code class="swift">func numberOfStickers(in stickerBrowserView: MSStickerBrowserView) -&gt; Int {    return stickers.count}func stickerBrowserView(_ stickerBrowserView: MSStickerBrowserView, stickerAt index: Int) -&gt; MSSticker {    return stickers[index]}</code></pre><p><code>viewDidLoad</code> 中加载 sticker 、创建 MSStickerBrowserViewController：</p><pre><code class="swift">override func viewDidLoad() {    super.viewDidLoad()    loadStickers()    createStickerBrowser()}</code></pre><p>运行，跟上一个表情包差不多，但背景换成了自定义的颜色。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80dm1uafej30ku112q69.jpg" alt=""></p><h1 id="自定义-APP"><a href="#自定义-APP" class="headerlink" title="自定义 APP"></a>自定义 APP</h1><p>本例将利用 iMessage App 创建一个独特的可交互消息。<br>创建 iMessage Application <code>MessageApp</code>，在<code>MainInterface.storyboard</code>添加一个 stepper 和 button：<br><img src="http://upload-images.jianshu.io/upload_images/326255-0dce497fdcdbe7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>选择 stepper 打开 Attributes inspector, 改变最小最大值为0和10:<br><img src="http://upload-images.jianshu.io/upload_images/326255-bf8a7f349311fcb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>介绍几个关键对象：</p><h2 id="MSConversation"><a href="#MSConversation" class="headerlink" title="MSConversation"></a>MSConversation</h2><p>指当前打开的会话，可以通过 MSConversation 插入消息。<br>在<code>MSMessagesAppViewController</code>中可以通过成员变量<code>activeConversatio</code>n获取当前的<code>MSConversation</code>，随后可调用以下方法插入不同的消息：</p><pre><code class="swift">// 添加交互型消息.open func insert(_ message: MSMessage, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加 sticker.open func insert(_ sticker: MSSticker, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加文本.open func insertText(_ text: String, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加多媒体（音视频）.open func insertAttachment(_ URL: URL, withAlternateFilename filename: String?, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1415843-bb2627708998cfe4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><h2 id="MSMessage"><a href="#MSMessage" class="headerlink" title="MSMessage"></a>MSMessage</h2><p>代表单个消息体，包含两个部分：</p><ul><li><code>MSSession</code>：用来描述消息如何发送;</li><li><code>MSMessageLayout</code>：用来描述消息如何展示。<br>在 iMessage 中自定义 MSMessage 必须要设置两个属性：<code>layout</code> 和 <code>url</code>。 url 是链接某个 web 页面的一些内容, 这样 MacOS 用户可以看到 iMessage 的内容。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1415843-8f7716fc63e26aea.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><p><code>MSMessageLayout</code>是一个抽象类，目前系统只提供了一种展现方法<code>MSMessageTemplateLayout</code>，里边有许多属性和空间用来自定义message;：<br><img src="https://docs-assets.developer.apple.com/published/af521ba258/MSMessageTemplateLayout_2x_93d9e9b7-b99c-4def-a8e1-2df50a710a52.png" alt=""><br> 左上角的空间是展示icon， 所有的属性都是可选的，提供任何标题字符串将摆脱底部部分的布局。<br>添加<code>createImageForMessage()</code>方法，将当前的stepper的数值显示到圆形的label中, 然后将label放在UIImage对象中。</p><pre><code class="swift">func createImageForMessage() -&gt; UIImage? {    let background = UIView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))    background.backgroundColor = UIColor.white    let label = UILabel(frame: CGRect(x: 75, y: 75, width: 150, height: 150))    label.font = UIFont.systemFont(ofSize: 56.0)    label.backgroundColor = UIColor.red    label.textColor = UIColor.white    label.text = &quot;\(Int(stepper.value))&quot;    label.textAlignment = .center    label.layer.cornerRadius = label.frame.size.width/2.0    label.clipsToBounds = true    background.addSubview(label)    background.frame.origin = CGPoint(x: view.frame.size.width, y: view.frame.size.height)    view.addSubview(background)    UIGraphicsBeginImageContextWithOptions(background.frame.size, false, UIScreen.main.scale)    background.drawHierarchy(in: background.bounds, afterScreenUpdates: true)    let image = UIGraphicsGetImageFromCurrentImageContext()    UIGraphicsEndImageContext()    background.removeFromSuperview()    return image}</code></pre><p>设置 button 点击方法<code>didPress</code>，该方法中先创建message的布局, 并且设置 image 和 caption, 接着创建 MSMessage 对象并插入到会话中：</p><pre><code class="swift">@IBAction func didPress(button sender: AnyObject) {    if let image = createImageForMessage(), let conversation = activeConversation {        let layout = MSMessageTemplateLayout()        layout.image = image        layout.caption = &quot;Stepper Value&quot;        let message = MSMessage()        message.layout = layout        message.url = URL(string: &quot;emptyURL&quot;)        conversation.insert(message, completionHandler: { (error) in            print(error)        })    }}</code></pre><p>在这个例子中, 我们只是创建了简单的字符 url，如果用户点击该消息并且 url 是 http(s) 类型的，系统会通过浏览器打开相应的页面。<br>运行 App：<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f80fc9xq3ej30ku112td8.jpg" alt=""><br>点击 button 发送消息：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80fcp6fl0j30ku112q57.jpg" alt=""><br>stepper+2：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80fd9slruj30ku112mzf.jpg" alt=""></p><h1 id="iMessage-App-LifeCycle"><a href="#iMessage-App-LifeCycle" class="headerlink" title="iMessage App LifeCycle"></a>iMessage App LifeCycle</h1><p>看下 iMessage App 的生命周期。</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><pre><code class="objc">// Message Extension启动。- (void)didBecomeActiveWithConversation:(MSConversation *)conversation;- (void)viewWillAppear:(BOOL)animated;- (void)viewDidAppear:(BOOL)animated;</code></pre><h2 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h2><pre><code class="objc">- (void)viewWillDisappear:(BOOL)animated;- (void)viewDidDisappear:(BOOL)animated;- (void)willResignActiveWithConversation:(MSConversation *)conversation;// Message Extension被系统销毁。</code></pre><h2 id="唤起过程"><a href="#唤起过程" class="headerlink" title="唤起过程"></a>唤起过程</h2><pre><code class="objc">-(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;-(void)didTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;</code></pre><p>上面列出的回调方法均出现在<code>MSMessagesAppViewController</code>中，因此，iMessage App 的生命周期就是<code>MSMessagesAppViewController</code>的生命周期。</p><blockquote><p><a href="https://developer.apple.com/reference/messages" target="_blank" rel="noopener">官方文档 Messages Framework Reference</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/204/" target="_blank" rel="noopener">WWDC Session1</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/224/" target="_blank" rel="noopener">WWDC Session2</a><br><a href="https://developer.apple.com/library/prerelease/content/samplecode/IceCreamBuilder/Introduction/Intro.html" target="_blank" rel="noopener">官方 demo</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Messages </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 程序证书及签名机制</title>
      <link href="/2018/06/13/iosapp-certificate-signature/"/>
      <url>/2018/06/13/iosapp-certificate-signature/</url>
      <content type="html"><![CDATA[<p>最近在研究除了 Apple 官方途径，iPhone手机上安装应用的其他途径。顺便总结下 iOS 开发中涉及的一套证书及签名机制。<br><a id="more"></a></p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是非对称加密和摘要算法的结合。防止中途篡改文本内容，保证文本的完整性，以及文本是由指定的权限者发的。<br>发布方加密过程:<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9n5536maxj307k0gwjru.jpg" alt=""><br>接收方验证过程：<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9n560603pj30hw0ja407.jpg" alt=""></p><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>数字证书就是通过数字签名实现的数字化的证书。简单讲数字证书包含以下信息:</p><ul><li>签发机构：CA（苹果公司）</li><li>被签发人：企业 / 开发者</li><li>验证方：iOS 设备</li><li>验证过程：固化在 iOS 系统中</li><li>证书链：根是苹果的CA</li></ul><h1 id="iOS-开发：证书申请、签名打包"><a href="#iOS-开发：证书申请、签名打包" class="headerlink" title="iOS 开发：证书申请、签名打包"></a>iOS 开发：证书申请、签名打包</h1><p><img src="http://pchou.qiniudn.com/iOS%E8%AF%81%E4%B9%A6%E5%92%8C%E6%A0%A1%E9%AA%8C.png" alt=""><br>这张图阐述了，开发iOS应用程序时，从申请证书，到打包的大致过程。简单总结如下：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9nxlzvnsvj31kw0g678v.jpg" alt=""><br><strong>数字证书的作用：</strong><br>证明app的所属以及app的完整性，保证app本身是安全的。</p><h1 id="iOS授权和描述文件"><a href="#iOS授权和描述文件" class="headerlink" title="iOS授权和描述文件"></a>iOS授权和描述文件</h1><p><code>mobileprovision</code>是为了证明 app 所使用的某些服务是被苹果认可的，如 Push 证书。<br><code>mobileprovision</code>包含：</p><ul><li>AppId。</li><li>使用哪些证书。</li><li>功能授权列表。</li><li>可安装的设备列表（UDID）。</li><li>苹果签名。</li></ul><h1 id="ipa文件"><a href="#ipa文件" class="headerlink" title=".ipa文件"></a>.ipa文件</h1><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9nzfmyp6uj30n204imxu.jpg" alt=""><br><code>.iTunesMetadata.plist</code>文件用来记录app的基本信息，例如购买者的appleID，app购买时间、app支持的设备体系结构，app的版本、app标识符等。<br>解压/payload中的.app文件可看到.ipa主要的文件结构：<br><img src="http://pchou.qiniudn.com/ipa%E7%BB%84%E6%88%90.png" alt=""></p><ul><li>_CodeSignature/CodeResources：程序包中（除 Frameworks）所有文件的签名。</li><li>embedded.mobileprovision：打包时使用。</li><li>SC_Info(图中未列出)：包含两个文件<ol><li>appname.sinf 为 metadata 文件</li><li>appname.supp 为解密可执行文件的密钥</li></ol></li></ul><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9nzic64qtj30w80i6tb7.jpg" alt=""><br>Xcode 打包生成 ipa 文件过程中利用当前证书私钥进行代码、资源文件的数字签名，将其存放在_CodeSignature文件夹下。</p><h1 id="关于-iTunes-授权"><a href="#关于-iTunes-授权" class="headerlink" title="关于 iTunes 授权"></a>关于 iTunes 授权</h1><p>每个 Apple ID 最多授权5台电脑（用来登录iTunes下载app和管理同步手机）。5的限制是通过扫描硬盘序列号来确认。<br>iTunes 授权时，需要连接 Apple 服务器进行验证，通过验证后，会将授权信息以加密文件的形式，存放在<a href="https://discussions.apple.com/thread/1715932?tstart=0" target="_blank" rel="noopener">SC_Info</a>文件夹。这些文件是隐藏的，可通过<a href="http://www.bresink.com/osx/TinkerTool.html" target="_blank" rel="noopener">TinkerTool</a>查看。<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9o6jx1dq8j30j402oab9.jpg" alt=""><br>iTunes 授权后，即可登录 Apple ID 并将该账号下购买过的应用同步到 iPhone 中。XX 助手工具便通过“欺骗授权”的方式，为每个用户修改或虚拟出一个相同的硬盘序列号，接着，“这台电脑”取得一个公共 id 的授权，然后把公共id买过的 app 装到某 iOS 设备中。达到一个账号给多台设备（5台以上）共享使用的目的。</p><h1 id="账号共享分发"><a href="#账号共享分发" class="headerlink" title="账号共享分发"></a>账号共享分发</h1><p><a href="http://www.pc6.com/edu/53793.html" target="_blank" rel="noopener">这篇文章</a>讲到在 windows 平台下使用账号共享分发app的方法。简单总结如下：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f9o8njxtpoj312a0acdhu.jpg" alt=""><br>同步授权后可以使用iTunes，也可以使用itools安装分享者另外发布出来的所有应用。</p><h1 id="ipa-文件安装后的校验过程"><a href="#ipa-文件安装后的校验过程" class="headerlink" title="ipa 文件安装后的校验过程"></a>ipa 文件安装后的校验过程</h1><p>App安装到ios系统上时，系统首先通过描述文件找到数字证书，通过证书里的苹果数字签名，验证证书的有效性。如果证书有效，取出证书中的开发者公钥，解密App的数字签名。如果发现摘要一致，则验证通过，App成功安装在手机上，其中一个环节有问题，验证工作就失败。</p><blockquote><p><a href="http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html" target="_blank" rel="noopener">漫谈iOS程序的证书和签名机制</a><br><a href="http://e-intuit.hk/kuaiyong-piracy.html" target="_blank" rel="noopener">iTools第三方市场分发原理</a><br><a href="https://objccn.io/issue-17-2/" target="_blank" rel="noopener">代码签名探析</a><br><a href="https://xiuchundao.me/post/code-resources-and-embedded-mobileprovision-included-in-ipa-file" target="_blank" rel="noopener">签过名的ipa文件</a><br><a href="http://www.pc6.com/edu/53793.html" target="_blank" rel="noopener">多个授权文件共存的正确方法</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TableView 动态 cell 高度自适应方案</title>
      <link href="/2018/06/13/dynamic-height-cell/"/>
      <url>/2018/06/13/dynamic-height-cell/</url>
      <content type="html"><![CDATA[<p>相比安卓 ListView/RecylerView，iOS 中 TableViewCell 高度自适应是需要开发者自己想办法解决的，原因在于 tableview 的渲染机制默认是先获取 cell 高度，然后再去绘制 cell 体。由于 label/textview 等通常是高度不定的，cell 高度动态化是个很常见的需求。<br><a id="more"></a></p><h1 id="方案一：高度固定"><a href="#方案一：高度固定" class="headerlink" title="方案一：高度固定"></a>方案一：高度固定</h1><p>针对所有 Cell 具有固定高度的情况：</p><ol><li><code>self.tableView.rowHeight = 88;</code></li><li>实现协议方法 <code>heightForRowAtIndexPath:</code>。</li></ol><p><strong>缺点：</strong>不支持动态高度。</p><h1 id="方案二：cell-预估高度（iOS-7-）"><a href="#方案二：cell-预估高度（iOS-7-）" class="headerlink" title="方案二：cell 预估高度（iOS 7+）"></a>方案二：cell 预估高度（iOS 7+）</h1><p><strong>设计思路：</strong><br>加载 tableview 时一次性计算所有 cell 高度太耗性能。所以把计算 height 的任务从 load time 转移到 scrolling time。只有滑动到的 cell 会计算，屏幕外边的不会计算。<br>方法：<code>tableView: estimatedHeightForRowAtIndexPath:</code><br>这是 iOS 7.0 出现的 UITableViewDelegate 中的方法,表示返回某行 cell 的预估高度。这个方法改变了 TableView 代理方法的调用顺序。<br>未调用<code>estimatedHeightForRow...</code>方法时：<br><img src="http://seuzl.qiniudn.com/md/1528946585725.png" alt=""><br>调用<code>estimatedHeightForRow...</code>后：<br><img src="http://seuzl.qiniudn.com/md/1528946602952.png" alt=""><br>此时 tableView 工作原理：</p><ol><li>tableView 先向代理拿得到每个 cell 的预估高度(<code>estimatedHeightForRow...</code>方法)，并且拿这个高度去计算整个 tableView 应该显示的范围。</li><li>根据每行预估的高度，算出一屏显示的 cell 的个数，并先对这些 cell(调用<code>cellForRow...</code>方法)进行绘制。</li><li>绘制时拿到 cell 的真实高度,然后放在<code>heightForRow...</code>方法里面拿给 tabelView 去用。</li><li>屏幕滚动(有 cell 进入屏幕)的时候,仍然会调用绘制以及获取真实高度的方法。</li></ol><p>简单点说，预估高度用来让 tableView 心里有个底，把 cell 先绘制出来，但最后实际的 cell 高度还是会从<code>heightForRow...</code>方法中获取。</p><p><strong>缺点：</strong></p><ol><li>设置估算高度后，<code>tableview.contentSize.height</code>根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</li><li>估算高度使加载速度更快，但侵害滑动流畅性，cell较多情况下滑动时实时计算高度带来的卡顿是明显能体验到的。</li></ol><h1 id="方案三：self-sizing-cell-（iOS-8-）"><a href="#方案三：self-sizing-cell-（iOS-8-）" class="headerlink" title="方案三：self-sizing cell （iOS 8+）"></a>方案三：self-sizing cell （iOS 8+）</h1><p><strong>设计思路：</strong><br>如图，row123 是已经在屏幕上被展示的cell, 而 row4 是下一个会被展示的cell, 这时 row4 这个 cell 的 rowHeight 是预先为其设置的 estimated height， 又或者是  UITableViewDelegate 中返回的 height。<br>当用户滚动的时候，首先 cell 会被创建或重用，然后 cell 会被调用调整 size 的方法， 接着 cell 会根据 tableView 的size去调整自身的 contentSize，最后cell被展示出来。<br><img src="http://ww2.sinaimg.cn/mw690/005tGCqhjw1f9fwywhi35j308p07zq31.jpg" alt=""><br>如何让一个cell去调整自己的高度？</p><ol><li>cell 要使用 Autolayout 布局；</li><li>在 tableView 中启动动态布局, 告诉 tableView 用新的方法来布局行高.而不是 rowHeight 或者 delegate 方法。<br><code>tableView.rowHeight = UITableViewAutomaticDimension;</code></li></ol><p><strong>缺点：</strong></p><ol><li>仅支持iOS 8+；</li><li>高度没有缓存。iOS 7 计算高度后有”缓存“机制，不会重复计算；iOS 8 不论何时都会重新计算 cell 高度。</li></ol><h1 id="方案四：FDTemplateLayoutCell（iOS-6-）"><a href="#方案四：FDTemplateLayoutCell（iOS-6-）" class="headerlink" title="方案四：FDTemplateLayoutCell（iOS 6+）"></a>方案四：FDTemplateLayoutCell（iOS 6+）</h1><p>好处：既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。</p><ol><li>根据 autolayout 约束自动计算高度。使用了系统在 iOS6 提供的 API：<code>-systemLayoutSizeFittingSize:</code></li><li>根据 indexPath 的一套高度缓存机制。<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了多余计算。</li><li>自动的缓存失效机制。<br>UITableView 刷新时，已有的高度缓存将以最小的代价失效。如删除一个 indexPath 为 [0:5] 的 cell，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li><li>预缓存机制（通过 runloop 实现）。<br>UITableView 没有滑动的空闲时刻会计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性。</li></ol><p><strong>缺点：</strong><br>要求约束设置完整准确，保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。（这个实际上是<code>systemLayoutSizeFittingSize:</code>的要求）。</p><p>从易用性、性能、高度自适应效果、适配 iOS 最低版本综合来看，方案四是最佳的。但需要引入第三方库，同时要保证 autolayout 约束完整准确才行，关于这点<a href="https://www.jianshu.com/p/386b792054b1" target="_blank" rel="noopener">《UITableViewCell高度自适应的关键点》</a>总结得很好：</p><blockquote><p>Cell 内部的 Constraints 一定要有一条从 Cell 顶部到底部的一条可联通线。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为 ViewControllers 瘦身</title>
      <link href="/2018/05/30/light-viewcontrollers/"/>
      <url>/2018/05/30/light-viewcontrollers/</url>
      <content type="html"><![CDATA[<p>目标：写可维护的代码。<br><a id="more"></a></p><h2 id="把-TableView-从-VC-中抽离"><a href="#把-TableView-从-VC-中抽离" class="headerlink" title="把 TableView 从 VC 中抽离"></a>把 TableView 从 VC 中抽离</h2><p>UITableView 可以说是 iOS 界面开发中用的最广泛的组件，就我自己做过的项目而言，绝大部份 ViewController 都是在围绕 UITableViewDelegate 和 UITableViewDataSource 中的方法打交道。但说到底这些函数都是 View 层面的，全部在 VC 中处理显得不太合适，也不利于日后的维护和扩展，所以关于瘦身 VC 很容易想到一点是从 VC 中抽离 tableView 的表示逻辑。这种思想其实与最近火热的<a href="http://www.cnblogs.com/ludashi/p/4211556.html" target="_blank" rel="noopener">MVVM</a>设计模式相通。核心是<strong>把逻辑代码尽量移到 model 层</strong>, 你可以认为它是一个中间层 , 逻辑代码可以是各种 delegate,网络请求,缓存,数据库,coredata 等, 而 controller 正是用来组织串联他们，使得整个程序走通。</p><h3 id="把-Data-Source-分离出来"><a href="#把-Data-Source-分离出来" class="headerlink" title="把 Data Source 分离出来"></a>把 Data Source 分离出来</h3><p>举例:当需要将一个数组映射到一个 tableView 进行显示，这种一一对应关系可以单独写一个类<code>ArrayDataSource</code>，使用 block 或者 delegate 设置 cell。ArrayDataSource 类完全可以复用到任何需要将一个数组的内容映射到一个 tableView 的场景。<br>ArrayDataSource 中声明 <code>block(cell,item)</code> 来初始化 cell，block实现方式（item 和 cell 如何对应）则可以在 cell+Configure 的 category 中声明。<br>使用<code>ArrayDataSource</code>，在<code>ViewController</code>中执行<code>setUpTableView</code>即可。<code>setUpTableView</code>中实现 block（可以是执行 configure 方法的方式）。使用 cell 类 category 的方式是为了避免向 dataSource 暴露 cell 的设计,说白了是为了更好得分离 view 和 model 层。</p><blockquote><p><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank" rel="noopener">1.1 参考项目看这里</a></p></blockquote><h3 id="把-Data-Source-和-Delegate-都分离出来"><a href="#把-Data-Source-和-Delegate-都分离出来" class="headerlink" title="把 Data Source 和 Delegate 都分离出来"></a>把 Data Source 和 Delegate 都分离出来</h3><p>1.1中的方法是在<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a>一文中提到的。但该文讲的只是把<code>UITableViewDataSource</code>中的方法提取到一个单独的类，从结果来看，是把<code>numberOfRowsInSection</code>和<code>cellForRowAtIndexPath</code>从 VC 中提取出去。但实际上<code>UITableViewDelegate</code>也是可以抽象出去的。例如 cell 的生成, cell 行高, 点击事件等等。这里用 block 实现回调。<br>处理类<code>TableViewDataSourceDelegate.h</code></p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void    (^TableViewCellConfigureBlock)(NSIndexPath *indexPath, id item, XTRootCustomCell *cell) ;typedef CGFloat (^CellHeightBlock)(NSIndexPath *indexPath, id item) ;typedef void    (^DidSelectCellBlock)(NSIndexPath *indexPath, id item) ;@interface TableViewDataSourceDelegate : NSObject &lt;UITableViewDelegate,UITableViewDataSource&gt;//初始化方法: 传数据源, cellIdentifier, 三个block分别对应配置, 行高, 点击。- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock ;//将UITableViewDataSource和UITableViewDelegate设于TableViewDataSourceDelegate。- (void)handleTableViewDatasourceAndDelegate:(UITableView *)table ;//默认indexPath.row对应每个dataSource相应返回item。- (id)itemAtIndexPath:(NSIndexPath *)indexPath ;@end</code></pre><p>在 1.1 中为了避免 model 和 view 的耦合，将 cell 的配置用 category 方法处理。但使用的方式是每一个<code>UITableViewCell</code>都做了扩展，实际上可以做得更彻底 ——直接对这些子类的父类<code>UITableViewCell</code>进行扩展。这样做的好处是比 1.1 的扩展方法更加灵活，可以提供多个 configure 方法，针对不同类型的 model 进行数据展示，同时也增强 cell 的移植性。<br>为 UITableViewCell 提供扩展<code>UITableViewCell+Extension.h</code></p><pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;@interface UITableViewCell (Extension)//实际是tableView reigister nib，由于是与cell(view)紧密相关的方法，故在cell本身进行实现，而非在vc中。+(void) registerTable:(UITableView*)table        nibIdentifier:(NSString*)identifier;//根据数据源配置并绘制cell 子类需重写该方法-(void)configure:(UITableViewCell*)cell       customObj:(id)obj       indexPath:(NSIndexPath*)indexPath;//根据数据源计算cell的高度 子类可重写该方法, 若不写为默认值44.0+(CGFloat)getCellHeightWithCustomObj:(id)obj                        indexPath:(NSIndexPath*)indexPath;@end</code></pre><p>如此，对于每一个 cell 子类，实现两个新方法:</p><pre><code class="objc">- (void)configure:(UITableViewCell *)cell        customObj:(id)obj        indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}+ (CGFloat)getCellHeightWithCustomObj:(id)obj                            indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}</code></pre><p>OK,做了这么多工作，返回 VC 看一下最后的成果吧！瘦身后的 viewController 对于 tableView 的所有处理都只需要一个方法<code>setUpTableView</code></p><pre><code class="objc">- (void)setupTableView{    TableViewCellConfigureBlock configureCell = ^(NSIndexPath *indexPath, MyObj *obj, XTRootCustomCell *cell) {        [cell configure:cell customObj:obj indexPath:indexPath] ;    } ;    CellHeightBlock heightBlock = ^CGFloat(NSIndexPath *indexPath, id item) {        return [MyCell getCellHeightWithCustomObj:item indexPath:indexPath] ;    } ;    DidSelectCellBlock selectedBlock = ^(NSIndexPath *indexPath, id item) {        NSLog(@&quot;click row : %@&quot;,@(indexPath.row)) ;    } ;    self.tableHandler = [[TableDataDelegate alloc] initWithItems:self.list                                                   cellIdentifier:MyCellIdentifier                                               configureCellBlock:configureCell                                                  cellHeightBlock:heightBlock                                                   didSelectBlock:selectedBlock] ;    [self.tableHander handleTableViewDatasourceAndDelegate:self.table] ;}</code></pre><blockquote><p>1.2 <a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">参考项目看这里</a></p></blockquote><h3 id="抽离-TableView-终极版"><a href="#抽离-TableView-终极版" class="headerlink" title="抽离 TableView 终极版"></a>抽离 TableView 终极版</h3><p>经过 1.2 的处理，<code>UITableViewDelegate</code> 和 <code>UITableViewDataSource</code> 的方法都已经移到<code>TableViewDataSourceDelegate</code>这个类中处理，但根据<br><a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">1.2参考项目</a>可以发现1.2的处理方式有局限性，我们观察<code>TableViewDataSourceDelegate</code>中的核心方法:</p><pre><code class="objc">- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock;</code></pre><p><code>TableViewDataSourceDelegate</code>进行初始化时需传递参数<code>CellIdentifier</code>和<code>aHeightBlock</code>,实际开发工作中这两者通常是和<code>UITableViewCell</code>类紧密相关的。一类 <code>UITableViewCell</code>往往对应一个它自己的 <code>CellIdentifier</code> 和 <code>cellHeight</code>，如果初始化<code>TableViewDataSourceDelegate</code>对象时就指定这两个属性，则<code>TableViewDataSourceDelegate</code>仅局限于被一种 tableView 复用:cell种类都相同，也就是用一个tableView展示一个数组( indexPath.row 对应数组下标)。如图：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezscp180r2j30af0hz755.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005tGCqhjw1ezscrw6qbyj30ah0icgnm.jpg" alt=""><br>这些 cell 都是同一种类，但实际开发中往往面临着更复杂的 cell 样式，如我在开发<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">校友圈</a>时：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezsd219avzj30ag0ikaau.jpg" alt=""><br>这种情况怎么使用<code>TableViewDataSourceDelegate</code>呢？修改<code>TableViewDataSourceDelegate</code>的 init 方法：</p><pre><code class="objc">(id)initWithItems:(NSDictionary *)anItemsconfigureCellBlock:(TableViewCellConfigureCellBlock)aConfigureCellBlock   cellHeightBlock:(CellHeightBlock)aHeightBlock    didSelectBlock:(DidSelectCellBlock)aDidSelectBlock;</code></pre><h2 id="业务逻辑移到-model-中"><a href="#业务逻辑移到-model-中" class="headerlink" title="业务逻辑移到 model 中"></a>业务逻辑移到 model 中</h2><p>尽管 viewController 最主要功能是处理业务逻辑，但对于一些和 model 联系紧密，和 view 关系不大（即不是 model 和 view 进行交互的逻辑）的代码应移到 model 中，通常是用 category 的处理方法，更加清晰。</p><h2 id="网络请求逻辑移到-model"><a href="#网络请求逻辑移到-model" class="headerlink" title="网络请求逻辑移到 model"></a>网络请求逻辑移到 model</h2><p>用 category 方式处理。viewController 使用 block 回调请求网络。</p><h2 id="view-代码移到-view-层"><a href="#view-代码移到-view-层" class="headerlink" title="view 代码移到 view 层"></a>view 代码移到 view 层</h2><p>不要在 viewController 中构建复杂的 view 层次结构。<br>要注意的是，IB 并非只能和 viewControllers 一起使用，可以加载单独的 nib 文件到自定义的 view 中。</p><blockquote><p>参考：<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
