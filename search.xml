<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>为 ViewControllers 瘦身</title>
      <link href="/2018/05/30/light-viewcontrollers/"/>
      <url>/2018/05/30/light-viewcontrollers/</url>
      <content type="html"><![CDATA[<p>目标：写可维护的代码。<br><a id="more"></a></p><h2 id="把-TableView-从-VC-中抽离"><a href="#把-TableView-从-VC-中抽离" class="headerlink" title="把 TableView 从 VC 中抽离"></a>把 TableView 从 VC 中抽离</h2><p>UITableView 可以说是 iOS 界面开发中用的最广泛的组件，就我自己做过的项目而言，绝大部份 ViewController 都是在围绕 UITableViewDelegate 和 UITableViewDataSource 中的方法打交道。但说到底这些函数都是 View 层面的，全部在 VC 中处理显得不太合适，也不利于日后的维护和扩展，所以关于瘦身 VC 很容易想到一点是从 VC 中抽离 tableView 的表示逻辑。这种思想其实与最近火热的<a href="http://www.cnblogs.com/ludashi/p/4211556.html" target="_blank" rel="noopener">MVVM</a>设计模式相通。核心是<strong>把逻辑代码尽量移到 model 层</strong>, 你可以认为它是一个中间层 , 逻辑代码可以是各种 delegate,网络请求,缓存,数据库,coredata 等, 而 controller 正是用来组织串联他们，使得整个程序走通。</p><h3 id="把-Data-Source-分离出来"><a href="#把-Data-Source-分离出来" class="headerlink" title="把 Data Source 分离出来"></a>把 Data Source 分离出来</h3><p>举例:当需要将一个数组映射到一个 tableView 进行显示，这种一一对应关系可以单独写一个类<code>ArrayDataSource</code>，使用 block 或者 delegate 设置 cell。ArrayDataSource 类完全可以复用到任何需要将一个数组的内容映射到一个 tableView 的场景。<br>ArrayDataSource 中声明 <code>block(cell,item)</code> 来初始化 cell，block实现方式（item 和 cell 如何对应）则可以在 cell+Configure 的 category 中声明。<br>使用<code>ArrayDataSource</code>，在<code>ViewController</code>中执行<code>setUpTableView</code>即可。<code>setUpTableView</code>中实现 block（可以是执行 configure 方法的方式）。使用 cell 类 category 的方式是为了避免向 dataSource 暴露 cell 的设计,说白了是为了更好得分离 view 和 model 层。</p><blockquote><p><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank" rel="noopener">1.1 参考项目看这里</a></p></blockquote><h3 id="把-Data-Source-和-Delegate-都分离出来"><a href="#把-Data-Source-和-Delegate-都分离出来" class="headerlink" title="把 Data Source 和 Delegate 都分离出来"></a>把 Data Source 和 Delegate 都分离出来</h3><p>1.1中的方法是在<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a>一文中提到的。但该文讲的只是把<code>UITableViewDataSource</code>中的方法提取到一个单独的类，从结果来看，是把<code>numberOfRowsInSection</code>和<code>cellForRowAtIndexPath</code>从 VC 中提取出去。但实际上<code>UITableViewDelegate</code>也是可以抽象出去的。例如 cell 的生成, cell 行高, 点击事件等等。这里用 block 实现回调。<br>处理类<code>TableViewDataSourceDelegate.h</code></p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void    (^TableViewCellConfigureBlock)(NSIndexPath *indexPath, id item, XTRootCustomCell *cell) ;typedef CGFloat (^CellHeightBlock)(NSIndexPath *indexPath, id item) ;typedef void    (^DidSelectCellBlock)(NSIndexPath *indexPath, id item) ;@interface TableViewDataSourceDelegate : NSObject &lt;UITableViewDelegate,UITableViewDataSource&gt;//初始化方法: 传数据源, cellIdentifier, 三个block分别对应配置, 行高, 点击。- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock ;//将UITableViewDataSource和UITableViewDelegate设于TableViewDataSourceDelegate。- (void)handleTableViewDatasourceAndDelegate:(UITableView *)table ;//默认indexPath.row对应每个dataSource相应返回item。- (id)itemAtIndexPath:(NSIndexPath *)indexPath ;@end</code></pre><p>在 1.1 中为了避免 model 和 view 的耦合，将 cell 的配置用 category 方法处理。但使用的方式是每一个<code>UITableViewCell</code>都做了扩展，实际上可以做得更彻底 ——直接对这些子类的父类<code>UITableViewCell</code>进行扩展。这样做的好处是比 1.1 的扩展方法更加灵活，可以提供多个 configure 方法，针对不同类型的 model 进行数据展示，同时也增强 cell 的移植性。<br>为 UITableViewCell 提供扩展<code>UITableViewCell+Extension.h</code></p><pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;@interface UITableViewCell (Extension)//实际是tableView reigister nib，由于是与cell(view)紧密相关的方法，故在cell本身进行实现，而非在vc中。+(void) registerTable:(UITableView*)table        nibIdentifier:(NSString*)identifier;//根据数据源配置并绘制cell 子类需重写该方法-(void)configure:(UITableViewCell*)cell       customObj:(id)obj       indexPath:(NSIndexPath*)indexPath;//根据数据源计算cell的高度 子类可重写该方法, 若不写为默认值44.0+(CGFloat)getCellHeightWithCustomObj:(id)obj                        indexPath:(NSIndexPath*)indexPath;@end</code></pre><p>如此，对于每一个 cell 子类，实现两个新方法:</p><pre><code class="objc">- (void)configure:(UITableViewCell *)cell        customObj:(id)obj        indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}+ (CGFloat)getCellHeightWithCustomObj:(id)obj                            indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}</code></pre><p>OK,做了这么多工作，返回 VC 看一下最后的成果吧！瘦身后的 viewController 对于 tableView 的所有处理都只需要一个方法<code>setUpTableView</code></p><pre><code class="objc">- (void)setupTableView{    TableViewCellConfigureBlock configureCell = ^(NSIndexPath *indexPath, MyObj *obj, XTRootCustomCell *cell) {        [cell configure:cell customObj:obj indexPath:indexPath] ;    } ;    CellHeightBlock heightBlock = ^CGFloat(NSIndexPath *indexPath, id item) {        return [MyCell getCellHeightWithCustomObj:item indexPath:indexPath] ;    } ;    DidSelectCellBlock selectedBlock = ^(NSIndexPath *indexPath, id item) {        NSLog(@&quot;click row : %@&quot;,@(indexPath.row)) ;    } ;    self.tableHandler = [[TableDataDelegate alloc] initWithItems:self.list                                                   cellIdentifier:MyCellIdentifier                                               configureCellBlock:configureCell                                                  cellHeightBlock:heightBlock                                                   didSelectBlock:selectedBlock] ;    [self.tableHander handleTableViewDatasourceAndDelegate:self.table] ;}</code></pre><blockquote><p>1.2 <a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">参考项目看这里</a></p></blockquote><h3 id="抽离-TableView-终极版"><a href="#抽离-TableView-终极版" class="headerlink" title="抽离 TableView 终极版"></a>抽离 TableView 终极版</h3><p>经过 1.2 的处理，<code>UITableViewDelegate</code> 和 <code>UITableViewDataSource</code> 的方法都已经移到<code>TableViewDataSourceDelegate</code>这个类中处理，但根据<br><a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">1.2参考项目</a>可以发现1.2的处理方式有局限性，我们观察<code>TableViewDataSourceDelegate</code>中的核心方法:</p><pre><code class="objc">- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock;</code></pre><p><code>TableViewDataSourceDelegate</code>进行初始化时需传递参数<code>CellIdentifier</code>和<code>aHeightBlock</code>,实际开发工作中这两者通常是和<code>UITableViewCell</code>类紧密相关的。一类 <code>UITableViewCell</code>往往对应一个它自己的 <code>CellIdentifier</code> 和 <code>cellHeight</code>，如果初始化<code>TableViewDataSourceDelegate</code>对象时就指定这两个属性，则<code>TableViewDataSourceDelegate</code>仅局限于被一种 tableView 复用:cell种类都相同，也就是用一个tableView展示一个数组( indexPath.row 对应数组下标)。如图：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezscp180r2j30af0hz755.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005tGCqhjw1ezscrw6qbyj30ah0icgnm.jpg" alt=""><br>这些 cell 都是同一种类，但实际开发中往往面临着更复杂的 cell 样式，如我在开发<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">校友圈</a>时：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezsd219avzj30ag0ikaau.jpg" alt=""><br>这种情况怎么使用<code>TableViewDataSourceDelegate</code>呢？修改<code>TableViewDataSourceDelegate</code>的 init 方法：</p><pre><code class="objc">(id)initWithItems:(NSDictionary *)anItemsconfigureCellBlock:(TableViewCellConfigureCellBlock)aConfigureCellBlock   cellHeightBlock:(CellHeightBlock)aHeightBlock    didSelectBlock:(DidSelectCellBlock)aDidSelectBlock;</code></pre><h2 id="业务逻辑移到-model-中"><a href="#业务逻辑移到-model-中" class="headerlink" title="业务逻辑移到 model 中"></a>业务逻辑移到 model 中</h2><p>尽管 viewController 最主要功能是处理业务逻辑，但对于一些和 model 联系紧密，和 view 关系不大（即不是 model 和 view 进行交互的逻辑）的代码应移到 model 中，通常是用 category 的处理方法，更加清晰。</p><h2 id="网络请求逻辑移到-model"><a href="#网络请求逻辑移到-model" class="headerlink" title="网络请求逻辑移到 model"></a>网络请求逻辑移到 model</h2><p>用 category 方式处理。viewController 使用 block 回调请求网络。</p><h2 id="view-代码移到-view-层"><a href="#view-代码移到-view-层" class="headerlink" title="view 代码移到 view 层"></a>view 代码移到 view 层</h2><p>不要在 viewController 中构建复杂的 view 层次结构。<br>要注意的是，IB 并非只能和 viewControllers 一起使用，可以加载单独的 nib 文件到自定义的 view 中。</p><blockquote><p>参考：<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
