<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>为 ViewControllers 瘦身</title>
      <link href="/2018/05/30/%E4%B8%BA%20ViewControllers%20%E7%98%A6%E8%BA%AB/"/>
      <url>/2018/05/30/%E4%B8%BA%20ViewControllers%20%E7%98%A6%E8%BA%AB/</url>
      <content type="html"><![CDATA[<p>目标：写可维护的代码。<br><a id="more"></a></p><h2 id="把TableView从ViewController中抽出来"><a href="#把TableView从ViewController中抽出来" class="headerlink" title="把TableView从ViewController中抽出来"></a>把TableView从ViewController中抽出来</h2><p>UITableView可以说是iOS界面开发中用的最广泛的组件，就我自己做过的项目而言，绝大部份ViewController都是在围绕tableViewDelegate 和 UITableViewDataSource 中的方法打交道。但说到底这些函数都是View层面的，全部在VC中处理显得不太合适，也不利于日后的维护和扩展，所以关于瘦身VC很容易想到一点是从<strong>VC中抽离tableView的表示逻辑</strong>。这种思想其实与最近火热的<a href="http://www.cnblogs.com/ludashi/p/4211556.html" target="_blank" rel="noopener">MVVM</a>设计模式相通。就是<strong>把”逻辑部分”尽量移到Model层</strong>, 你可以认为它是一个中间层 , 所谓”逻辑部分”可以是各种delegate,网络请求,缓存,数据库,coredata等等等等 , 而controller正是用来组织串联他们，使得整个程序走通。</p><h3 id="把-Data-Source-分离出来"><a href="#把-Data-Source-分离出来" class="headerlink" title="把 Data Source 分离出来"></a>把 Data Source 分离出来</h3><p>举例:当需要将一个数组映射到一个tableView进行显示，这种一一对应关系可以单独写一个类ArrayDataSource，使用block或者delegate设置cell。ArrayDataSource类完全可以复用到任何需要<strong>将一个数组的内容映射到一个tableView</strong>的场景。<br>ArrayDataSource中声明block(cell,item)来初始化cell，block实现方式（item和cell如何对应）则可以在 cell+Configure 的category中声明。<br>使用ArrayDataSource，在ViewController中执行setUpTableView即可。setUpTableView中实现block（可以是执行configure方法的方式）。使用cell类category的方式是为了<strong>避免向 data source 暴露 cell 的设计</strong>,说白了是为了更好得分离 view 和 model 层。</p><blockquote><p><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank" rel="noopener">1.1 参考项目看这里</a></p></blockquote><h3 id="把-Data-Source-和-Delegate-都分离出来"><a href="#把-Data-Source-和-Delegate-都分离出来" class="headerlink" title="把 Data Source 和 Delegate 都分离出来"></a>把 Data Source 和 Delegate 都分离出来</h3><p>1.1中的方法是在objccn<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a>一文中提到的。但该文讲的只是把UITableViewDataSource中的方法提取到一个单独的类，从结果来看，是把<code>numberOfRowsInSection</code>和<code>cellForRowAtIndexPath</code>从VC中提取出去。但实际上UITableViewDelegate也是可以抽象出去的。例如cell的生成, cell行高, 点击事件等等。这里我用了block的形式使得函数能够回调。</p><p>处理类<code>TableViewDataSourceDelegate.h</code></p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void    (^TableViewCellConfigureBlock)(NSIndexPath *indexPath, id item, XTRootCustomCell *cell) ;typedef CGFloat (^CellHeightBlock)(NSIndexPath *indexPath, id item) ;typedef void    (^DidSelectCellBlock)(NSIndexPath *indexPath, id item) ;@interface TableViewDataSourceDelegate : NSObject &lt;UITableViewDelegate,UITableViewDataSource&gt;//初始化方法: 传数据源, cellIdentifier, 三个block分别对应配置, 行高, 点击。- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock ;//将UITableViewDataSource和UITableViewDelegate设于TableViewDataSourceDelegate。- (void)handleTableViewDatasourceAndDelegate:(UITableView *)table ;//默认indexPath.row对应每个dataSource相应返回item。- (id)itemAtIndexPath:(NSIndexPath *)indexPath ;@end</code></pre><p>在1.1中为了避免model和view的耦合，将cell的配置用category方法处理。但使用的方式是每一个UITableViewCell都做了扩展，实际上可以做得更彻底－－－<strong>直接对这些子类的父类UITableViewCell进行扩展</strong>。这样做的好处是比1.1的扩展方法更加灵活，可以提供多个configure方法，针对不同类型的Model进行数据展示，同时也增强Cell的移植性。</p><p>对UITableViewCell的扩展<code>UITableViewCell+Extension.h</code></p><pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;@interface UITableViewCell (Extension)//实际是tableView reigister nib，由于是与cell(view)紧密相关的方法，故在cell本身进行实现，而非在vc中。+(void) registerTable:(UITableView*)table        nibIdentifier:(NSString*)identifier;//根据数据源配置并绘制cell 子类需重写该方法-(void)configure:(UITableViewCell*)cell       customObj:(id)obj       indexPath:(NSIndexPath*)indexPath;//根据数据源计算cell的高度 子类可重写该方法, 若不写为默认值44.0+(CGFloat)getCellHeightWithCustomObj:(id)obj                        indexPath:(NSIndexPath*)indexPath;@end</code></pre><p>如此，对于每一个Cell子类，实现两个新方法:</p><pre><code class="objc">- (void)configure:(UITableViewCell *)cell        customObj:(id)obj        indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}+ (CGFloat)getCellHeightWithCustomObj:(id)obj                            indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}</code></pre><p>OK,做了这么多工作，返回VC看一下最后的成果吧！瘦身后的ViewController对于tableView的所有处理都只需要一个方法<code>setUpTableView</code></p><pre><code class="objc">- (void)setupTableView{    TableViewCellConfigureBlock configureCell = ^(NSIndexPath *indexPath, MyObj *obj, XTRootCustomCell *cell) {        [cell configure:cell customObj:obj indexPath:indexPath] ;    } ;    CellHeightBlock heightBlock = ^CGFloat(NSIndexPath *indexPath, id item) {        return [MyCell getCellHeightWithCustomObj:item indexPath:indexPath] ;    } ;    DidSelectCellBlock selectedBlock = ^(NSIndexPath *indexPath, id item) {        NSLog(@&quot;click row : %@&quot;,@(indexPath.row)) ;    } ;    self.tableHandler = [[TableDataDelegate alloc] initWithItems:self.list                                                   cellIdentifier:MyCellIdentifier                                               configureCellBlock:configureCell                                                  cellHeightBlock:heightBlock                                                   didSelectBlock:selectedBlock] ;    [self.tableHander handleTableViewDatasourceAndDelegate:self.table] ;}</code></pre><blockquote><p>1.2 <a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">参考项目看这里</a></p></blockquote><h3 id="抽离TableView终极版"><a href="#抽离TableView终极版" class="headerlink" title="抽离TableView终极版"></a>抽离TableView终极版</h3><p>经过1.2的处理，UITableViewDelegate 和 UITableViewDataSource 的方法都已经移到<code>TableViewDataSourceDelegate</code>这个类中处理，但根据<br><a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">1.2参考项目</a>可以发现1.2的处理方式有局限性，我们观察<code>TableViewDataSourceDelegate</code>中的核心方法:</p><pre><code class="objc">- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock;</code></pre><p><code>TableViewDataSourceDelegate</code>进行初始化时需传递参数<code>CellIdentifier</code>和<code>aHeightBlock</code>,实际开发工作中这两者通常是和<code>UITableViewCell</code>类紧密相关的。一类 UITableViewCell 往往对应一个它自己的 CellIdentifier 和 cellHeight，如果初始化<code>TableViewDataSourceDelegate</code>对象时就指定这两个属性，则<code>TableViewDataSourceDelegate</code>仅局限于被一种tableView复用:cell种类都相同，也就是<strong>用一个tableView展示一个数组</strong>( indexPath.row 对应 数组下标 )。如图：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezscp180r2j30af0hz755.jpg" alt=""><br><br><img src="http://ww2.sinaimg.cn/large/005tGCqhjw1ezscrw6qbyj30ah0icgnm.jpg" alt=""></p><p>这些cell都是同一种类，但实际开发中往往面临着更复杂的cell样式，如我在开发 <em>校友圈</em> 时：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezsd219avzj30ag0ikaau.jpg" alt=""></p><p>这种情况怎么使用<code>TableViewDataSourceDelegate</code>呢？<br>我目前是如下方法实现的，但感觉有些太复杂了，如果你有更好的处理方法欢迎与我交流。<br><br><br><strong>a. 修改<code>TableViewDataSourceDelegate</code>的init方法</strong>。</p><pre><code class="objc">(id)initWithItems:(NSDictionary *)anItemsconfigureCellBlock:(TableViewCellConfigureCellBlock)aConfigureCellBlock   cellHeightBlock:(CellHeightBlock)aHeightBlock    didSelectBlock:(DidSelectCellBlock)aDidSelectBlock;</code></pre><h2 id="业务逻辑移到model中"><a href="#业务逻辑移到model中" class="headerlink" title="业务逻辑移到model中"></a>业务逻辑移到model中</h2><p>尽管viewController最主要功能是处理业务逻辑，但对于一些和model联系紧密，和view关系不大（即不是model和view进行交互的逻辑）的代码应移到model中，通常是用category的处理方法，更加清晰。</p><h2 id="网络请求逻辑移到model"><a href="#网络请求逻辑移到model" class="headerlink" title="网络请求逻辑移到model"></a>网络请求逻辑移到model</h2><p>用category方式处理。viewController使用block回调的方式请求网络。</p><h2 id="view代码移到view层"><a href="#view代码移到view层" class="headerlink" title="view代码移到view层"></a>view代码移到view层</h2><p>不要在 view controller 中构建复杂的 view 层次结构。<br>要注意的是， <strong>IB 并非只能和 view controllers 一起使用</strong>，可以加载单独的 nib 文件到自定义的 view 中。</p><blockquote><p>参考：<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/29/hello-world/"/>
      <url>/2018/05/29/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> How To </category>
          
          <category> Hexo </category>
          
          <category> MathJax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> MathJax </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
