<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>DynamicCard - 基于 FlexBoxLayout 的动态排版渲染引擎</title>
      <link href="/2019/04/24/dynamiccard/"/>
      <url>/2019/04/24/dynamiccard/</url>
      <content type="html"><![CDATA[<p>客户端开发一直存在的一个主要矛盾是产品运营日益增长的快速迭代需要同应用市场严格的审核上架周期之间的矛盾。为应对这一矛盾各种客户端动态化的方案层出不穷。本文介绍一种基于 FlexBox 和 Yoga 的动态排版框架( for iOS )，可在线上调整页面样式，同时对新增卡片类型可做到无需跟版本实时更新。<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>App Store 新应用上架和版本更新必经的人工审核一直让急性子的中国开发者头疼，虽然目前已经大大缩减了审核周期（通常前一天晚上提审，次日上午即可得到结果），但遇到重大 bug 急需修复，或者仅仅是想改动某个 label 的样式，想在某个地方加个 button 都要重新开发和提审的话显然是不现实的。另一方面现在的 APP 页面样式五花八门，以常见的 feeds 流为例：<br><img src="/pic/007iUjdily1fxhukh0quej31k10u07wj.jpeg" alt=""><br>一个 tableview 常常由文字+图片+视频随机排列组合形成多种样式的 cell, 如果按照传统的方法每新增一种样式就新建一个类继承 <code>UITableViewCell</code>, 非常低效和复杂。这种场景页面的动态化也是刚需。<br>一个成熟的UI排版渲染引擎至少需要解决以下问题：</p><ol><li>提升开发效率。</li><li>新增和修改 Feed 样式不需要跟版本。</li><li>列表的滑动流畅不应受影响。</li><li>允许扩展自定义样式。</li></ol><p>业内终端动态化最著名的两个框架是 ReactNative 和 weex，两个框架的好处是代码复用和跨平台，但带来的问题就是对开发人员的要求挺高的，不仅要懂 js/react/vue, 还要懂安卓和 iOS 开发；对工程的侵入性很大，很多开发人员<a href="https://juejin.im/post/5b2a5368f265da595c0cf6d5" target="_blank" rel="noopener">对 React Native 的缺陷诟病已久</a>。其实如果团队内不是所有人都熟悉js的话，很自然的想法是退而求其次，不必下发 jsBundle，<strong>通过后台下发 json/xml 配置文件，终端去解析并在 APP 上生成真实布局</strong>。这就是 DynamicCard 实现动态化的核心。先来看看用起来是怎么样的。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先需要一个排版描述（layoutDic, 限于篇幅，子卡只给出 10002）：</p><pre><code class="JSON">&quot;1007&quot;: {    &quot;cardID&quot;: 1007,    &quot;version&quot;: 1,    &quot;minFrameworkVersion&quot;: 1,    &quot;desc&quot;: &quot;内容视频卡&quot;,    &quot;flex_direction&quot;: &quot;column&quot;,    &quot;subviews&quot;: [{            &quot;margin&quot;: [16, 28, 16, 0],            &quot;subCardID&quot;: &quot;10001&quot;,            &quot;is_clickable&quot;: 1,            &quot;name&quot;: &quot;userSubCard&quot;,            &quot;type&quot;: &quot;UISubCardView&quot;        },        {            &quot;margin&quot;: [16, 10, 16, 0],            &quot;type&quot;: &quot;UILabel&quot;,                  &quot;name&quot;: &quot;content&quot;,            &quot;font_size&quot;: 14,            &quot;lines&quot;: 0,            &quot;font_color&quot;: &quot;#222222&quot;,            &quot;font_name&quot;: &quot;PingFangSC-Regular&quot;,            &quot;line_height&quot;: 24,            &quot;letter_space&quot;: 0.7,            &quot;text&quot;: &quot;content_text&quot;        },        {            &quot;margin&quot;: [16, 16, 16, 0],            &quot;type&quot;: &quot;UIVideoView&quot;,            &quot;name&quot;: &quot;video&quot;,            &quot;video_url&quot;: &quot;video_url&quot;,            &quot;video_cover&quot;: &quot;video_cover&quot;,            &quot;video_width&quot;: &quot;video_width&quot;,            &quot;video_height&quot;: &quot;video_height&quot;,            &quot;video_auotoPlay&quot;: &quot;video_auotoPlay&quot;,            &quot;video_showMute&quot;: &quot;video_showMute&quot;,            &quot;corner_radius&quot;: 8,            &quot;background_color&quot;: &quot;#ffffff&quot;        },        {            &quot;margin&quot;: [16, 12, 0, 0],            &quot;subCardID&quot;: &quot;10004&quot;,            &quot;name&quot;: &quot;gameSubCard&quot;,            &quot;type&quot;: &quot;UISubCardView&quot;        },        {            &quot;margin&quot;: [16, 12, 0, 24],            &quot;subCardID&quot;: &quot;10002&quot;,            &quot;name&quot;: &quot;actionSubCard&quot;,            &quot;type&quot;: &quot;UISubCardView&quot;        }    ]}&quot;10002&quot;: {    &quot;cardID&quot;: 10002,    &quot;version&quot;: 1,    &quot;minFrameworkVersion&quot;: 1,    &quot;desc&quot;: &quot;内容卡的操作子卡（点赞评论）&quot;,    &quot;flex_direction&quot;: &quot;row&quot;,    &quot;align_items&quot;: &quot;alignStart&quot;,    &quot;subviews&quot;: [{            &quot;margin&quot;: [0, 0, 0, 0],            &quot;size&quot;: [76, 24],            &quot;type&quot;: &quot;UIVirtualView&quot;,            &quot;flex_direction&quot;: &quot;row&quot;,            &quot;align_items&quot;: &quot;alignStart&quot;,            &quot;subviews&quot;: [{                &quot;margin&quot;: [0, 0, 0, 0],                &quot;size&quot;: [0, 24],                &quot;type&quot;: &quot;UIButton&quot;,                &quot;font_color&quot;: &quot;#777575&quot;,                &quot;font_color_selected&quot;: &quot;#777575&quot;,                &quot;font_size&quot;: 12,                &quot;name&quot;: &quot;like&quot;,                &quot;status&quot;: &quot;like_status&quot;,                &quot;font_name&quot;: &quot;PingFangSC-Light&quot;,                &quot;image_url&quot;: &quot;like_picture&quot;,                &quot;direction&quot;: &quot;left&quot;,                &quot;horizontal_alignment&quot;: &quot;left&quot;,                &quot;content_edge_insets&quot;: [5.3, 3.5, 5.3, 3.5],                &quot;compound_drawable_padding&quot;: 8.7,                &quot;title&quot;: &quot;like_count&quot;,                &quot;action&quot;: &quot;like_event&quot;            }]        },        {            &quot;margin&quot;: [0, 0, 0, 0],            &quot;size&quot;: [76, 24],            &quot;type&quot;: &quot;UIVirtualView&quot;,            &quot;flex_direction&quot;: &quot;row&quot;,            &quot;align_items&quot;: &quot;alignStart&quot;,            &quot;subviews&quot;: [{                &quot;margin&quot;: [0, 0, 0, 0],                &quot;size&quot;: [0, 24],                &quot;type&quot;: &quot;UIButton&quot;,                &quot;font_color&quot;: &quot;#777575&quot;,                &quot;font_color_selected&quot;: &quot;#777575&quot;,                &quot;font_size&quot;: 12,                &quot;name&quot;: &quot;comment&quot;,                &quot;font_name&quot;: &quot;PingFangSC-Light&quot;,                &quot;image_url&quot;: &quot;comment_picture&quot;,                &quot;direction&quot;: &quot;left&quot;,                &quot;horizontal_alignment&quot;: &quot;left&quot;,                &quot;content_edge_insets&quot;: [5.3, 3.5, 5.3, 3.5],                &quot;compound_drawable_padding&quot;: 8.7,                &quot;title&quot;: &quot;comment_count&quot;,                &quot;action&quot;: &quot;comment_event&quot;            }]        }    ]}</code></pre><p>接着需要一个业务数据描述（dataDic）</p><pre><code class="JSON">{    &quot;card_id&quot;:1007,    &quot;user_icon&quot;:&quot;http://img.jystatic.com/expmepic/2018/07/20/44b83ff79eaaba7a89247a6046b2dc4a_1532092212.png&quot;,    &quot;user_name&quot;:&quot;抽筋八骨&quot;,    &quot;user_id&quot;:&quot;108395&quot;,    &quot;user_levelImage&quot;:&quot;https://img.jystatic.com/expmepic/20180816/w3.png&quot;,    &quot;user_event&quot;:&quot;JumpUserDetailPage&quot;,    &quot;time_text&quot;:&quot;7月26日&quot;,    &quot;follow_event&quot;:&quot;FollowEvent&quot;,    &quot;follow_name&quot;:&quot;关注|已关注&quot;,    &quot;follow_status&quot;:0,    &quot;content_id&quot;:&quot;post_108395_1532592117598&quot;,    &quot;content_text&quot;:&quot;今天推荐一款船新的音乐游戏polytone，感觉自己化身DJ在打碟&quot;,    &quot;video_cover&quot;:&quot;https://img.jystatic.com/expmepic/2018/09/19/800efe4c5ae4dd82414a9ec6060190ee_1532590303.1.png&quot;,    &quot;video_width&quot;:1920,    &quot;video_url&quot;:&quot;http://video2.jystatic.com/shg_1110_50003_d7459ef7730a4fa78c37976431c2cd2d.f501.mp4?dis_k=1043e9edde940a512d19a2f4432c6767&amp;dis_t=1546874077&quot;,    &quot;video_duration&quot;:34,    &quot;video_height&quot;:1080,    &quot;app_icon&quot;:&quot;https://img.jystatic.com/expmepic/2018/07/25/21abecdd40f93c1987fe8f27fd691316_1532504772830148299.png&quot;,    &quot;app_name&quot;:&quot;polytone&quot;,    &quot;app_event&quot;:&quot;JumpGameDetailPage&quot;,    &quot;like_event&quot;:&quot;LikeEvent&quot;,    &quot;like_status&quot;:0,    &quot;like_count&quot;:403,    &quot;like_picture&quot;:&quot;icon_like_normal.png|icon_like_highlight.png&quot;,    &quot;comment_count&quot;:43,    &quot;comment_picture&quot;:&quot;icon_comment.png&quot;,    &quot;comment_event&quot;:&quot;JumpCommentsPage&quot;}</code></pre><p>以上排版数据的结果如下：<br><img src="/pic/007i4MEmgy1fyyfa7rwuxj30ie0jyaid.jpg" alt=""><br>看到这个demo，大家应该知道 DynamicCard 是什么东西了，上面的 JSON 文件阅读起来也非常自然、直接。接下来要解决的问题比较多。这里重点描述<strong>布局与事件处理、重用、扩展</strong>。分别解决 <strong>UI 在线调整、性能优化、功能扩充</strong>三个方面的问题。</p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="v0-AutoLayout"><a href="#v0-AutoLayout" class="headerlink" title="v0. AutoLayout"></a>v0. AutoLayout</h2><p>第一版我们采用了 autolayout 布局，对于每个控件由四个数组控制决定它的约束：</p><blockquote><p>margin、marginView、marginDirection、size</p></blockquote><p>View 层使用<a href="https://objccn.io/issue-5-1/" target="_blank" rel="noopener">TextKit</a>实现图文混排，这样不必再关心控件具体是 <code>UILabel</code>, 还是<code>UITextView</code>、<code>UIImageView</code>等，统一抽象到一个三层架构中进行渲染：<code>NSTextStorage</code>管理文本内容和属性，<code>NSLayoutManager</code>从<code>NSTextStorage</code>对象中取得文本后进行排版，然后把排版之后的文本放到<code>NSTextContainer</code>对象指定的区域上。最后再由一个文本控件从<code>NSTextContainer</code>中取出内容显示到屏幕中。<br><img src="https://objccn.io/images/issues/issue-5/TextKit.png" alt=""><br>很快发现由于每个控件都用四个数组才能确定位置，随着卡片样式的丰富，布局字典过于复杂，反而拖累了开发效率，亟需新的布局引擎。</p><h2 id="v1-FlexBoxLayout"><a href="#v1-FlexBoxLayout" class="headerlink" title="v1. FlexBoxLayout"></a>v1. FlexBoxLayout</h2><p>这里要感谢<a href="https://lpd-ios.github.io/" target="_blank" rel="noopener">饿了么团队</a>的两篇博文<a href="https://lpd-ios.github.io/2017/04/05/FlexBox-Weex/" target="_blank" rel="noopener">《由 FlexBox 算法强力驱动的 Weex 布局引擎》</a>、<a href="https://lpd-ios.github.io/2017/02/12/Flexbox-CSSLayout/" target="_blank" rel="noopener">《iOS Flexbox 布局优化》</a>，带我们找到了非常适合当下场景的<strong>基于 Yoga 引擎的 Flexbox 布局方案 —— <a href="https://github.com/carlSQ/FlexBoxLayout" target="_blank" rel="noopener">FlexBoxLayout</a></strong>，不了解<code>Yoga</code>和<code>FlexBox</code>的话可以阅读那两篇文章。总之它使得我们可以像安卓开发中 XML 使用五大布局定义视图一样实现 iOS 界面布局，从开头 demo 的 layoutDic 可以看出。</p><p>DynamicCard 框架整体设计为 MVVM 架构，每张卡片分配唯一的一个<code>cardID</code>, 代表一种样式。定义<code>CardView</code>作为卡片根容器，用<code>CardModel</code>进行初始化。<code>subViews</code>为该卡片的所有字view，定义基类<code>ViewModel</code>管理 view 的一些基础属性如<code>background_color</code>, <code>corner_radius</code>, <code>border_width</code>, <code>visibility</code> 等，之后我们用工厂方法创建每种具体 view 所绑定的 <code>viewModel</code>，如：</p><table><thead><tr><th>view</th><th>viewModel</th></tr></thead><tbody><tr><td>DCLabel</td><td>DCLabelModel</td></tr><tr><td>DCButton</td><td>DCButtonModel</td></tr><tr><td>DCImageView</td><td>DCImageModel</td></tr><tr><td>DCVideoView</td><td>DCVideoModel</td></tr></tbody></table><p><code>ViewModel</code>用来绑定 view 和 data，以及管理数据的更新。框架的工作原理如下图，对一张卡片的渲染大致分三个流程：</p><ol><li>从统一后台（或者本地缓存）拉取布局字典，从业务后台获取数据字典；</li><li>根据 layoutMap + dataMap 生成所需要的 viewModels 及 cardModel，完成 view-viewModel 的数据绑定；</li><li>使用 FlexBoxLayout 进行布局，最终将卡片展示在屏幕上。</li></ol><p><img src="/pic/007i4MEmgy1fyzaxbruuxj31hx0u04qp.jpg" alt=""><br>为提升开发效率我们作了两点优化：</p><ol><li>支持子卡, 对应 viewModel <code>SubCardViewModel</code>, 便于组合复用一些模板卡片，如demo 10001,10002,10004 卡;</li><li>支持虚拟视图，对应 viewModel <code>DCVirtualNodeModel</code>,  避免为实现 FlexBox 布局而创建无用 view 占内存。</li></ol><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>每个<code>viewModel</code>除了<code>layoutDic</code>和<code>dataDic</code>外，还有一个<code>actionModel</code>，通过<code>action</code>字段下发对应的点击事件。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>本地统一管理一个路由事件表，事件分为两类：</p><ol><li>跳转事件。<br><em>eg. [“JumpCommentsPage” : “jyp://open?page=CommentDetailViewController”]</em></li><li>自定义事件。<br><em>eg. [“LikeEvent” : “jyp://open?target=ButtonService&amp;&amp;action=onLikeButtonClick:”]</em></li></ol><p>后台为某个 view 的 action 赋值后，本地路由去匹配完整的伪协议链接，根据格式判断是跳转还是点击，注意两种事件都是将所需参数注入<code>dataDic</code>传给路由。 如果是跳转事件很好处理；自定义事件我们则需要让<code>viewModel</code>实时响应其数据变化，与其相关联的其他<code>viewModel</code>也要及时刷新。 </p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>前面讲到 DynamicCard 使用 MVVM 架构，自然是需要 viewModel 监听 model 的属性变化，再控制 view 去刷新UI。图示为 model 层，单例<code>modelManager</code>将维护一个<code>modelList</code>，这里有个前提是 id 之间不能有重复。<br><img src="/pic/007i4MEmgy1fyzk0e1xj3j313k0u078c.jpg" alt=""><br>以 demo 卡片为例，dataDic 存在 userId、contentId，初始化该卡片<code>cardModel</code>时新建<code>userModel</code>及<code>contentModel</code>插入 modelList, 并为二者添加观察者<code>cardModel</code>，<code>cardModel</code>实现<code>observeValueForKeyPath:</code>. 用户点赞后，<code>modelManager</code>更新该卡片 <code>contentModel</code>, 观察者<code>cardModel</code>更新<code>like_status</code>、<code>like_count</code>值后，刷新对应的 subView.<br><img src="/pic/007i4MEmgy1fyzl8bus1oj30wm0u0k7y.jpg" alt=""><br>注意如果app内其它地方卡片2也有该 feed（同一 contentId），则不需新建 contentModel, 将卡片2添加到观察者列表中，在卡片1点赞，卡片2也会实时响应刷新。</p><h1 id="重用"><a href="#重用" class="headerlink" title="重用"></a>重用</h1><p>重用是 DynamicCard 在设计之初就重点考虑的一个因素，也是不同于其他引擎的最大的特色。例如 React Native 很大的一个缺陷就是不支持 cell 重用，原因：</p><blockquote><ol><li>UITableView 是主线程同步的，为了保证 UI 流畅度，UI 的渲染需要达到60帧/秒，每帧的大致消耗时间保持在16ms之内；</li><li>React Native 运行在单独线程，和UI主线程不同步，也就是从 RN Render 到真正调用 native 代码这个过程是异步的，导致从js运行到最后系统渲染的总时间很难做到&lt;16ms.</li></ol></blockquote><p>可以说有了<strong>重用</strong>这个特性，DynamicCard 才能应用在列表等有高性能要求的场景。重用指的是，在 UITableView 滑动的时候，不同列表项复用同一个 Cell，Cell 里面的视图数据可以重复使用，核心是为了减少创建视图和修改视图树的次数。<code>FlexBoxLayout</code>提供了 UITableView 的一个 category: <code>UITableView+FBLayout</code>, <strong>支持自动高度、布局缓存，contentView 缓存，和自动 cache 失效机制。</strong> 简单分析下实现方式。<br>为每个<code>UITableView</code>提供两种缓存方案：contentView 缓存 和布局缓存（可选）。对外提供 cell view 的构建block, 展示某行 cell 时，先查看 contentView 是否有缓存（以 indexPath 索引），如果有直接返回缓存。没有的话通过 block 获取 view，然后查找 layout 缓存，如果命中直接<code>applyLayoutCache</code>设置 frame，否则<code>applyWithSize</code>计算 frame. 至此 cell 样式确定，然后根据需要可将 layout 或者 contentView 添加到缓存中。<br><img src="/pic/007i4MEmgy1fz0gk0y13cj31ba0u0wln.jpg" alt=""><br>我们进一步封装一个<code>DyCardTableViewController</code>, 提供数据源<code>dataList</code>, 即后台返回的 dataDic 数组。</p><pre><code class="Swift">lazy var dataList = [[String: Any]]()</code></pre><p>创建 tableView 并提供<code>fb_setCellContnetViewBlock</code>实现：</p><pre><code class="Swift">tableView.fb_setCellContnetViewBlock(forIndexPath: { [weak self] indexPath -&gt; UIView in    guard let data = self?.dataList[indexPath.row],        let cardID = data[DyCardDataKey.cardID] as? String,        let layoutDic = DCLayoutEngine.shared.getLayoutDicByCardId(cardID) else {            return DCCardView(frame: .zero)    }    let cardModel = DCCardModel(layoutDic: layoutDic, dataDic: data)    let cardView = DCCardView(cardModel: cardModel)    cardView.cardClickClosure = self?.cardClickClosure    return cardView})</code></pre><p>但实际使用中发现开启 contentView 缓存后，列表下拉非常流畅，但上滑加载速度慢，研究源码发现其实是“伪重用”：</p><pre><code class="Objective-c">//UITableView+FBLayout.m- (UITableViewCell *)fb_cacheCellForIndexPath:(NSIndexPath *)indexPath {    // static NSString *kCellIdentifier = @&quot;fb_kCellIdentifier&quot;;    UITableViewCell *cell = [self dequeueReusableCellWithIdentifier:kCellIdentifier forIndexPath:indexPath];    UIView *reuseContentView = [cell.contentView viewWithTag:contentViewTag];    [self updateLayoutCacheWtih:reuseContentView toIndexPath:cell.indexPathStorage];    // 取缓存，或者block创建    UIView *cellContentView = [self fb_cacheContentView:indexPath reuseContentView:reuseContentView];    cell.fb_drawsAsynchronously = YES;    cellContentView.fb_drawsAsynchronously = YES;    cell.selectionStyle = cellContentView.fb_selectionStyle;    cell.backgroundColor = cellContentView.backgroundColor;    cell.clipsToBounds = cellContentView.clipsToBounds;    [cell setIndexPathStorageWithIndexPath:indexPath];    [self fb_configContentView:cellContentView forCell:cell];    return cell;}- (void)fb_configContentView:(UIView *)contentView forCell:(UITableViewCell *)cell{  UIView *removedView = [cell.contentView viewWithTag:contentViewTag];  [removedView removeFromSuperview];  [cell.contentView addSubview:contentView];}</code></pre><p><code>reuseIdentifier</code>只有一个定值，所谓的“重用”只到 contentView 级别，具体的子 view(label\button 等) 仍需由 CardView 创建 -&gt; 填充数据 -&gt; 布局 -&gt; 计算frame, 这显然是不够的。对<code>UITableView+FBLayout</code>进行了改造：</p><ol><li>既然一个<code>cardId</code>代表一种卡片样式，直接以<code>cardId</code>作为<code>reuseIdentifier</code>；</li><li><code>ViewModel</code>基类提供<code>updateView()</code>方法，子类实现直接刷新数据而不必新建view, 例如 label 更新 text, imageView 更新 image;</li><li>关闭 contentView 缓存，每个 cell 优先从复用池取，如果有，则 update 数据后计算 frame（or下拉场景直接 apply layoutCache），没有则新建。</li></ol><p>优化后的 block 实现：</p><pre><code class="Swift"> tableView.fb_setCellContnetViewBlock(forIndexPath: { [weak self] indexPath, reuseContentView -&gt; UIView in     guard let data = self?.dataList[indexPath.row],         let cardID = data[DyCardDataKey.cardID] as? String,         let layoutDic = DCLayoutEngine.shared.getLayoutDicByCardId(cardID) else {             return DCCardView(frame: .zero)     }     if (self?.base_reuseContent)! {         if let reuseContentView = reuseContentView as? DCCardView, let cardID = Int(cardID){             //reuse             if reuseContentView.cardModel?.cardID == cardID {                 reuseContentView.cardModel?.update(dataDic:data)                 return reuseContentView             }         }     }     let cardModel = DCCardModel(layoutDic: layoutDic, dataDic: data)     let cardView = DCCardView(cardModel: cardModel)     cardView.cardClickClosure = self?.cardClickClosure     return cardView }) self.view.addSubview(tableView) tableView.snp.makeConstraints(self.tableViewConstraintWithTopBar(self.navigationBar, nil)) return tableView}()</code></pre><p>至此，对于一个类似 feeds 的列表，终端只需新建 ViewController 继承<code>DyCardTableViewController</code>, 设置好 tableView 位置等，再从后台拉取 dataDic 数组组装<code>dataList</code>即可，不用再关心每张卡片的样式。效率提升、代码整洁。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>DynamicCard 内置了一些基础渲染控件，比如文字（DCLabel），图片（DCImageView），按钮（DCButton）等。如果这些组件不满足需求，还可以通过扩展组件来完成封装。实现自定义控件的大概流程如下：<br><img src="/pic/007i4MEmgy1fz0my8zr2oj312a0u0wtm.jpg" alt=""></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>DynamicCard 已应用于多个上线项目。终端有一个 manager 负责卡片的<strong>版本控制</strong>和<strong>存储</strong>。本地预存一份原始布局 json 文件，以提供无网络等异常情况下的默认样式。我们为终端同学提供了一个 CMS 平台，可批量上传or手动添加某个卡片的布局json，首次上传 version = 0, 之后每编辑一次该卡片 version 自动加1，totalVersion 也加1。此外每张卡还有一个值<code>minParseVersion</code>, 表示支持该卡片样式的最低<code>DynamicCard</code> framework 版本。终端<code>kLayoutParseVersion</code>通常是跟随 app 版本升级的，例如某个版本扩展了新的自定义视图，或者解析规则发生了变化等。 APP 运行后，设置定时任务每隔一段时间检查是否有卡片布局更新（比较本地<code>totalVersion</code>是否小于后台），如果有则请求数据，下发的新卡片需满足两个条件：</p><ol><li>version &gt; 终端本地卡片 version（or 本地没有该 cardId）</li><li>minParseVersion &lt;= kLayoutParseVersion</li></ol><p>例如下图只会下发 1002 和 1011 卡：<br><img src="/pic/007i4MEmgy1fz0pz56yvcj31hy0tm79k.jpg" alt=""></p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li><strong>动态</strong>：这是 DynamicCard 最大的优势，也是开发此框架的初衷。现在所有的布局字典都统一在 CMS 平台配置、编辑、管理版本、下发，数据字典由业务后台下发。终端可以动态接收和实时加载、渲染、刷新数据，卡片的新增和调整摆脱了对终端版本的依赖，APP 具备 native 体验的同时又有类似 H5 的灵活性。</li><li><strong>快速</strong>：排版性能与直接书写的排版代码性能相差不大，封装的 TableView 支持自动高度、布局缓存、contentView 缓存、和自动 cache 失效机制，以保障列表页的流畅度（当然，比 AutoLayout 性能好很多）。</li><li><strong>描述型排版</strong>：DynamicCard 接收的排版信息是一个字典，不需要写逻辑代码。做成描述型的好处是:<ul><li>方便维护，不易出错（因为没有代码）；</li><li>方便存储；</li><li>提升开发效率，只要熟悉 FlexBox, 各种布局实现起来要比代码容易得多（此外可以给控件扩展一些属性快速实现效果，比如 UIButton 图文排布）。</li></ul></li></ol><pre><code class="Swift">var direction: String?                   // 图片位于文字的方位var compound_drawable_padding: Float?    // 间隙大小</code></pre><p>就实际使用感受来讲，DynamicCard 需要后台与安卓/iOS开发共同维护一份数据字典的文档，dataDic key 要求和 layoutDic 中定义的 value 一致，如果有不一致或者找不到的情况控件便无法正常渲染，一定程度上加大了后台的工作量。<br>相比 weex/RN 下发js脚本，DynamicCard 在事件处理方面显得不够灵活。但接入和学习成本小得多，终端上手快，而 weex/RN 其实是降低了前端开发者入门移动端的门槛。<br>终端要根据实际场景选择是否采用 DynamicCard，一些样式丰富且频繁变化的界面如feed流非常适合。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AVPlayer 边下边播与最佳实践</title>
      <link href="/2019/04/23/avplayer-best-practice/"/>
      <url>/2019/04/23/avplayer-best-practice/</url>
      <content type="html"><![CDATA[<p>最近研究 iOS 中视频播放器的相关内容，基于 AVPlayer 依次完成了底层视频边下边播的缓存框架、自定义的视频播放控制器、TableView 视频播放列表。本文整理一下边下边播的实现原理和使用 AVPlayer 遇到的一些坑。<br><a id="more"></a><br>相关代码开源在视频播放器<a href="https://github.com/zltunes/ZLPlayer" target="_blank" rel="noopener">ZLPlayer</a>, 支持边下边播，简单分片缓存。提供视频加载进度、播放进度、缓冲进度、播放错误处理、seek操作等回调接口。<br><img src="https://ae01.alicdn.com/kf/HTB1QsjHShTpK1RjSZR0762EwXXa8.png" alt=""></p><h1 id="使用-AVAssetResourceLoader-实现边下边播"><a href="#使用-AVAssetResourceLoader-实现边下边播" class="headerlink" title="使用 AVAssetResourceLoader 实现边下边播"></a>使用 AVAssetResourceLoader 实现边下边播</h1><p>AVPlayer 是支持直接从一个 url 下载并播放视频的：</p><pre><code class="Swift">let urlAssrt = AVURLAsset(url: URL(string: mediaUrl))let playerItem = AVPlayerItem(asset: urlAssrt)let player = AVPlayer(playerItem: playerItem)</code></pre><p>但 AVPlayer 没有提供方法给我们直接获取它下载下来的数据，无法对下载过程进行干预控制如seek操作，也不支持分片缓存。AVAssetResourceLoader 通过委托对象去调节 AVURLAsset 所需要的加载资源，包括获取 AVPlayer 需要的数据信息、决定传递多少数据给 AVPlayer 等，可操作的自由度更高，因此最终采用这种方式实现。各层级关系如下：<br><img src="https://ae01.alicdn.com/kf/HTB1Ou0MRMHqK1RjSZJn762NLpXap.png" alt=""></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><strong>AVAssetResourceLoader 仅在 AVURLAsset 不知道如何去加载这个 URL 资源时才会被调用</strong>，因此在初始化 AVURLAsset 的时候需要把目标视频URL地址的scheme替换为系统不能识别的scheme (这一点很重要！)， AVAssetResourceLoader 将 AVAssetResourceLoadingRequest 传给 AVAssetResourceLoaderDelegate, 我们先保存这些请求，然后通过 URLSession 自己构建下载任务。每次收到响应后把数据填充给 AVAssetResourceLoadingRequest, 并对数据进行缓存，就完成了边下边播，流程如图:<br><img src="https://ae01.alicdn.com/kf/HTB11vhNRNTpK1RjSZFM762G_VXau.png" alt=""></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="必要的配置：自定义-URLScheme-来创建-AVPlayerItem"><a href="#必要的配置：自定义-URLScheme-来创建-AVPlayerItem" class="headerlink" title="必要的配置：自定义 URLScheme 来创建 AVPlayerItem"></a>必要的配置：自定义 URLScheme 来创建 AVPlayerItem</h3><pre><code class="Swift">var component = URLComponents(url: originalURL, resolvingAgainstBaseURL: true)!component.scheme = &quot;Stream&quot;let urlAssrt = AVURLAsset(url: component.url!)urlAssrt.resourceLoader.setDelegate(videoResourceLoaderDelegate, queue: videoResourceLoaderDelegate.resourceLoaderQueue)playerItem = AVPlayerItem(asset: urlAssrt)</code></pre><h3 id="实现-AVAssetResourceLoaderDelegate-协议"><a href="#实现-AVAssetResourceLoaderDelegate-协议" class="headerlink" title="实现 AVAssetResourceLoaderDelegate 协议"></a>实现 AVAssetResourceLoaderDelegate 协议</h3><p>两个必须实现的方法：</p><pre><code class="Swift">func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -&gt; Bool </code></pre><p><strong>要求加载资源的代理方法</strong>，返回 true 表示该代理类现在可以处理该请求，我们需要在这里保存 loadingRequest 并开启下载数据的任务，下载回调中拿到响应数据后再对 loadingRequest 进行填充。</p><pre><code class="Swift">func resourceLoader(_ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest: AVAssetResourceLoadingRequest)</code></pre><p><strong>AVAssetResourceLoader 取消了本次请求</strong>，此时我们需要把该 loadingRequest 移出下载任务的回调列表（停止填充）。<br>具体实现：</p><pre><code class="Swift">public func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -&gt; Bool {    // 启动下载任务，同时保留loadingRequest, progress 是 URLSession 响应数据的回调处理    VideoDownloadManager.shared.startDownload(url: originalURL, loadingRequest: loadingRequest, progress: { [weak self] (loadingRequest, task) in        if nil  == self {            return        }        self!.resourceLoaderQueue.async { [weak self] in            if nil  == self {                return            }            // 数据填充操作，具体实现见后文            let isFinish = self!.respondData(loadingRequest: loadingRequest!, data: task.cachedData, dataOffset: 0, contentLength: task.contentLength, mimeType: &quot;video/mp4&quot;)            if isFinish {                // loadingRequest 填充结束，需要从该下载任务的回调列表中移除                task.removeCallback(by: loadingRequest!)            }        }    }, complete: {  _,_  in    }, observer: self)    return true}</code></pre><h3 id="视频下载任务管理（简单分块）"><a href="#视频下载任务管理（简单分块）" class="headerlink" title="视频下载任务管理（简单分块）"></a>视频下载任务管理（简单分块）</h3><pre><code class="Swift">    /// 启动下载任务    func startDownload(url: URL, loadingRequest: AVAssetResourceLoadingRequest?, progress: VideoDownloadProgressHandler?, complete: VideoDownloadCompleteHandler?, observer: VideoResourceLoader? = nil) {        // 已经存在任务（同一视频源由一个下载任务管理）        if let task = urlTasks[url] {            if let loadingRequest = loadingRequest {                // 添加回调                if let callback = VideoDownloadCallback(loadingRequest: loadingRequest, progress: progress, complete: complete) {                    task.addCallback(callback)                }                // 添加观察者                if let observer = observer {                    let weakObject = WeakObject&lt;VideoResourceLoader&gt;(target: observer)                    task.addObsever(weakObject)                }                // 回调上层（上一个 loadingRequest 填充完后 task 可能还有剩余数据，先填充）                if let progress = progress {                    progress(loadingRequest, task)                }            }        } else { // 创建新任务            // 框架支持部分缓存，当视频还未缓冲完 playerItem 即被销毁时，将本次已下载数据缓存起来            // 新的 task 先异步载入缓存再继续下载，从而实现“断点续传”            VideoCacheManager.shared.asynLoadCache(url: url) { (data, contentLength) in                let cacheLength = (data != nil) ? data!.count : 0                let isFullCache = (cacheLength &gt; 0 &amp;&amp; data!.count == contentLength!)                // 创建下载任务                 let request = self.createURLRequest(url: url, loadingRequest: (isFullCache ? nil : loadingRequest), cacheLength: cacheLength)                let dataTask = self.session.dataTask(with: request)                let newTask = VideoDownloadTask(url: url, dataTask: dataTask)                // 添加回调                if let callback = VideoDownloadCallback(loadingRequest: loadingRequest, progress: progress, complete: complete) {                    newTask.addCallback(callback)                }                // 添加观察者                if let observer = observer {                    // 注意：newTask 维护一个 observers 数组，对每个 observer 都是强引用                    // 避免内存泄漏，使用一个弱引用对象容器封装                    let weakObject = WeakObject&lt;VideoResourceLoader&gt;(target: observer)                    newTask.addObsever(weakObject)                }                // 填充缓存的数据                if let data = data {                    newTask.contentLength = contentLength!                    newTask.appendData(data)                    // 回调上层                    if let loadingRequest = loadingRequest, let progress = progress {                        progress(loadingRequest, newTask)                    }                }                self.urlTasks[url] = newTask                // 任务启动                if !isFullCache {                    dataTask.resume()                }            }        }    }    /// 创建下载URL请求    private func createURLRequest(url: URL, loadingRequest: AVAssetResourceLoadingRequest?, cacheLength: Int) -&gt; URLRequest {        var request = URLRequest(url: url)        request.cachePolicy = .reloadIgnoringLocalCacheData        // 设置Range, 如果有部分本地缓存，将缓存终点作为本次请求起点        if let dataRequest = loadingRequest?.dataRequest {            let requestedOffset = (cacheLength &gt; 0 ? Int64(cacheLength) : dataRequest.requestedOffset)            request.addValue(&quot;bytes=\(requestedOffset)-&quot;, forHTTPHeaderField: &quot;Range&quot;)        }        return request    }    /// 从响应请求头中获取视频文件总长度 contentLength    public func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&gt; Void) {        if let downloadTask = downloadTask(for: dataTask) {            guard response.mimeType == &quot;video/mp4&quot; else {                return            }            // 请求头有两个字段需要关注            // Content-Length表示本次请求的数据长度            // Content-Range表示本次请求的数据在总媒体文件中的位置，格式是start-end/total，因此Content-Length = end - start + 1            if let contentRange = (response as! HTTPURLResponse).allHeaderFields[&quot;Content-Range&quot;] as? String {                let contentLengthString = contentRange.split(separator: &quot;/&quot;).map{String($0)}.last!                downloadTask.contentLength = Int(contentLengthString)!            } else {                downloadTask.contentLength = Int(response.expectedContentLength)            }        }        completionHandler(.allow)    }    /// 收到响应数据的处理    public func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {        if let downloadTask = downloadTask(for: dataTask) {            // 在已下载数据基础上填充            downloadTask.appendData(data)            let callbacks = downloadTask.callbacks            for callback in callbacks {                if let progress = callback.progressHandler {                    progress(callback.loadingRequest, downloadTask)                }            }        }    }</code></pre><h3 id="把请求返回数据输出到-loadingRequest-VideoDownloadProgressHandler"><a href="#把请求返回数据输出到-loadingRequest-VideoDownloadProgressHandler" class="headerlink" title="把请求返回数据输出到 loadingRequest (VideoDownloadProgressHandler)"></a>把请求返回数据输出到 loadingRequest (VideoDownloadProgressHandler)</h3><p>这一步主要是根据 URLRequest 下载数据和 loadingRequest 请求数据的范围，计算填充的起始和结束位置，并判断是否结束填充。</p><pre><code class="Swift">    private func respondData(loadingRequest: AVAssetResourceLoadingRequest, data: Data, dataOffset: Int, contentLength: Int, mimeType: String) -&gt; Bool {        if loadingRequest.isCancelled || loadingRequest.isFinished {            return false        }        // 填充信息        if let contentInformationRequest = loadingRequest.contentInformationRequest {            let contentType =  UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, mimeType as CFString, nil)?.takeRetainedValue()            contentInformationRequest.contentType = contentType as String?            contentInformationRequest.isByteRangeAccessSupported = true            contentInformationRequest.contentLength = Int64(contentLength)        }        // 填充数据        if let dataRequest = loadingRequest.dataRequest {            guard dataRequest.currentOffset &gt;= dataOffset &amp;&amp; dataRequest.currentOffset &lt; dataOffset.advanced(by: data.count) else {                return false // 没有可用数据            }            // 可用cache长度            let availableCacheLength = dataOffset.advanced(by: data.count).advanced(by: Int(-dataRequest.currentOffset))            // 待填充数据长度            let requestedEndIndex = (dataRequest.requestsAllDataToEndOfResource ? contentLength : Int(dataRequest.requestedOffset.advanced(by: dataRequest.requestedLength)))            let unreadLength = requestedEndIndex.advanced(by: Int(-dataRequest.currentOffset))            // 填充数据长度            let respondDataLength = min(availableCacheLength, Int(unreadLength))            // 计算填充数据的起点和终点，进行填充            let beginIndex = dataRequest.currentOffset.advanced(by: -dataOffset)            let endIndex = beginIndex.advanced(by: respondDataLength)            let respondData = data.subdata(in: Int(beginIndex)..&lt;Int(endIndex))            dataRequest.respond(with: respondData)            // 判断是否结束            if dataRequest.currentOffset &gt;= dataRequest.requestedOffset.advanced(by: dataRequest.requestedLength) {                loadingRequest.finishLoading()                return true            }        }        return false    }</code></pre><p>下图可直观地表示上述代码的流程。直线表示完整的视频，直线下方是 VideoDownloadTask 的下载进度，直线上方是某一次 loadingRequest 的填充过程。通过比较 <strong>可用 cache 长度（availableCacheLength）</strong> 和 <strong>待填充数据长度（unreadLength）</strong> 可确定本次所取data的范围。包含两种情况，图1表示 availableCacheLength &gt; unreadLength, 取部分 data 填充，并调用<code>loadingRequest.finishLoading()</code>结束该loadingRequest. <strong>这一步是必需的，不然可能没有继续的请求了。</strong><br><img src="https://ae01.alicdn.com/kf/HTB1D7yLShTpK1RjSZR0762EwXXaz.png" alt=""><br>图2表示 availableCacheLength &lt; unreadLength, data 全部填充，并等待新的响应数据（didReceive data）.<br><img src="https://ae01.alicdn.com/kf/HTB1LR_dShjaK1RjSZKz760VwXXax.png" alt=""><br>如果请求遇到错误、或者请求被取消我们也需要作响应处理， 从 urlTasks 移除下载任务（移除之前先检查任务是否还有其他观察者）、中断 URLRequest、保存视频缓存。</p><h3 id="视频缓存管理"><a href="#视频缓存管理" class="headerlink" title="视频缓存管理"></a>视频缓存管理</h3><p>FileManager 可以帮助我们方便地建立视频缓存管理器。统一保存在 caches/videos/, 以 url md5 值作为文件名。如果是完整视频，后缀为.mp4, 否则当临时文件缓存.tmp:</p><pre><code class="Swift">/// 视频目录// /var/mobile/Containers/Data/Application/B78CD5EE-540B-4C6E-8B49-47EE148881AE/Library/Caches/videosstatic var videoDirectory: String = FileManager.cachesPath.appendingPathComponent(&quot;videos&quot;)/// 视频文件名(url md5值)static func videoFileName(url: URL) -&gt; String {    return url.absoluteString.md5String}/// 视频完整文件路径    static func videoFilePath(url: URL) -&gt; String {    let videoName = videoFileName(url: url)    return videoDirectory.appendingPathComponent(videoName) + &quot;.mp4&quot;}/// 视频临时文件路径static func tmpFilePath(url: URL) -&gt; String {    let videoName = videoFileName(url: url)    return videoDirectory.appendingPathComponent(videoName) + &quot;.tmp&quot;}</code></pre><p>VideoCacheManager 需要提供视频缓存保存和异步载入的逻辑：</p><pre><code class="Swift">    /// 保存视频缓存    func storeCache(with downloadTask: VideoDownloadTask, completion: (() -&gt; Void)?) {        ioQueue.async {            if !FileManager.default.fileExists(atPath: VideoCacheManager.videoDirectory) {                do {                    try FileManager.default.createDirectory(atPath: VideoCacheManager.videoDirectory, withIntermediateDirectories: true, attributes: nil)                } catch {                    print(&quot;Video|cache&quot;, &quot;create video Directory error:\(error)&quot;)                }            }            let url = downloadTask.url            let tmpFile = VideoCacheManager.tmpFilePath(url: url)            // 保存完整视频            let data = downloadTask.cachedData            let contentLength = downloadTask.contentLength            let isFinished = (data.count == contentLength)            if isFinished {                let file = VideoCacheManager.videoFilePath(url: url)                do {                    try data.write(to: URL(fileURLWithPath: file))                } catch {                    print(&quot;Video|cache&quot;, &quot;store video error:\(error)&quot;)                }                if FileManager.default.fileExists(atPath: tmpFile) {                    do  {                        try FileManager.default.removeItem(atPath: tmpFile)                    } catch {                        print(&quot;Video|cache&quot;, &quot;remove video tmp file error:\(error)&quot;)                    }                }            } else { // 保存临时视频信息                let tmpInfo = [kDataKey: data, kContentLengthKey: contentLength] as [String : Any]                let success = NSKeyedArchiver.archiveRootObject(tmpInfo, toFile: tmpFile)                if !success {                    print(&quot;Video|cache&quot;, &quot;store video tmp file error&quot;)                }            }            completion?()        }    }</code></pre><p>至此一个支持简单分片、边下边播的视频缓存框架便完成了。「简单分片」的原因是暂不支持进度条seek操作。data 缓存一直是从0开始，这次缓存0-x%, 下次便从 x 处接着下载。支持seek的一个思路：</p><ol><li>seek 到已下载填充部分，直接 seek 成功；</li><li>seek 到未下载部分，如下载进度60%, seek至70%, 则取消现有的 URLSessionDataTask 并删除已缓存数据, 创建新的 URLRequest 设置<code>Range</code>为70%, 请求和填充数据范围70%-100%. 事实上 AVPlayer 对 loadingRequest 也是这么处理的， seek 之后旧的 loadingRequest 会被 cancel, 创建新的 loadingRequest, dataRequest.requestedOffset 也会变成 seek 处的值；</li><li>若此时又 seek 到40%, 则新建任务下载范围是 40%-100%. 开始新的下载后，由于文件不完整，下载完的数据不再保存。</li></ol><h1 id="AVPlayer-一级封装"><a href="#AVPlayer-一级封装" class="headerlink" title="AVPlayer 一级封装"></a>AVPlayer 一级封装</h1><p>AVPlayer 需要手动实现播放逻辑，用法都大同小异。先使用 AVPlayerItem 实例初始化 AVPlayer, 然后使用 AVPlayer 实例初始化 AVPlayerLayer 实例，接着需要添加几类监听：</p><h2 id="kvo-监听-playerItem-加载和缓冲状态"><a href="#kvo-监听-playerItem-加载和缓冲状态" class="headerlink" title="kvo 监听 playerItem 加载和缓冲状态"></a>kvo 监听 playerItem 加载和缓冲状态</h2><pre><code class="Swift">func addObserver(to playerItem: AVPlayerItem?) {    if playerItem != nil {        //监控视频加载状态        playerItem?.addObserver(self, forKeyPath: &quot;status&quot;, options: .new, context: nil)        //监控网络加载情况        playerItem?.addObserver(self, forKeyPath: &quot;loadedTimeRanges&quot;, options: .new, context: nil)        //正在缓冲        playerItem?.addObserver(self, forKeyPath: &quot;playbackBufferEmpty&quot;, options: .new, context: nil)        //缓冲结束，可无延迟播放        playerItem?.addObserver(self, forKeyPath: &quot;playbackLikelyToKeepUp&quot;, options: .new, context: nil)    }}</code></pre><h2 id="播放进度监控"><a href="#播放进度监控" class="headerlink" title="播放进度监控"></a>播放进度监控</h2><pre><code class="Swift">func addProgressObserver() {    //这里设置每秒执行一次    let interval = CMTime(value: 1, timescale: 1)    playTimeObserverToken = player?.addPeriodicTimeObserver(forInterval: interval, queue: DispatchQueue.main, using: { [weak self] time in        guard let `self` = self else {            return        }        self.currentPlayTime = CMTimeGetSeconds(time)        // 自定义行为，更新播放进度条等...    })}</code></pre><h2 id="播放完成、错误通知"><a href="#播放完成、错误通知" class="headerlink" title="播放完成、错误通知"></a>播放完成、错误通知</h2><pre><code class="Swift">func addNotification() {    //给 playerItem 添加播放完成通知    NotificationCenter.default.addObserver(self, selector: #selector(self.playbackFinished(_:)), name: .AVPlayerItemDidPlayToEndTime, object: player?.currentItem)    //给 playerItem 添加播放错误通知    NotificationCenter.default.addObserver(self, selector: #selector(self.playbackFail(_:)), name: .AVPlayerItemFailedToPlayToEndTime, object: player?.currentItem)}</code></pre><h2 id="外部环境通知"><a href="#外部环境通知" class="headerlink" title="外部环境通知"></a>外部环境通知</h2><pre><code class="Swift">//app进入后台NotificationCenter.default.addObserver(self, selector: #selector(appResignActive(_:)), name: UIApplication.willResignActiveNotification, object: nil)//app进入前台NotificationCenter.default.addObserver(self, selector: #selector(appBecomeActive(_:)), name: UIApplication.didBecomeActiveNotification, object: nil)// 监听耳机插入和拔掉通知NotificationCenter.default.addObserver(self, selector: #selector(audioRouteChangeListenerCallback(_:)), name: AVAudioSession.routeChangeNotification, object: nil)//中断处理(播放过程中有打电话等系统事件)NotificationCenter.default.addObserver(self, selector: #selector(handleInterruption(_:)), name: AVAudioSession.interruptionNotification, object: nil)// 通过 AVAudioSession 设置自己的APP是否和其他APP音频同时存在，是否会被静音键或锁屏键静音等AVAudioSession.sharedInstance().setCategory(AVAudioSession.Category.playback /*允许后台*/, options: .mixWithOthers /*混合播放，不独占*/)</code></pre><p>以上基本实现了通过 AVPlayer 控制并监听视频播放进度，代码开源在 Github. 包括边下边播的缓存逻辑，并提供了一个通用播放器 ZLAVPlayer, 将视频加载状态、播放进度、缓冲进度、播放错误、seek等操作通过闭包或代理的方式对外提供回调，你可以对 ZLAVPlayer 进行二级封装，自定义播放暂停按钮、进度条、加载动画等UI元素，只需要在 init 的时候提供视频 url 和实现各个回调。 </p><pre><code class="Swift">var zlAVPlayer = ZLAVPlayer(withURL: url,    process: { [weak self] (player, progress) in     print(&quot;当前播放进度：\(progress), 当前播放时间：\(player.currentPlayTime).&quot;)    }, compelete: { (player) in        print(&quot;播放结束.&quot;)    }, loadStatus: { (player, status) in        if status == .readyToPlay {            print(&quot;加载状态：准备完毕，可以播放。视频总时长：\(player.totalTime).&quot;)        } else if status == .unknown {            print(&quot;加载状态：未知状态，此时不能播放.&quot;)        } else if status == .failed {            print(&quot;加载状态：加载失败，网络或者服务器出现问题：\(player.playerItem.error).&quot;)        }    }, bufferPercent: {  (player, bufferPercent) in        print(&quot;缓冲进度: \(bufferPercent).&quot;)    }, willSeek: { (player, curtPos, toPos) in        print(&quot;即将seek.&quot;)        player.setSeek(to: toPos)    }, seekComplete: { (player, prePos, curtPos) in        print(&quot;seek 结束.&quot;)    }, buffering: { (player) in        print(&quot;可用缓冲耗尽，将停止播放.&quot;)        player.pause()    }, bufferFinish: { (player) in        print(&quot;可无延迟播放.&quot;)        player.play()    }, error: { (player, error) in        print(&quot;播放出错: \(error).&quot;)})</code></pre><h1 id="使用问题记录"><a href="#使用问题记录" class="headerlink" title="使用问题记录"></a>使用问题记录</h1><h2 id="AVPlayer-最佳实践"><a href="#AVPlayer-最佳实践" class="headerlink" title="AVPlayer 最佳实践"></a>AVPlayer 最佳实践</h2><p>首次创建 player 实例一般按照以下步骤：</p><pre><code class="Swift">// 1. 初始化AVAssetlet asset = AVURLAsset(url: url)// 2. 根据AVAsset初始化AVPlayerItemlet playerItem = AVPlayerItem(asset: asset)// 3. 根据AVPlayerItem初始化AVPlayerlet player = AVPlayer(playerItem: playerItem)// 4. 绑定AVPlayer至AVPlayerLayer，显示内容。let playerLayer = AVPlayerLayer(player: player)</code></pre><p>第3步执行时，由于 player 没有绑定到layer，此时系统只会准备音频相关的资源。到第4步执行时，系统会把之前准备好的音频资源重置，重新绑定音视频资源。这里会有一定程度的资源消耗，系统需要重新绑定音视频管线，造成播放首帧变慢。<br>因此更推荐以下步骤：</p><pre><code class="Swift">// 1. 初始化AVAssetlet asset = AVURLAsset(url: url)// 2. 根据AVAsset初始化AVPlayerItemlet playerItem = AVPlayerItem(asset: asset)// 3. 直接初始化AVPlayerlet player = AVPlayer()// 4. 绑定AVPlayer至AVPlayerLayer，让系统提前准备好视频渲染管线let playerLayer = AVPlayerLayer(player: player) // 5. 最后输入playerItem，开始视频播放player.replaceCurrentItemWithPlayerItem(playerItem)</code></pre><p>可以看出两段代码只是简单地调整了播放器初始化的流程，却可以让系统在播放时节省初始化的时间。<br>为加快首帧播放，可以提前配置好 AVPlayer 和 AVPlayerItem, 但只是配置，不需要初始化相关依赖。提前将 AVPlayerLayer 连接到 AVPlayer 上，最后再通过<code>replaceCurrentItem(with: playerItem)</code>, 将 player 与 item 绑定起来，开始视频播放。</p><h2 id="获取视频播放总时间，playerItem-duration-返回nan"><a href="#获取视频播放总时间，playerItem-duration-返回nan" class="headerlink" title="获取视频播放总时间，playerItem.duration 返回nan"></a>获取视频播放总时间，playerItem.duration 返回nan</h2><p><code>CMTimeGetSeconds(playerItem.duration)</code>有时返回nan, 导致算不出进度条总长度，这可能是 AVPlayerItem 的一个bug, 改为<code>CMTimeGetSeconds(playerItem.asset.duration)</code>后没有再出现过这个问题。<br>另外系统加载视频资源是异步的，可能创建一个 playeritem 后，立马去访问视频相关的属性如时长等，会是一个错误的值，要等到 playeritem.status == .readyToPlay 后再取。</p><h2 id="播放错误处理"><a href="#播放错误处理" class="headerlink" title="播放错误处理"></a>播放错误处理</h2><p>通常是 URLSessionTask 下载过程出错，缓存框架本身有容错处理： 保存已下载数据，中断URLRequest, <code>urlTasks</code> remove 本次任务。反映到上层就是kvo playerItem.status 返回<code>AVPlayerItem.Status.failed</code>, 错误原因可以通过 <code>playerItem.error</code>查看。首先设置 retryCount, 超过重试次数提示用户加载错误： </p><ul><li>如果是常见错误码如网络问题<code>NSURLErrorNotConnectedToInternet</code>/<code>NSURLErrorCannotFindHost</code>, resetVideo, 调用 player.seekTo 会重启新的 loadingRequest, 从而重新创建 VideoDownloadTask. </li><li>其他错误则 resrtPlayer, 直接重新初始化 player.</li></ul><h2 id="开始播放的时机"><a href="#开始播放的时机" class="headerlink" title="开始播放的时机"></a>开始播放的时机</h2><p>通常大家会在收到 playeritem.status == .readyToPlay 后立即播放，可能会导致开始播放时黑屏/花屏一下，原因是下载数据还不够，导致卡顿和解码异常，影响播放体验。控制播放/暂停逻辑最好结合<code>playbackBufferEmpty</code>和<code>playbackLikelyToKeepUp</code>这两个属性, 当监听到<code>playbackLikelyToKeepUp</code>, 表明现在 avplayer 可以无延迟播放，此时再play().</p><h2 id="UITableView-视频列表"><a href="#UITableView-视频列表" class="headerlink" title="UITableView 视频列表"></a>UITableView 视频列表</h2><p>AVPlayer播放单个视频并没有太大的性能问题，但在 tableView 中滚动时，自动切换和播放视频容易造成滑动卡顿，使用时注意几个问题：</p><ol><li><strong>AVPlayer 渲染通道是有上限的。</strong> 之前 tableviewCell 没有复用时，发现超过18个视频后，后续的 avplayer 都无法播放了，<code>playeritem.error</code>返回<code>Code=-11839  Cannot Decode.</code> 这是由于 AVPlayer 通道创建过多，被 AVFoundation 限制解码。当调用代码<code>player = AVPlayer(playerItem: playerItem)</code>即创建了一条“渲染通道”，AVFoundation 对这样的 AVPayer 实例是有个数限制的，上限值不定，和iOS 硬件/系统相关。所以要尽可能减少 player 个数，cell重用是基本款。<a href="https://stackoverflow.com/questions/8608570/avplayeritem-fails-with-avstatusfailed-and-error-code-cannot-decode" target="_blank" rel="noopener">参考这个问题</a></li><li>使用<code>player = AVPlayer(playerItem: playerItem)</code>新建一个 AVPayer, 或者使用<code>player.replaceCurrentItem(with: playerItem)</code>切换播放源都是比较耗时的操作，之前在每个<code>cellForRow..</code> 刷新数据时执行，滑动可见肉眼卡顿，经 Instruments 排查，<code>replaceCurrentItem(with: playerItem)</code> 会花费 30ms 左右, 从而造成 UI 线程阻塞。网上一些资料讲到 <strong>「该方法在切换视频时底层会调用信号量等待」</strong> 导致当前线程卡顿，因此尝试将该方法放到子线程执行，卡顿问题有缓解，但引出一些播放异常问题（下一条）。<br>重新思考下，列表滑动过程中是不需要播视频的，我们通常是滑动停止后，自动播放位于顶部或中间的视频，或者由用户点击触发。<strong>player 可以此时再切换视频源</strong>，滑动过程中<code>cellForRow..</code>只需展示视频封面等静态元素。缺点是每个视频首次加载时间略有延长，不过相比滑动时的卡顿，视频开始播放前的缓冲是容易接受的。</li><li>将<code>replaceCurrentItem(with:)</code>放到子线程后，由于播放无法及时响应，较高频率会出现滑动结束后，待播放 playerItem 一直加载失败，或者视频有声音开始播，但画面一直是黑色的等现象。查看<a href="https://developer.apple.com/documentation/avfoundation/avplayer" target="_blank" rel="noopener">苹果文档</a>，注册和取消kvo的操作都应放到主线程，因为 AVFoundation 强制在主线程触发<code>observeValue(forKeyPath:of:change:context:)</code>,  因此 playerItem 的初始化、<code>replaceCurrentItem(with: playerItem)</code>, 以及kvo相关、<code>addPeriodicTimeObserver</code>都统一在主线程调用，避免出现状态不同步的情况。</li></ol>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> AVFoundation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全面的 iOS 客户端网络诊断方案</title>
      <link href="/2019/04/22/ios-network-diagnosis/"/>
      <url>/2019/04/22/ios-network-diagnosis/</url>
      <content type="html"><![CDATA[<p>终端开发经常遇到需要排查 APP 网络状况的场景，例如可能由于某些地区网络运营商的问题，导致客户端某些功能不正常；或者用户自己网络的问题导致无法正常使用我们的后台服务。对此本文提供一套全面的客户端网络诊断方案。<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前的做法非常麻烦：</p><ol><li>用户反馈某一功能异常；</li><li>客服联系该用户；</li><li>客服指导该用户手机上下载网络诊断软件；</li><li>按情况 ping 某域名、traceroute 某域名；</li><li>让用户截图把信息发回来，转交给开发人员分析。</li></ol><p>现在在 App 内集成网络诊断功能，用户只需要点击一次，应用内分析出网络情况生成日志文本，之后可以选择微信分享或者直接上传到开发者后台。如视频所示：</p><iframe height="498" width="510" src="https://player.youku.com/embed/XNDA4NDQ0MzU1Mg==" frameborder="0" 'allowfullscreen'=""></iframe><h1 id="1-检查本地网络环境信息"><a href="#1-检查本地网络环境信息" class="headerlink" title="1. 检查本地网络环境信息"></a>1. 检查本地网络环境信息</h1><p>检查当前是否联网、联网类型、SIM卡网络运营商等基础信息有两种方法：</p><h2 id="通过-statusBar-的网络-subview"><a href="#通过-statusBar-的网络-subview" class="headerlink" title="通过 statusBar 的网络 subview"></a>通过 statusBar 的网络 subview</h2><p>这种方法的前提是必须保证状态栏不隐藏。</p><pre><code class="objective-c">//网络类型typedef enum {    NETWORK_TYPE_NONE = 0,    NETWORK_TYPE_2G = 1,    NETWORK_TYPE_3G = 2,    NETWORK_TYPE_4G = 3,    NETWORK_TYPE_5G = 4,      NETWORK_TYPE_WIFI = 5,} NETWORK_TYPE;+ (NETWORK_TYPE)getNetworkTypeFromStatusBar{    UIApplication *app = [UIApplication sharedApplication];    NETWORK_TYPE nettype = NETWORK_TYPE_NONE;    //iOS11    if ([[app valueForKeyPath:@&quot;_statusBar&quot;] isKindOfClass:NSClassFromString(@&quot;UIStatusBar_Modern&quot;)]) {        NSArray *views = [[[[app valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews];        for (UIView *view in views) {            for (id child in view.subviews) {                //wifi                if ([child isKindOfClass:NSClassFromString(@&quot;_UIStatusBarWifiSignalView&quot;)]) {                    nettype = NETWORK_TYPE_WIFI;                }                //2G 3G 4G                if ([child isKindOfClass:NSClassFromString(@&quot;_UIStatusBarStringView&quot;)]) {                    if ([[child valueForKey:@&quot;_originalText&quot;] containsString:@&quot;2G&quot;]) {                        nettype = NETWORK_TYPE_2G;                    } else if ([[child valueForKey:@&quot;_originalText&quot;] containsString:@&quot;3G&quot;]) {                        nettype = NETWORK_TYPE_3G;                    } else if ([[child valueForKey:@&quot;_originalText&quot;] containsString:@&quot;4G&quot;]) {                        nettype = NETWORK_TYPE_4G;                    }                }            }        }    } else {        NSArray *subviews = [[[[UIApplication sharedApplication] valueForKey:@&quot;statusBar&quot;]                              valueForKey:@&quot;foregroundView&quot;] subviews];        NSNumber *dataNetworkItemView = nil;        for (id subview in subviews) {            if ([subview isKindOfClass:[NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;) class]]) {                dataNetworkItemView = subview;                break;            }        }        NSNumber *num = [dataNetworkItemView valueForKey:@&quot;dataNetworkType&quot;];        nettype = [num intValue];    }   return nettype;}</code></pre><h2 id="通过-CTTelephonyNetworkInfo"><a href="#通过-CTTelephonyNetworkInfo" class="headerlink" title="通过 CTTelephonyNetworkInfo"></a>通过 CTTelephonyNetworkInfo</h2><p>这个类是 iOS7 以后才出现的，需要导入<a href="https://developer.apple.com/documentation/coretelephony" target="_blank" rel="noopener">CoreTelephony.framework</a>, 用来获取手机的运营商信息和简单的通话信息。</p><pre><code class="Swift">let ctNetworkInfo = CTTelephonyNetworkInfo()    /// 当前蜂窝网络类型    public func cellularType() -&gt; CellularType {        switch  ctNetworkInfo.currentRadioAccessTechnology {        case CTRadioAccessTechnologyEdge, CTRadioAccessTechnologyGPRS, CTRadioAccessTechnologyCDMA1x:            return ._2G        case CTRadioAccessTechnologyHSDPA, CTRadioAccessTechnologyWCDMA, CTRadioAccessTechnologyHSUPA, CTRadioAccessTechnologyCDMAEVDORev0, CTRadioAccessTechnologyCDMAEVDORevA, CTRadioAccessTechnologyCDMAEVDORevB, CTRadioAccessTechnologyeHRPD:            return ._3G        case CTRadioAccessTechnologyLTE:            return ._4G        default:            return .unknow        }    }    /// 移动运营商类型    public func mobileCarrierType() -&gt; CarrierType {        let carrier = ctNetworkInfo.subscriberCellularProvider        guard let MCC = carrier?.mobileCountryCode, let MNC = carrier?.mobileNetworkCode else {            return .unknow        }        switch Int(MCC) {        case 460:            do { //CN                switch Int(MNC) {                case 0, 2, 7, 8:    return .chinaMobile                case 1, 6, 9:       return .chinaUnicom                case 3, 5, 11:      return .chinaTelecom                case 20:            return .chinaTietong                default:            return .unknow                }            }        case 454:            do {//HK                switch Int(MNC) {                case 12, 13:    return .chinaMobileHK                case 7:         return .chinaUnicomHK                default:        return .otherHK                }            }        default: return .unknow        }    }    /// 移动运营商名称    public func mobileCarrierName() -&gt; String {        if let carrier = ctNetworkInfo.subscriberCellularProvider {            if let name = carrier.carrierName {                return name            }        }        return &quot;unknow&quot;    }</code></pre><p>获取系统 WiFi 的相关信息则可以通过系统 sdk 的<code>CaptiveNetwork</code>类：</p><pre><code class="Swift">// MARK: - WIFIextension NetworkDetector {    /// 获取WIFI信息    private func supportedInterfacesNetworkInfo() -&gt; [String: Any]? {        guard let interfaceList = CNCopySupportedInterfaces() as? [String] else {            return nil        }        for interface in interfaceList {            if let networkInfo = CNCopyCurrentNetworkInfo(interface as CFString) as? [String: Any],                let _ = networkInfo[kCNNetworkInfoKeySSID as String] {                return networkInfo            }        }        return nil    }    /// WIFI名称    public func SSID(_ networkInfo: [String: Any]? = nil) -&gt; String? {        if let info = (networkInfo ?? supportedInterfacesNetworkInfo()) {            return info[kCNNetworkInfoKeySSID as String] as? String        }        return nil    }    /// WIFI Mac地址    public func BSSID(_ networkInfo: [String: Any]? = nil) -&gt; String? {        if let info = (networkInfo ?? supportedInterfacesNetworkInfo()) {            return info[kCNNetworkInfoKeyBSSID as String] as? String        }        return nil    }}</code></pre><p>获取 iOS 设备的ip地址，这方面网上文章很多了，<a href="https://blog.csdn.net/luoshengkim/article/details/51135063" target="_blank" rel="noopener">参考这里</a>。</p><h1 id="2-检查后台可用性"><a href="#2-检查后台可用性" class="headerlink" title="2. 检查后台可用性"></a>2. 检查后台可用性</h1><p>这一步主要通过 TCP 连接测试目标地址的可用性与连通性。首先给出域名转ip的方法（支持 ipv4 和 ipv6）。</p><pre><code class="Obj-c">/*! * 通过hostname获取ip列表 DNS解析地址 */+ (NSArray *)getDNSsWithDormain:(NSString *)hostName{    NSMutableArray *result = [[NSMutableArray alloc] init];    NSArray *IPV4DNSs = [self getIPV4DNSWithHostName:hostName];    if (IPV4DNSs &amp;&amp; IPV4DNSs.count &gt; 0) {        [result addObjectsFromArray:IPV4DNSs];    }    //由于在IPV6环境下不能用IPV4的地址进行连接监测    //所以只返回IPV6的服务器DNS地址    NSArray *IPV6DNSs = [self getIPV6DNSWithHostName:hostName];    if (IPV6DNSs &amp;&amp; IPV6DNSs.count &gt; 0) {        [result removeAllObjects];        [result addObjectsFromArray:IPV6DNSs];    }    return [NSArray arrayWithArray:result];}+ (NSArray *)getIPV4DNSWithHostName:(NSString *)hostName{    const char *hostN = [hostName UTF8String];    struct hostent *phot;    @try {        phot = gethostbyname(hostN);    } @catch (NSException *exception) {        return nil;    }    NSMutableArray *result = [[NSMutableArray alloc] init];    int j = 0;    while (phot &amp;&amp; phot-&gt;h_addr_list &amp;&amp; phot-&gt;h_addr_list[j]) {        struct in_addr ip_addr;        memcpy(&amp;ip_addr, phot-&gt;h_addr_list[j], 4);        char ip[20] = {0};        inet_ntop(AF_INET, &amp;ip_addr, ip, sizeof(ip));        NSString *strIPAddress = [NSString stringWithUTF8String:ip];        [result addObject:strIPAddress];        j++;    }    return [NSArray arrayWithArray:result];}+ (NSArray *)getIPV6DNSWithHostName:(NSString *)hostName{    const char *hostN = [hostName UTF8String];    struct hostent *phot;    @try {        /**         * 只有在IPV6的网络下才会有返回值         */        phot = gethostbyname2(hostN, AF_INET6);    } @catch (NSException *exception) {        return nil;    }    NSMutableArray *result = [[NSMutableArray alloc] init];    int j = 0;    while (phot &amp;&amp; phot-&gt;h_addr_list &amp;&amp; phot-&gt;h_addr_list[j]) {        struct in6_addr ip6_addr;        memcpy(&amp;ip6_addr, phot-&gt;h_addr_list[j], sizeof(struct in6_addr));        NSString *strIPAddress = [self formatIPV6Address: ip6_addr];        [result addObject:strIPAddress];        j++;    }    return [NSArray arrayWithArray:result];}</code></pre><p>iOS 实现 socket 编程可以使用<code>CFNetwork</code>, 是基于<code>CFSocket</code>等接口的上层封装，<code>ASIHttpRequest</code>就工作在这一层。不过<code>CFNetwork</code>用起来依旧比较复杂。用的较多的是谷歌封装的一个IM框架<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>, 它给 Mac 和 iOS 提供了易于使用的、强大的异步套接字库，向上封装出简单易用的OC接口。省去了我们面向 Socket 以及数据流 Stream 等繁琐复杂的编程，而且支持TCP或者UDP协议，支持IPv4和IPv6。<br><a href="https://github.com/zltunes/NetworkDetector/blob/master/GCDSocketEngine.swift" target="_blank" rel="noopener">这里</a>提供一个封装好的 Engine 类，调用方实现 protocol 方法即可。另外支持发送心跳包，用于IM、自建推送等长连接场景。</p><h1 id="3-测试长连接"><a href="#3-测试长连接" class="headerlink" title="3. 测试长连接"></a>3. 测试长连接</h1><p>长连接的实现方式，一种是上面的基于 tcp 的长连接，客户端通常用这种。web的场景则有 http keep-alive 和 websocket 两种。</p><h2 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h2><p>长连接需要保持心跳，因为国内移动无线网络运营商在链路上一段时间内没有数据通讯后, 会淘汰NAT表中的对应项, 造成链路中断。而国内的运营商一般NAT超时的时间为5分钟，所以通常我们心跳设置的时间间隔为3-5分钟。<br>每次发送心跳包之前记录时间，在回调<code>didRead data:</code>中计算本次心跳包发起到收到的耗时。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><code>keep-alive</code>和<code>webSocket</code>这两种长连接有什么区别呢？<br>在 HTTP1.0 中，一次 TCP 连接只能完成1个 HTTP 请求，一个Request 一个Response, 这次HTTP请求就结束了。HTTP1.1中进行了改进，keep-alive connection 允许<strong>在一次 TCP 连接中完成多个 HTTP 请求</strong>，但因为局限较多，这种仍被称作是<strong>伪.长连接</strong>，原因如下：</p><ol><li>遵循 Request = Response, 在 HTTP 中永远是一一对应的；</li><li>对每个请求仍然要单独发 Header, 信息交换效率很低；</li><li>Response 永远是被动的，不能主动发起。</li></ol><p>传统HTTP客户端与服务器请求响应模式如下图所示：<br><img src="https://mccdn.qcloud.com/static/img/c99efde0caccb49814ea83c126b0e18a/image.jpg" alt=""><br>WebSocket 可以看成是 HTTP 协议为了支持长连接所打的一个大补丁，它借用了HTTP的协议来完成一部分握手，但握手成功后就完全按照Websocket协议进行了，相比 keep-alive 建立的是<strong>真.长连接</strong>：</p><ol><li>通过第一个 HTTP request 建立 TCP 连接之后，之后的交换数据都不需要再发 HTTP request 了，提高信息交换效率；</li><li>被动性。服务端可以主动推送信息给客户端。</li></ol><p>WebSocket模式客户端与服务器请求响应模式如下图：<br><img src="https://mccdn.qcloud.com/static/img/e4128e588c6c21216319351ee7eb0bac/image.jpg" alt=""></p><p>iOS 平台常用的一个 WebSocket 框架<a href="https://github.com/daltoniam/Starscream" target="_blank" rel="noopener">Starscream</a>, 用法与 CocoaAsyncSocket 类似，建立连接后定时向后台写入一段字符串来做心跳检验。</p><h1 id="4-Ping-域名测试"><a href="#4-Ping-域名测试" class="headerlink" title="4. Ping 域名测试"></a>4. Ping 域名测试</h1><p>ping 程序是对两台主机之间<strong>连通性</strong>进行测试的基本工具，基于 ICMP 协议，ICMP 协议定义了一组错误信息，当路由器或者主机无法成功处理一个 IP 封包的时候，能够将错误信息回送给来源主机。<br>苹果官方有封装 ping 功能的库<a href="https://developer.apple.com/library/archive/samplecode/SimplePing/Introduction/Intro.html#//apple_ref/doc/uid/DTS10000716" target="_blank" rel="noopener">SimplePing</a>, 支持 iPv4 和 iPv6。SimplePing 流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/656644-555fbc9fd4a0b461.png?imageMogr2/auto-orient/" alt=""><br>用起来也非常简单：</p><pre><code class="Objc">    // 1. 利用 HostName 创建 SimplePing 对象    SimplePing *pinger = [[SimplePing alloc] initWithHostName:@&quot;www.apple.com&quot;];    self.pinger = pinger;    // 2. 指定 IP 地址类型    if (isIpv4 &amp;&amp; !isIpv6) {        pinger.addressStyle = SimplePingAddressStyleICMPv4;    }else if (isIpv6 &amp;&amp; !isIpv4) {        pinger.addressStyle = SimplePingAddressStyleICMPv6;    }    // 3. 设置 delegate,用于接收回调信息    pinger.delegate = self;    // 4. 开始 ping    [pinger start];</code></pre><p>需要注意的是，<strong>delegate 中的一系列回调方法将在对象调用 start 方法所在的线程对应的 runloop 中以 NSDefaultRunLoopMode 执行</strong>，因此为保证接收到回调我们需要加以下 do…while 代码使 ping 程序在当前线程一直执行。</p><pre><code class="Objc">_sendCount = 1;do {    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];} while (self.pinger != nil || _sendCount &lt;= MAXCOUNT_PING);</code></pre><p>得到最后一个 ping 结果后将 pinger 置为 nil, 或 _sendCount 达到最大值，从而结束 while 循环。</p><pre><code class="Objc">self.pinger = nil;_sendCount = MAXCOUNT_PING + 1;</code></pre><p>提供一个封装好的<a href="https://github.com/zltunes/NetworkDetector/tree/master/NetPing" target="_blank" rel="noopener">NetPing</a>类，通过模拟 shell 命令 ping 的过程，监控目标主机是否连通，并通过解析 ICMP 包，输出每次 ping 的域名ip、数据大小、icmp_seq、time 等信息，从而完整展示 ping 的结果。每个域名连续执行五次，因为每次的速度不一致，可以观察其平均速度来判断网络情况。</p><pre><code class="c">Ping: www.qq.com 64 bytes from 182.254.34.74: icmp_seq=0 type=ICMPv4TypeEchoReply time=22.996 ms64 bytes from 182.254.34.74: icmp_seq=1 type=ICMPv4TypeEchoReply time=36.688 ms64 bytes from 182.254.34.74: icmp_seq=2 type=ICMPv4TypeEchoReply time=25.390 ms64 bytes from 182.254.34.74: icmp_seq=3 type=ICMPv4TypeEchoReply time=25.516 ms64 bytes from 182.254.34.74: icmp_seq=4 type=ICMPv4TypeEchoReply time=28.377 ms</code></pre><p>在发送 ping 数据时为什么初始化一个<code>NSTimer</code>?, 因为如果 ping 失败，也就是发送的测试报文成功，但一直没收到响应的报文，此时却不会有任何的回调方法告知我们，因此加一个 timer 进行<strong>延时判断</strong>。如果3s内无 response 则输出 timeout, 并主动重试（当 ping 次数未超限）。 如果是在 delegate 回调中触发了 <code>sendPing</code>（ping命令发生错误、发送ping数据失败、成功接收到 PingResponse 数据、接收到错误的 PingResponse 数据），则会及时将 timer 关掉。</p><pre><code class="objc">/* * 发送Ping数据，pinger会组装一个ICMP控制报文的数据发送过去 * */- (void)sendPing{    if (timer) {        [timer invalidate];    }    if (_sendCount &gt; MAXCOUNT_PING) {        _sendCount++;        self.pinger = nil;        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(netPingDidEnd)]) {            [self.delegate netPingDidEnd];        }    }    else {        assert(self.pinger != nil);        _sendCount++;        _startTime = [NetTimer getMicroSeconds];        if (_isLargePing) {            NSString *testStr = @&quot;&quot;;            for (int i=0; i&lt;408; i++) {                testStr = [testStr stringByAppendingString:@&quot;abcdefghi &quot;];            }            testStr = [testStr stringByAppendingString:@&quot;abcdefgh&quot;];            NSData *data = [testStr dataUsingEncoding:NSASCIIStringEncoding];            [self.pinger sendPingWithData:data];        } else {            [self.pinger sendPingWithData:nil];        }        timer = [NSTimer scheduledTimerWithTimeInterval:3.0                                                 target:self                                               selector:@selector(pingTimeout:)                                               userInfo:[NSNumber numberWithInt:_sendCount]                                                repeats:NO];    }}- (void)pingTimeout:(NSTimer *)index{    if ([[index userInfo] intValue] == _sendCount &amp;&amp; _sendCount &lt;= MAXCOUNT_PING + 1 &amp;&amp;        _sendCount &gt; 1) {        NSString *timeoutLog =            [NSString stringWithFormat:@&quot;ping: cannot resolve %@: TimeOut&quot;, _hostAddress];        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(appendPingLog:)]) {            [self.delegate appendPingLog:timeoutLog];        }        [self sendPing];    }}</code></pre><h1 id="5-Traceroute-测试"><a href="#5-Traceroute-测试" class="headerlink" title="5. Traceroute 测试"></a>5. Traceroute 测试</h1><p>与 Ping 一样，Traceroute 也是基于 ICMP 协议的常规网络分析工具。数据从主机发送到目标服务器要经过层层路由转发，Traceroute 用来侦测到目的主机之间所经路由。带 -R 参数的 ping 命令也可以记录路由过程，但是因为 IP 数据报头的长度限制(最多能保存9个IP地址)，ping 不能完全的记录下所经过的路由器，traceroute 正好就填补了这个缺憾。工作原理很简单：</p><ol><li>发送一份 TTL == 1 的 IP 数据报给目的主机，经过第一个路由器时，TTL 值被减为 0，则第一个路由器丢弃该数据报，并返回一份 <strong>ICMP超时报文</strong>，于此得到了路径中第一个路由器的地址；</li><li>再发送一份 TTL 值为 2 的数据报，便可得到第二个路由器的地址；</li><li>以此类推，一直到到达目的主机为止，这样便记录下了路径上所有的路由 IP。</li></ol><h2 id="基于-UDP-实现"><a href="#基于-UDP-实现" class="headerlink" title="基于 UDP 实现"></a>基于 UDP 实现</h2><p>我们如何知道数据报何时到达目的主机呢？在基于UDP的方案中，traceroute 使用了一个大于30000的端口号，服务器在收到这个数据包的时候会返回一个<strong>端口不可达</strong>的ICMP错误信息，客户端通过判断收到的错误信息是TTL超时还是端口不可达来判断数据包是否到达目标主机。Linux 和 MacOS 平台上的 traceroute 都是基于该原理实现的。然而使用过程中会发现这种方法并不太靠谱。TTL增加到一定大小后就拿不到返回的数据包了，也无法知道什么时候到达目的主机。<br><img src="/pic/007i4MEmgy1g0ng36vh5xj30wi0kagn1.jpg" alt=""><br>原因可以看下<a href="https://www.cnblogs.com/beyond_dxb/p/8383821.html" target="_blank" rel="noopener">这篇文章</a>的分析：</p><blockquote><p>使用 UDP 的 traceroute，失败还是比较常见的。这常常是由于，在运营商的路由器上，UDP与ICMP的待遇大不相同。为了利于troubleshooting，ICMP ECHO Request/Reply 是不会封的，而UDP则不同。UDP常被用来做网络攻击，因为UDP无需连接，因而没有任何状态约束它，比较方便攻击者伪造源IP、伪造目的端口发送任意多的UDP包，长度自定义。所以运营商为安全考虑，对于UDP端口常常采用白名单ACL，就是只有ACL允许的端口才可以通过，没有明确允许的则统统丢弃。比如允许DNS/DHCP/SNMP等。</p></blockquote><p>目前网上许多开源的iOS traceroute库基本都是UDP的方案，使用起来并不靠谱，为此实现一套基于 ICMP 的方案。</p><h2 id="基于-ICMP-实现"><a href="#基于-ICMP-实现" class="headerlink" title="基于 ICMP 实现"></a>基于 ICMP 实现</h2><p>详细代码见<a href="https://github.com/zltunes/NetworkDetector/tree/master/Traceroute" target="_blank" rel="noopener">这里</a>。整体流程如下：</p><pre><code class="c">// 1. 创建套接字int send_sock = socket(remoteAddr-&gt;sa_family, SOCK_DGRAM, isIPv6 ? IPPROTO_ICMPV6 : IPPROTO_ICMP);// 2. 最多尝试30跳int ttl = 1;bool finished = false; // 是否抵达目标主机while(ttl &lt;= 30 &amp;&amp; !finished) {    // 3. 设置TTL，下一跳TTL递增    setsockopt(sock, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl));    ++ttl;    // 4. 构建icmp报文    packetData = makeICMPPacket(...);    // 5. 连续发送3个ICMP报文，记录往返时长    for (0...3) {        // 6. 发送icmp报文        sendto(...);        // 7. 接收icmp数据        ssize_t resultLen = recvfrom(...);        if (resultLen &gt;= 0) {            // 8. 解析数据包            ICMPPacket *packet = unpack(...);            if (icmp_timeout) {                // 到达中间节点            } else if (icmp_EchoReply &amp;&amp; ip == 目标主机ip) {                // 到达目标服务器，traceroute 结束            } else {                // 失败            }        }    }}</code></pre><p>从伪代码看出，关键在于如何创建和发送ICMP数据，以及如何从接收到的ip数据包中解析ICMP。</p><h3 id="ICMP-数据创建"><a href="#ICMP-数据创建" class="headerlink" title="ICMP 数据创建"></a>ICMP 数据创建</h3><p><img src="/pic/007i4MEmgy1g0ni5cyvx2j320s0kqjzi.jpg" alt=""><br>图为<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">ICMP数据结构</a>，据此定义 ICMPPacket 数据结构：</p><pre><code class="c">typedef struct ICMPPacket {    uint8_t     type; // 类型    uint8_t     code; // 类型代码    uint16_t    checksum; // 校验码    uint16_t    identifier; // ID    uint16_t    sequenceNumber; // 序列号    // data...} ICMPPacket;</code></pre><p>ICMPv4TypeEchoRequest 类型=8，代码=0，创建好 ICMP 报文直接发送就可以了，系统会自动加上IP头部。</p><h3 id="ICMP-数据解析"><a href="#ICMP-数据解析" class="headerlink" title="ICMP 数据解析"></a>ICMP 数据解析</h3><p><img src="/pic/007iUjdily1g0nih9sjz1j31ja0v0dpf.jpg" alt=""></p><pre><code class="c">typedef struct IPv4Header {    uint8_t versionAndHeaderLength; // 版本和首部长度    uint8_t serviceType;    uint16_t totalLength;     uint16_t identifier;    uint16_t flagsAndFragmentOffset;    uint8_t timeToLive;    uint8_t protocol; // 协议类型，1表示ICMP    uint16_t checksum;    uint8_t sourceAddress[4];    uint8_t destAddress[4];    // options...    // data...} IPv4Header;</code></pre><p>根据ip数据包结构的关键字段，我们可以获取到 ICMP 数据包，再根据上面的<code>类型</code>字段判断是<code>CMPv4TypeTimeOut</code>(11) 还是<br><code>ICMPv4TypeEchoReply</code>(0)，从而得知当前所处路由位置。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>以 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 为例，比较两种方案的 traceroute 结果，<br><img src="/pic/007i4MEmgy1g0niyv0o02j314u0uujxk.jpg" alt=""><br><img src="/pic/007i4MEmgy1g0niy2cnrmj315o0o6dm0.jpg" alt=""><br>UDP 方案从ttl==13之后都不再收到服务器返回，也无法得知什么时候到达baidu, ICMP 则完整地输出路由表。<br>两种方案都会出现某一跳显示星号的情况，代表那一跳路由器隐藏了自己位置。并不是所有网关都会如实返回ICMP超时报文。出于安全性考虑，大多数防火墙以及启用了防火墙功能的路由器缺省配置为<strong>不返回各种ICMP报文</strong>，因此traceroute程序不一定能拿到所有的沿途网关地址。<br>总结一下：</p><ol><li>UDP模式：UDP探测数据包（目标端口大于30000） -&gt; 中间网关发回 ICMP TTL Timout -&gt; 目标主机发回 ICMP Destination Unreachable</li><li>ICMP模式：ICMPEchoRequest 探测数据包 -&gt; 中间网关发回 ICMP TTL Timout -&gt; 目标主机发回 ICMPEchoReply </li></ol><h1 id="6-文件下载测试"><a href="#6-文件下载测试" class="headerlink" title="6. 文件下载测试"></a>6. 文件下载测试</h1><p><a href="https://github.com/zltunes/NetworkDetector/blob/master/SimpleDownloadEngine.swift" target="_blank" rel="noopener">这里</a>提供一个基于 URLSession 实现的简单的下载器，在下载成功的回调中计算文件下载速度，网上相关教程很多，不赘述了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，开发者诊断 iOS APP 网络状况所需要的功能基本都包括了，该工具完整诊断结果如下：</p><pre><code class="json">Step1:-------------&gt; 检查当前网络 &lt;---------------当前是否联网：已联网当前联网类型：wifiSSID：Tencent-StaffWiFi当前本机IP: 10.70.75.98本地网关: fe80:c::本地DNS: 10.11.10.12, 10.6.210.85, 10.14.12.239Step2:-------------&gt; 检查后台可用性 &lt;---------------Server: nggws.starrobot.qq.com,port:443isConnected: true, isAvailable: trueServer: nggws.starrobot.qq.com,port:80isConnected: true, isAvailable: true域名转IP: 14.17.41.219Server: nggws.robot.qq.com,port:443isConnected: true, isAvailable: trueServer: nggws.robot.qq.com,port:80isConnected: true, isAvailable: true域名转IP: 183.61.51.41Server: qdtts.qq.com,port:443isConnected: true, isAvailable: trueServer: qdtts.qq.com,port:80isConnected: true, isAvailable: true域名转IP: 58.60.9.100Server: yingyongbao.soundai.cn,port:443isConnected: true, isAvailable: true域名转IP: 182.61.53.149Step3:-------------&gt; TestWebSocket &lt;---------------wss://nggws.starrobot.qq.com:443, 连接成功心跳包[1]发起到收到耗时：10ms心跳包[2]发起到收到耗时：25ms心跳包[3]发起到收到耗时：12msws://nggws.starrobot.qq.com:80, 连接成功心跳包[1]发起到收到耗时：17ms心跳包[2]发起到收到耗时：16ms心跳包[3]发起到收到耗时：11mswss://nggws.robot.qq.com:443, 连接成功心跳包[1]发起到收到耗时：14ms心跳包[2]发起到收到耗时：13ms心跳包[3]发起到收到耗时：15msws://nggws.robot.qq.com:80, 连接成功心跳包[1]发起到收到耗时：11ms心跳包[2]发起到收到耗时：13ms心跳包[3]发起到收到耗时：18msStep4:---------------&gt; PING域名测试 &lt;---------------PING: [    nggws.starrobot.qq.com    ]64 bytes from 14.17.41.219 icmp_seq=#0 time=14ms64 bytes from 14.17.41.219 icmp_seq=#1 time=5ms64 bytes from 14.17.41.219 icmp_seq=#2 time=14ms64 bytes from 14.17.41.219 icmp_seq=#3 time=4ms64 bytes from 14.17.41.219 icmp_seq=#4 time=8msPING: [    nggws.robot.qq.com    ]64 bytes from 183.61.51.41 icmp_seq=#0 time=11ms64 bytes from 183.61.51.41 icmp_seq=#1 time=7ms64 bytes from 183.61.51.41 icmp_seq=#2 time=10ms64 bytes from 183.61.51.41 icmp_seq=#3 time=12ms64 bytes from 183.61.51.41 icmp_seq=#4 time=11msPING: [    qdtts.qq.com    ]64 bytes from 58.60.9.100 icmp_seq=#0 time=7ms64 bytes from 58.60.9.100 icmp_seq=#1 time=8ms64 bytes from 58.60.9.100 icmp_seq=#2 time=5ms64 bytes from 58.60.9.100 icmp_seq=#3 time=9ms64 bytes from 58.60.9.100 icmp_seq=#4 time=6msPING: [    yingyongbao.soundai.cn    ]64 bytes from 182.61.53.149 icmp_seq=#0 time=13ms64 bytes from 182.61.53.149 icmp_seq=#1 time=18ms64 bytes from 182.61.53.149 icmp_seq=#2 time=17ms64 bytes from 182.61.53.149 icmp_seq=#3 time=16ms64 bytes from 182.61.53.149 icmp_seq=#4 time=18msPING: [    www.baidu.com    ]64 bytes from 14.215.177.39 icmp_seq=#0 time=11ms64 bytes from 14.215.177.39 icmp_seq=#1 time=9ms64 bytes from 14.215.177.39 icmp_seq=#2 time=11ms64 bytes from 14.215.177.39 icmp_seq=#3 time=16ms64 bytes from 14.215.177.39 icmp_seq=#4 time=10msStep5:---------------&gt; traceroute 测试 &lt;---------------开始traceroute...1   10.70.75.2        5.86ms    3.17ms    8.69ms  2   10.14.61.41       3.94ms    7.24ms    5.30ms  3   10.14.60.30       9.65ms    2.92ms    9.28ms  4   10.14.61.60       3.01ms    3.72ms    6.01ms  5   14.17.22.1        6.59ms    9.81ms    4.17ms  6   10.200.102.1      4.57ms    4.17ms    6.41ms  7   ***********       ----ms    ----ms    ----ms  8   14.17.0.97        14.05ms   8.24ms    5.05ms  9   119.147.220.157   9.93ms    5.11ms    4.47ms  10  113.96.4.118      18.49ms   14.68ms   9.45ms  11  219.135.96.86     58.19ms   -----ms   22.62ms 12  14.29.117.238     12.20ms   8.35ms    -----ms 13  ***********       -----ms   -----ms   -----ms 14  14.215.177.38     10.80ms   7.38ms    8.88ms  Step6.1:--------&gt; 文件下载测试[http] &lt;--------下载成功：19KB, 速度：54.11KB/S, 总耗时：356msStep6.2:--------&gt; 文件下载测试[https] &lt;--------下载成功：19KB, 速度：47.33KB/S, 总耗时：407msStep7:----&gt; 网络诊断结束，点[复制]按钮发送给客服，谢谢 &lt;----</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>客户端数据埋点方案优化</title>
      <link href="/2019/04/21/app-statistics-report/"/>
      <url>/2019/04/21/app-statistics-report/</url>
      <content type="html"><![CDATA[<p>“埋点”就是在应用中增加监控点，由客户端记录上报给服务端。作为大部分 APP 必不可少的功能模块，可以帮助我们获取用户行为数据（时间、操作）、应用质量数据（加载情况、错误异常）、产品运营数据（PV/UV、转化率/留存率）等，甚至在一些场景中和收入计算直接挂钩。本文记录一下对某 APP 埋点上报方案的改进过程。<br><a id="more"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前的上报系统把所有日志归为两类：</p><ol><li>实时上报：产生一条日志即触发一次请求，用于一些对时效性、准确性要求高的场景，如APP的下载、安装完成日志。</li><li>非实时上报：日志产生时先存入db, 上报触发条件有<ul><li>终端日志累计超过1000条</li><li>APP 连续运行超过3小时</li><li>APP 重新启动</li></ul></li></ol><p>在 APP 规模较小时可以满足业务需求，随着页面越来越复杂，功能模块越来越多，出现以下问题：</p><ol><li>实时上报请求太频繁，比如切换到某tab, 或者 listview 滑动一下即有10+条请求发送，导致客户端网络交互太多。</li><li>非实时上报导致数据延后，使统计报表产生误差，分析用户行为的时候不够准确，终端的页面曝光日志不够及时，导致活跃数据与后台统计出来的相差很大。</li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="细化日志等级，灵活触发条件"><a href="#细化日志等级，灵活触发条件" class="headerlink" title="细化日志等级，灵活触发条件"></a>细化日志等级，灵活触发条件</h2><p>针对“实时太频繁，非实时延迟大”的问题，由于目前只有实时和非实时2个等级，划分粒度太粗。我们引入更多的日志上报级别，<strong>日志的级别主要用来区分日志的重要性</strong>。越重要的日志，上报的实时性越强，触发上报的条件越宽松；越不重要的日志，上报的实时性越弱，触发上报的条件越严格。打个比方，如果实时上报是1，非实时上报是0，我们可以在 0 和 1 之间引入0.1，0.2，0.3等等。<br>日志上报的触发条件分为2个维度控制：<strong>日志积累时间</strong>，<strong>日志积累条数</strong>。只要满足两个条件之一，就算满足了触发条件。例如：<br><img src="/pic/app-statistics-report-1.jpg" alt=""><br>这里将上报日志划分成5个级别。<br>级别1是实时上报，无需条件触发。级别2在 WiFi 网络下当日志积累条数超过10条，或者日志积累时间超过600s就会上报，<strong>为避免网络状况不好时导致延时过大，流量环境下的上报触发条件相对宽松。</strong> 级别3表示上报条件比2更严格些。101级别表示此级别的日志永远不会上报到后台。102级别表示延迟上报，和旧有的非实时上报含义相同。<br>每条日志的等级由日志类型来决定，<strong>每一个日志类型都会被映射到一个唯一的日志级别。</strong> 二者的映射关系保存在后台。此外，每个日志级别对应的触发条件也交由后台配置。最终客户端只需知道各个业务点的日志类型即可，日志 level 可以是数量不定的，所有的日志都根据后台配置来决定上报时机，甚至不再上报。<br><img src="/pic/app-statistics-report-4.jpg" alt=""></p><h2 id="提高上报准确性"><a href="#提高上报准确性" class="headerlink" title="提高上报准确性"></a>提高上报准确性</h2><p>上报系统要尽量避免出现漏报、多报的情况。<br>级别2和3理论上可能导致数据的延迟和丢失。比如积累到一定量，但是没有到触发条件时候，客户端异常退出，会导致数据的丢失。为了保证客户端异常情况下日志不丢失，<strong>对优先级较高的日志在生成的时候就异步存入DB，上报成功后再删除掉</strong>。实时上报失败的日志存入 DB 转为延迟上报等待触发。<br>针对延迟上报的日志，客户端启动/触发间隔为m时间的定时任务，每次上报n条db里的数据。其中m、n后台可配置。<strong>但这一步要考虑与级别2/3同时触发的情况，避免同一数据重复上报。</strong></p><h1 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h1><h2 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h2><p>行为日志如何唯一标示一个view？有很多方案，比如<a href="https://neyoufan.github.io/2017/04/19/ios/%E7%BD%91%E6%98%93HubbleData%E6%97%A0%E5%9F%8B%E7%82%B9SDK%E5%9C%A8iOS%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">网易HubbleData</a><strong>使用每个view的 viewPath 作为唯一id</strong>：获取每个控件自身的ID、类名、Resource Id以及位于所属父组件的Index等特征信息，并逐级向上遍历找到根节点。iOS 的话可以使用<code>ViewController_UIControlClassName_action_target_UIControlProperty</code>来确定唯一key.<br>也可以简单一点像下面，为每个页面设置唯一的场景值 <code>sceneID</code>, 然后页面内划分不同模块<code>moduleID</code>, 接着划分更小一级为槽位<code>slotID</code>,  当点击某槽位进入二级页面，这里的 <code>sceneID-moduleID-slotID</code>就作为下一级页面内上报日志的<code>sourceScene-souceModule-sourceSlot</code>, 从而可以追溯日志源头，统计点击率等信息。<br><img src="/pic/app-statistics-report-3.jpg" alt=""><br>除了唯一ID外，上报信息经常需要包括一些业务数据如APP相关信息（应用市场）、视频信息（视频类APP）等。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://pic.superbed.cn/item/5cad7ba23a213b0417f8dd19" alt=""></p><ol><li>日志系统对外提供统一的上报接口</li></ol><pre><code class="Java">    /**     * 需要传入日志类型和结构，不同类型日志有不同的优先级     * @param logType 仅仅支持 LogTypeEnum 枚举的值，其他的值全部不做任何处理     * @param logStruct 上报结构，所有类型日志统一继承自 LogStruct, 这里传具体子类进去     */    public static void report(final byte logType, final LogStruct logStruct){        //TODO    }</code></pre><ol start="2"><li>日志分发器是整个上报系统的中枢，它是一个单例对象，持有一个日志处理器队列，可以根据日志优先级创建或调度不同的处理器，并在这些处理器创建时提供与<code>LogTriggerItem</code>相应的定时器。为节省性能，所有的日志处理都使用一个单独的工作线程统一处理。<br>分发器需要监听系统前后台切换事件，从前台切换到后台需要上报所有处理器中的缓存日志。重新进入前台需要重置定时器。</li><li>每个 Processor 的主要结构有：<ul><li>readySendToNetQueue: 缓存待发送日志</li><li>readyWriteToDBQueue: 缓存待存入 DB 中的数据</li><li>reportTriggerItem: 上报触发条件</li><li>reportAlarm: 定时器，定期检查 trigger 条件是否满足</li><li>writeToDBHandler:启用一个 handler 专门用于写DB</li></ul></li><li>Processor 工作流程如下：<br><img src="https://pic.superbed.cn/item/5cadb48f3a213b0417fb9167" alt=""></li></ol><h1 id="埋点方案的讨论（iOS平台）"><a href="#埋点方案的讨论（iOS平台）" class="headerlink" title="埋点方案的讨论（iOS平台）"></a>埋点方案的讨论（iOS平台）</h1><p>上面讲的APP使用的还是传统「代码埋点」的方式，客户端接入该上报sdk, 然后在业务各处调用Api. 优点是灵活度高，精确对齐产品所需数据，避免太多的无用上报。缺点也很明显，数据上报和业务强相关，上报数据有误，就需要发版本修复。另外上报代码遍地开花，影响代码整洁。现在业界普遍都在朝“无痕埋点上报”的方向改进。</p><h2 id="无痕埋点上报"><a href="#无痕埋点上报" class="headerlink" title="无痕埋点上报"></a>无痕埋点上报</h2><p>其实就是自动上报，达到了触发条件就会上报，和业务解耦，无需在业务的各处调用API，也不用针对每个版本的新需求专门做数据上报。缺点也有，无效上报过多，上报数据量大，业界做法各种各样，介绍通用的两种：</p><ol><li>hook 系统的UIKit，在所有的UI控件响应点击事件的时候自动采集数据。</li><li>在项目中抽象出UI控件的基类，重写 click 函数，插桩数据上报的代码。</li></ol><h3 id="方法1：MethodSwizzle"><a href="#方法1：MethodSwizzle" class="headerlink" title="方法1：MethodSwizzle"></a>方法1：MethodSwizzle</h3><p>由于业务场景的统计需要大部分为点击和曝光，综合起来需要对以下UI控件进行Method Swizzling. 包括<code>UIButton</code>, <code>UIGestureRecognizer</code>, <code>UISwitch</code>, 自定义的<code>UIControl</code>, 列表点击<code>UITableView</code>, <code>UICollectionView</code>, 各类弹框<code>UIAlertView</code>. 对每一个需要hook的系统控件都增加一个category, 然后重写<code>+ (void)load</code>函数。hook的处理方法和时机多种。以 UIButton 为例，我们需要hook的方法是：</p><pre><code class="Objective-C">- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event;</code></pre><p>新增一个方法</p><pre><code class="Objective-C">- (void)stSendActionWithAutoTrace:(SEL)action to:(id)target forEvent:(UIEvent *)event</code></pre><p>然后swizzle. <code>stSendActionWithAutoTrace</code>需要调用原来的业务实现，然后再加上数据上报的插桩代码。<br><code>UIGestureRecognizer</code>比较特殊，我们无法得知其响应函数，因为手势的触发依赖于系统的响应链，系统暴露给我们的接口是初始化函数<code>initWithTarget:action:</code>, 我们选择hook该函数，但需要考虑这么做带来的影响，比如系统私有view addGesture 在初始化<code>UIGestureRecognizer</code>对象的时候，像文本输入框的粘贴复制菜单，WebView/ScrollView 的点击事件, 弹框 AlertView 的点击等无用上报都需要过滤。<br>虽然我们hook的是手势初始化函数，但真正需要swizzle的是其手势回调，因此在动态运行时增加一个 swizzle 函数，其函数名规格为<code>targetclass+selector</code>, 这样将所有的手势回调函数收归到一起。需要注意一点：<strong>运行时增加swizzle函数时需要判断手势回调的参数个数</strong>, 因为项目中多人开发可能存在不同写法：<code>-（void)didTapOnView:(UIGestureRecognizer gesture)</code> 或者无参数<code>-（void） didTapOnView</code> 等。<br>此外还要考虑继承问题，如果子类继承并重写了父类的<code>didTapOnView</code>方法，并在实现中先调用了<code>[super didTapOnView]</code>, 那么在运行时添加的swizzle函数实现中将会收到两次消息导致多次上报，需要特殊处理。</p><h3 id="方法2：基类继承"><a href="#方法2：基类继承" class="headerlink" title="方法2：基类继承"></a>方法2：基类继承</h3><p>method swizzling的方法，比较底层，对系统调用伤筋动骨，对 UIKit 依赖比较强，系统如果有更改又需要同步跟进。另外 method swizzling 这种黑魔法使用不多，不熟悉的东西自然埋坑多。相比之下基类继承的方法是更容易应用的。<br>对<code>UIButton</code>等UI控件抽象<code>BaseButton</code>, 重写</p><pre><code class="Objective-C">- (void)sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event</code></pre><p>在里面加入上报插桩代码，项目中的 UIButton 需要统一继承 BaseButton, 则所有 button 都实现了自动上报，其他控件类似。安卓更简单些，定义<code>OnNewClickListener</code>继承<code>View.OnClickListener</code>, 之后<code>view.setOnClickListener</code>都传<code>OnNewClickListener</code>类型，实现<code>onNewClick()</code>方法即可。 </p><pre><code class="Java">public abstract class OnNewClickListener implements View.OnClickListener {    @Override    public void onClick(View v) {        onNewClick(v);        STCommonInfoGC stCommonInfoGC = getStInfo();        if (null != stCommonInfoGC) {            //重新创建用于点击上报的日志            stCommonInfoGC = STInfoBuilder.buildClickSTInfo(stCommonInfoGC);            STLog.reportLog(stCommonInfoGC);        }    }    public abstract void onNewClick(View v);    public STInfoClick getStInfo() {        return null;    }}</code></pre><p>同理，将系统基类<code>UITapGestureRecognizer</code>封装成<code>BaseTapGestureRecognizer</code>, 重写<code>initWithTarget:action:</code>函数，回调函数中先调用业务的手势回调实现，再调用数据上报接口。<br>不过这种方式也有些问题，比如第三方库的控件无法替换类型；新增控件可以直接继承<code>BaseButton</code>, 如果追求全局统一，对项目中旧有控件进行修改类型的工作，成本会比较大。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>采用哪种方案还是要结合项目和产品需求，考虑到：</p><ol><li>项目规模已经比较大，修改已有控件类型不合理。</li><li>产品对view的唯一id有自己的定义和统计方法，并且和业务强相关，如同样是点击action, 普通按钮和“开始下载”“更新”按钮的点击分属不同的日志类型（等级）；另外app卡片的相关日志都需要带上 appModel 信息。</li></ol><p>因此我们的项目最终采用了<strong>代码埋点 + 轻度无痕埋点</strong> 的方案，之所以是轻度，一是只有新增控件采用新基类，二是开放日志生成接口，供各个业务方自定义。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>客户端跨平台开发技术对比</title>
      <link href="/2019/04/20/cross-platform-app/"/>
      <url>/2019/04/20/cross-platform-app/</url>
      <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5b076e3af265da0dce48fe95" target="_blank" rel="noopener">浅谈 2018 移动端跨平台开发方案</a>这篇文章基本把目前跟客户端“跨平台”搭边的技术梳理了一遍，多达数十种。不过从苹果官方支持度、实用性、使用范围来挑选，主要是这三大类：<strong>Hybrid系列、RN系列和 Flutter 系列</strong>。本文将对这三类方案作简要总结和对比。<br><a id="more"></a></p><h1 id="Hybrid-系列"><a href="#Hybrid-系列" class="headerlink" title="Hybrid 系列"></a>Hybrid 系列</h1><p><img src="/pic/007iUjdily1g0s04ojscmj30c60cq75b.jpg" alt=""><br>这种是目前使用最简单也最普遍的，主要依靠 WebView 容器展示H5页面，增加了H5可以通过 Javascript 调用的Js Api。通过这些 Js Api 可以调用 Native 的能力。iOS 已经基本由<code>WKWebView</code>替代了<code>UIWebView</code>，通过<a href="https://developer.apple.com/documentation/webkit" target="_blank" rel="noopener">WebKit</a>开放的能力可以得知网页加载情况并执行响应动作。如图为腾讯新闻小程序，正文通过 webView 展示网页，底部 TabBar 则是 Native 实现的控件。<br><img src="/pic/007i4MEmgy1g0s1gxh8c7j30910fzgov.jpg" alt=""></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>几乎可以完全继承现代Web开发的所有成果；</li><li>完全动态化、跨平台；</li><li>web开发者不需要太多的学习成本。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>WebView的渲染效率和JS执行性能不佳，跟原生体验相差太远。</li><li>Android 手机系统版本和设备厂商的定制，很难保证所在所有设备上都能提供一致的体验。</li></ol><h1 id="RN-系列"><a href="#RN-系列" class="headerlink" title="RN 系列"></a>RN 系列</h1><p><img src="/pic/007iUjdily1g0s1sgy1mzj30aw0a0wfp.jpg" alt=""><br><a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">React Native</a> 和 <a href="https://weex.incubator.apache.org/" target="_blank" rel="noopener">Weex</a> 都归为这一类。为了解决 WebView 性能差的问题，以 RN 为代表的这一类框架将最终渲染工作交还给了系统，虽然同样使用类 HTML+JS 的 UI 构建逻辑，但最终会生成对应的<strong>自定义原生控件</strong>，以充分利用原生控件相对于 WebView 更优的绘制效率。与此同时这种策略也将框架本身和App开发者绑在了系统的控件系统上，不仅框架本身需要处理大量平台相关的逻辑，随着系统版本和API的变化，开发者可能也需要处理不同平台的差异，甚至有些特性只能在部分平台上实现（比如 RN 的<code>ToastAndroid</code> 顾名思义只能在 Android 使用），这样框架的跨平台特性就会大打折扣。下面对比一下这两个框架的原理和优缺点。</p><h2 id="RN"><a href="#RN" class="headerlink" title="RN"></a>RN</h2><h3 id="站在-React-肩膀上"><a href="#站在-React-肩膀上" class="headerlink" title="站在 React 肩膀上"></a>站在 React 肩膀上</h3><p><a href="https://zh-hans.reactjs.org/" target="_blank" rel="noopener">React</a> 是一套可以用简洁的语法高效绘制 DOM 的框架，它将网页上真实的 DOM 节点，抽象为 Virtual DOM —— 一个存在于内存中的 JavaScript 对象，与 DOM 一一对应。当界面发生变化时，得益于 DOM Diff 算法能够知道 Virtual DOM 的变化，从而高效改动 DOM，避免重新绘制 DOM。<br><img src="/pic/007i4MEmgy1g0s2hh1in6j30nl0c5tat.jpg" alt=""><br>RN 其实就是<strong>Native 版本的 React</strong>, 目的是让不熟悉原生平台的前端同学利用 React 也能开发 iOS/Android App. </p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>关于RN的架构、启动流程、渲染过程，以及最核心问题 —— JS 与 Native 如何交互，可参考网上的一系列优秀文章：</p><ul><li><a href="https://github.com/sucese/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/1ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E6%BA%90%E7%A0%81%E5%88%9D%E8%AF%86.md" target="_blank" rel="noopener">ReactNative源码篇</a>（Android）</li><li><a href="http://blog.cnbang.net/tech/2698/" target="_blank" rel="noopener">React Native通信机制详解</a>（iOS）</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Learn once, write anywhere. 一致性程度有限，不少组件和API都区分了 Android 和 iOS 版本。即使是共用组件，也会有平台独享的函数。平台间的差异性导致维护成本高。</li><li>对移动端开发学习成本高，对前端开发者来说也需要对原生平台有所了解。</li><li>滑动列表性能表现不佳：<ul><li>不支持视图重用，随着 Cell 数量的增加，占用的内存也线性增加。</li><li>UITableView 是主线程同步的，为了保证 UI 流畅度，UI 的渲染需要达到60帧/秒，每帧的大致消耗时间保持在16ms之内。而RN 运行在单独线程，和UI主线程不同步，也就是从 RN Render 到真正调用 native 代码这个过程是异步的，导致从js运行到最后系统渲染的总时间很难做到&lt;16ms.</li></ul></li></ol><h2 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h2><p>Weex 使用的前端框架是<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>, 相比 React 更轻量一些。<br><img src="/pic/007i4MEmgy1g0s8yo8slzj31d40rmk3x.jpg" alt=""><br><img src="/pic/007iUjdily1g0s8yxzajej31d60r24b2.jpg" alt=""><br>更详细的原理解析可参考<a href="https://halfrost.com/weex_ios/" target="_blank" rel="noopener">Weex 是如何在 iOS 客户端上跑起来的</a></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>相比 RN 滑动列表性能好。充分利用了<code>UITableView</code>或者<code>RecycleView</code>的重用机制实现了性能的优化。</li><li>Write Once, Run Everywhere. 保持Web、Android 和 iOS 三端高度一致性。</li><li>功能扩展更灵活，一些三方库如图片、网络等可由开发者自己适配。</li></ol><p><img src="/pic/007i4MEmgy1g0s94nz1ygj31du0r4n4j.jpg" alt=""><br><img src="/pic/007iUjdily1g0s9i4fozdj312j0mcaeo.jpg" alt=""></p><h1 id="Flutter-系列"><a href="#Flutter-系列" class="headerlink" title="Flutter 系列"></a>Flutter 系列</h1><p>Flutter 通过跨平台的 Skia 图形库实现渲染引擎，所有控件都是使用 Dart 语言重新开发（Material是安卓风格的控件库，Cupertino是iOS风格的控件库），然后通过自己的渲染引擎绘制出来，不使用系统原生控件。这样可以在最大程度上保证不同平台、不同设备的体验一致性。支持AOT的Dart语言，执行效率也非常高，使得Flutter完全可以媲美原生应用的性能。<br>Flutter框架的整个架构如下：<br><img src="/pic/007iUjdily1g0veym2p5bj30mc0exdhc.jpg" alt=""></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="Hot-Reload"><a href="#Hot-Reload" class="headerlink" title="Hot Reload"></a>Hot Reload</h3><p><img src="https://flutter.io/assets/tools/android-studio/hot-reload-36252b9c05984443ea5cd1960bab0f4ca904a6dfbe71165af4ed7f1b1c037124.gif" alt=""><br>程序运行到设备上后，有任何代码修改，Save 之后立即就可以更新到界面上，只需要几百毫秒。这一功能得益于Dart 在Debug模式下使用JIT（Just-in-time, 动态编译）执行方式，触发热刷新时Flutter会检测发生改变的Dart文件，将其同步到App私有缓存目录下，DartVM加载并且修改对应的类或者方法，重建控件树后立即可以在设备上看到效果。<br><img src="/pic/007i4MEmgy1g0vfb24il6j30q80n4jut.jpg" alt=""></p><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a><a href="https://flutterchina.club/widgets-intro/" target="_blank" rel="noopener">响应式</a></h3><p>这个就是学React的，API名字也是<code>setState</code>.</p><pre><code class="Dart">class CounterState extends State&lt;Counter&gt; {  int counter = 0;  void increment() {    // 告诉Flutter state已经改变, Flutter会调用build()，更新显示    setState(() {      counter++;    });  }  Widget build(BuildContext context) {    // 当 setState 被调用时，这个方法都会重新执行.    // Flutter 对此方法做了优化，使重新执行变的很快    // 所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget    return new Row(      children: &lt;Widget&gt;[        new RaisedButton(          onPressed: increment,          child: new Text(&#39;Increment&#39;),        ),        new Text(&#39;Count: $counter&#39;),      ],    );  }}</code></pre><h3 id="支持AOT和JIT"><a href="#支持AOT和JIT" class="headerlink" title="支持AOT和JIT"></a>支持AOT和JIT</h3><p>Dart语言可以有两种编译模式：JIT和AOT。</p><ul><li>JIT模式运行效率低，但是可以支持Hot Reload，<strong>只在Debug模式下使用</strong>。</li><li>AOT模式运行效率高，<strong>在Release模式下使用</strong>。通过区分编译模式，提高正式版本中代码的运行速度。</li></ul><h3 id="Platform-Channels"><a href="#Platform-Channels" class="headerlink" title="Platform Channels"></a><a href="https://flutterchina.club/platform-channels/" target="_blank" rel="noopener">Platform Channels</a></h3><p>同样是去调用 Native Service 的 API, RN 和 Hybrid APP 都是使用 Bridge 的技术来调用。而 Flutter 提供了 Platform Channels 来让 Dart 代码和 Native Service API进行互操作。</p><pre><code class="Dart">// 获取系统电量信息的异步方法Future&lt;Null&gt; getBatteryLevel() async {  var batteryLevel = &#39;unknown&#39;;  try {    int result = await methodChannel.invokeMethod(&#39;getBatteryLevel&#39;);    batteryLevel = &#39;Battery level: $result%&#39;;  } on PlatformException {    batteryLevel = &#39;Failed to get battery level.&#39;;  }  setState(() {    _batteryLevel = batteryLevel;  });}</code></pre><p>这种方式用起来比 Bridge 简单许多，据说性能也更好。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>通过网上各种 Flutter 和 RN 的对比测试数据来看，Flutter在高低端机CPU上的流畅度、内存等表现都优于RN。除了 Flutter 团队做的各种性能优化措施外，很大程度还是二者架构方案的不同导致的。RN 最大的性能瓶颈就在于 <strong>JAVA/OC 和 JS 的 Bridge 通信上</strong>。<br>RN的实现方式都是在JS层完成DOM的对比和更新，然后跨层通信到平台，创建平台组件，然后渲染。流程较长，而且存在线程跳跃：<br><img src="/pic/007iUjdily1g0vgjf1j7wj312u0nkae6.jpg" alt=""><br>Flutter 渲染引擎和控件都是自己实现，没有使用系统控件，整个渲染流程大大缩短。而且渲染引擎是C++实现，直接调用系统Canvas绘制，没有跨层通信和线程跳跃的问题：<br><img src="/pic/007i4MEmgy1g0vg8trgi1j313a0lwn1j.jpg" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th></th><th>性能</th><th>跨端性</th><th>动态化</th></tr></thead><tbody><tr><td>Hybrid系列</td><td>低</td><td>高</td><td>高</td></tr><tr><td>RN系列</td><td>中</td><td>中</td><td>高</td></tr><tr><td>Flutter系列</td><td>高</td><td>高</td><td>低</td></tr><tr><td>原生SDK</td><td>高</td><td>低</td><td>低</td></tr></tbody></table><p>综合来讲没有十全十美的跨平台方案，每种方案在性能、跨端、动态上都有得有失。</p><ul><li>对性能要求不高的场景，如简单的app内嵌活动H5场景，基于 WebView 的 Hybrid 方案是个不错的选择，对项目无侵入，且门槛很低。</li><li>如果对动态化需求强烈，不能接受 WebView 的性能问题，RN系列是不错的方案，跨端性的问题其实Weex已经解决了。RN和Weex都有大DAU的产品在使用，社区相对成熟。</li><li>Flutter 性能和跨端都是做的最好的，缺陷在于<strong>暂不支持动态化</strong>，可能是考虑到苹果官方不允许的问题。另外语言和框架都是全新的，需要从头学。</li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
            <tag> 动态化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>区块链和比特币原理、以太坊开发</title>
      <link href="/2019/04/19/blockchain/"/>
      <url>/2019/04/19/blockchain/</url>
      <content type="html"><![CDATA[<p>2008年，网络极客中本聪提出了比特币的概念，这是一种全新的电子货币。比特币是一种去中心化的记账系统，人们通过挖矿获得比特币，通过公开记账的方式完成支付。最近几年比特币暴涨暴跌，矿机从供不应求到无人问津，许多人一夜暴富，许多人倾家荡产。伴随着比特币沉浮的还有它的底层技术 —— 区块链。<br><a id="more"></a><br>17年7月我毕业参加工作，接着见证了数字货币疯涨的半年，比特币价格在11-12月份曾一度接近 $2w 峰值，当时技术圈“言必称链”，移动互联网变成“古典互联网”，“区块链才是未来”，以太猫、百度莱茨狗，网易黑钻，各种新鲜玩意儿层出不穷。紧接着18年伴随着“经济寒冬”，各类数字货币一路暴跌甚至归零，比特币价格此刻再看只有$3813（2019/03/05）,也听不到吹捧区块链的声音了，令人唏嘘。<br>抛去投资因素，区块链从08年开始已经运行了10年，没有出现大的问题，这证明<strong>基于“创造一种不受政府或其他任何人控制的货币”的构想</strong>，区块链是可行的。本文是之前在部门内做分享所用PPT，我们可以学习下区块链是如何实现去中心化、解决交易环节中的信任和其他各种问题，作为开发者如何应用区块链技术。</p><center><embed src="/share/blockchain.pdf" width="800" height="610"></center>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTPS 协议和原理</title>
      <link href="/2019/04/18/about-https/"/>
      <url>/2019/04/18/about-https/</url>
      <content type="html"><![CDATA[<ul><li>HTTPS 的出现背景与发展趋势；</li><li>HTTPS 原理（内容加密防窃听、身份认证防冒充、数据完整防篡改）；</li><li>HTTPS 对性能的影响；</li><li>如何优化 HTTPS；</li><li>如何实现全站 HTTPS 等。<a id="more"></a><center><embed src="/share/https.pdf" width="800" height="610"></center></li></ul>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 热更新解读（一）APatch &amp; JavaScriptCore</title>
      <link href="/2019/04/17/jspatch-apatch&amp;javascriptcore/"/>
      <url>/2019/04/17/jspatch-apatch&amp;javascriptcore/</url>
      <content type="html"><![CDATA[<p>之前在手淘实习负责过百川<a href="http://baichuan.taobao.com/product/hotfix.htm?infoq=01" target="_blank" rel="noopener">Hotfix能力</a>的建设，Android 端采用阿里自研 <a href="https://mp.weixin.qq.com/s/5KjSPvUflbg0pVRIjtLiRA" target="_blank" rel="noopener">Sophix</a>，iOS 端采用 JSPatch，解读 JSPatch 前有必要先了解 Objective-C 与 JavaScript 的互相调用。<br><a id="more"></a></p><h1 id="iOS-动态更新的几种方案"><a href="#iOS-动态更新的几种方案" class="headerlink" title="iOS 动态更新的几种方案"></a>iOS 动态更新的几种方案</h1><ul><li>WebView 加载 HTML5 动态更新。</li><li>React Native/weex js 动态更新。</li><li>lua 脚本文件控制动态更新（代表框架 <a href="https://github.com/mmin18/WaxPatch" target="_blank" rel="noopener">WaxPatch</a> ）。</li><li>js 脚本文件控制动态更新（代表框架 <a href="https://github.com/bang590/JSPatch/" target="_blank" rel="noopener">JSPatch</a>）。</li><li><a href="http://blog.csdn.net/like7xiaoben/article/details/44081257" target="_blank" rel="noopener">framework 实现功能模块动态更新</a>。</li></ul><p>其中 WaxPatch 和 JSPatch 是使用较广泛的两种热修复方案。而苹果 review guideline 提到只允通过<code>JavaScriptCore.framework</code>或<code>WebKit</code>执行脚本，因此 JSPatch 是真正被 Apple 官方支持的。此外鉴于<code>JavaScript</code>比<code>lua</code>语言更亲民，使用系统内置的 <code>JavaScriptCore.framework</code>而无需内嵌lua脚本引擎来解释运行lua代码，JSPatch 便成为目前 iOS 热修复使用最多，效果也最佳的方案。</p><blockquote><p>有关上述几种热修复方案的比较可阅读这两篇文章：<br><a href="http://awhisper.github.io/2016/07/22/Weex-ReactNative-JSPatch/" target="_blank" rel="noopener">Weex &amp; ReactNative &amp; JSPatch</a><br><a href="https://blog.cnbang.net/works/2767/" target="_blank" rel="noopener">WaxPatch与JSPatch对比</a></p></blockquote><h1 id="APatch-与-JSPatch-的关系"><a href="#APatch-与-JSPatch-的关系" class="headerlink" title="APatch 与 JSPatch 的关系"></a>APatch 与 JSPatch 的关系</h1><p>JSPatch 使用时需要一个后台下发和管理脚本。阿里百川 HotFix 平台帮助开发者做了这些事。通过提供脚本托管、版本管理、脚本文件及传输过程加密等服务，让开发者无需搭建后台和关心部署操作，只需引入一个 SDK 即可直接使用 JSPatch 进行热修复。这个 SDK 就是 <a href="http://baichuan.taobao.com/docs/doc.htm?spm=a3c0d.7629140.0.0.qm0FoS&amp;treeId=234&amp;articleId=105670&amp;docType=1" target="_blank" rel="noopener">APatch（iOS）</a>。<br><img src="https://img.alicdn.com/tps/TB12.jYMVXXXXX0XFXXXXXXXXXX-611-521.png" alt=""><br>APatch 在 JSPatch 核心代码的基础上封装了向 HotFix 平台请求脚本／传输解密／脚本管理／本地调试等功能，是配合阿里百川 HotFix 平台一起使用的。</p><h1 id="APatch-工作流程"><a href="#APatch-工作流程" class="headerlink" title="APatch 工作流程"></a>APatch 工作流程</h1><p><img src="/pic/005YhI8igy1fwa5u3lronj30ot0guwg8.jpeg" alt=""><br>JSPatch 脚本执行权限很高，若被第三方篡改会<a href="http://www.ibtimes.co.uk/ios-over-1000-apps-that-use-jspatch-technology-put-users-risk-1540734" target="_blank" rel="noopener">带来很大安全问题</a>。因此 APatch 和 HotFix 平台都对安全问题考虑良多。</p><h2 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h2><p>从上图可看出，客户端从服务器下载 Patch 之前先要下载指定 Patch 配置信息即<code>PatchInfo</code>，其中包含了 Patch 文件密钥 <code>file_token</code>。<br>服务端：</p><ul><li>对 <code>file_token</code> 用 RSA 公钥加密。</li><li>对 <code>PatchInfo</code> 原始数据采用 HMacSha1 算法计算的哈希值，并将原始数据和哈希值<code>serviceToken</code>放在同一消息中传送给客户端。</li></ul><p>客户端：</p><ul><li>使用 <code>secret</code> 计算所接收数据的哈希值。</li><li>检查计算所得的 HMAC 是否与传送的 HMAC 匹配。</li><li>只有<code>PatchInfo</code>通过校验匹配后才会去下载<code>Patch</code>。</li></ul><p>另外，update patch 的接口已迁至 https，进一步保证了数据传输的安全。</p><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>本地存储的脚本被篡改的机会小很多，只在越狱机器上有点风险，对此 APatch SDK 对下载的脚本进行了AES对称加密，每次读取时：</p><ul><li>客户端使用 RSA 私钥解密 <code>PatchInfo.file_token</code> 获取 <code>key</code> 和 <code>iv</code>。</li><li>使用 <code>key</code> 和 <code>iv</code> 进行 AES 解密。</li></ul><p>解密成功后的数据存储在 <code>script</code> 中，然后会调用 JSPatch 运行js脚本的接口：</p><pre><code class="Objective-C">[JPEngine evaluateScript:script];</code></pre><p>至此，APatch 的工作已经完成，接下来具体的热修复工作就交给 JSPatch 了。</p><h1 id="JSPatch-——-基于-JavaScriptCore-framework"><a href="#JSPatch-——-基于-JavaScriptCore-framework" class="headerlink" title="JSPatch —— 基于 JavaScriptCore.framework"></a>JSPatch —— 基于 JavaScriptCore.framework</h1><blockquote><p>JSPatch 是一个开源项目(<a href="https://github.com/bang590/JSPatch/" target="_blank" rel="noopener">Github链接</a>)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。<br>–<em>摘自 JSPatch wiki</em></p></blockquote><p>“极小的引擎文件”指的就是 JavaScriptCore。OS X Mavericks 和 iOS 7 引入了 JavaScriptCore 库，它把 WebKit 的 JavaScript 引擎用 Objective-C 封装，提供了简单、快速、安全的方式接入世界上最流行的语言：</p><ul><li>在 Objective-C 代码中直接执行 JavaScript 代码段；</li><li>在 JavaScript 语言环境里调用 Objective-C 公开给 JavaScript的 方法；</li><li>内存管理和线程封装。</li></ul><p>如果未接触过 JavaScriptCore，在深入学习 JSPatch 之前有必要先了解一下这个js引擎怎么使用。</p><h2 id="OC-调用-JS"><a href="#OC-调用-JS" class="headerlink" title="OC 调用 JS"></a>OC 调用 JS</h2><p><code>JSContext</code> 是运行 JavaScript 代码的环境。可以在 <code>JSContext</code>中创建变量、计算、定义方法等：</p><pre><code class="Objective-C">JSContext *context = [[JSContext alloc] init];[context evaluateScript:@&quot;var num = 5 + 5&quot;];[context evaluateScript:@&quot;var names = [&#39;Grace&#39;, &#39;Ada&#39;, &#39;Margaret&#39;]&quot;];[context evaluateScript:@&quot;var triple = function(value) { return value * 3 }&quot;];</code></pre><p><code>JSValue</code>包装了每一个可能的 JavaScript 值，任何出自 <code>JSContext</code> 的值都被包裹在一个 <code>JSValue</code> 对象中：</p><pre><code class="Objective-C">JSValue *tripleNum = [context evaluateScript:@&quot;triple(num)&quot;];//取出jsvalue中的值NSLog(@&quot;Tripled: %d&quot;, [tripleNum toInt32]);//30</code></pre><p>对 <code>JSContext</code> 和 <code>JSValue</code> 实例使用下标可以访问之前创建的 context 的任何值。<code>JSContext</code> 需要一个字符串下标，<code>JSValue</code> 使用字符串或整数下标来得到里面的对象和数组：</p><pre><code class="Objective-C">JSValue *names = context[@&quot;names&quot;];JSValue *initialName = names[0];NSLog(@&quot;The first name: %@&quot;, [initialName toString]);//Grace</code></pre><p>调用JS方法需要使用<code>callWithArguments:</code>传递参数：</p><pre><code class="Objective-C">JSValue *tripleFunction = context[@&quot;triple&quot;];JSValue *result = [tripleFunction callWithArguments:@[@5]];NSLog(@&quot;five tripled:%d&quot;,[result toInt32]);</code></pre><p>这里使用 Foundation 类型<code>NSArray</code>作为参数来直接调用该函数。JavaScriptCore 可以 很轻松地处理这个桥接。<br>以上js代码都以字符串形式直接出现在oc代码中，实际中也可以在项目中引入.js文件，执行js文件中的内容。即：</p><pre><code class="Objective-C">NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];NSString *jsCore = [[NSString alloc] initWithData:[[NSFileManager defaultManager] contentsAtPath:path] encoding:NSUTF8StringEncoding];[context evaluateScript:jsCore];</code></pre><h2 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h2><p>从JS访问在OC中定义的对象和方法有两种方式：</p><h3 id="方式一：-JSContext注册NSBlock对象："><a href="#方式一：-JSContext注册NSBlock对象：" class="headerlink" title="方式一： JSContext注册NSBlock对象："></a>方式一： <code>JSContext</code>注册<code>NSBlock</code>对象：</h3><pre><code class="Objective-C">context[@&quot;add&quot;] = ^(NSInteger a, NSInteger b) {            NSLog(@&quot;add result:%@&quot;, @(a + b));        };context.exceptionHandler = ^(JSContext *con, JSValue *exception) {            NSLog(@&quot;%@&quot;, exception);            con.exception = exception;            //异常处理...        };[context evaluateScript:@&quot;add(2,3)&quot;];//5</code></pre><h3 id="方式二：OC对象实现JSExport协议"><a href="#方式二：OC对象实现JSExport协议" class="headerlink" title="方式二：OC对象实现JSExport协议:"></a>方式二：OC对象实现<code>JSExport</code>协议:</h3><p>定义一个<code>Test</code>类，遵循 <code>JSExport</code>协议：</p><pre><code class="Objective-C">// in Test.h -----------------//定义一个JSExport子协议，暴露OC方法定义@protocol TestJSExports &lt;JSExport&gt;- (void)log:(id)value;- (void)addX:(int)x withY:(int)y;@end@interface Test : NSObject &lt;TestJSExports&gt;- (void)callOC;@end// in Test.m -----------------@implementation Test- (void)callOC {    JSContext *context = [[JSContext alloc] init];    //将实现了上面定义的协议的对象设置给JSContext    context[@&quot;Test&quot;] = self;    //执行在JSContext中的JS代码，即可以执行传入的对象的JSExport协议中定义的方法    [context evaluateScript:@&quot;Test.log(&#39;Hello JavaScript&#39;)&quot;];    [context evaluateScript:@&quot;Test.addXWithY(1, 2);&quot;];}- (void)log:(id)value {    NSLog(@&quot;value = %@&quot;, value);}- (void)addX:(int)x withY:(int)y {    NSLog(@&quot;x + y = %d&quot;, x + y);}@end</code></pre><p>测试：</p><pre><code class="Objective-C">Test *test = [[Test alloc]init];[test callOC];//&quot;value = Hello JavaScript&quot;,&quot;x + y = 3&quot;</code></pre>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 动态化 </tag>
            
            <tag> JSPatch </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 热更新解读（二）—— JSPatch 源码解析</title>
      <link href="/2019/04/16/jspatch-sourcecode/"/>
      <url>/2019/04/16/jspatch-sourcecode/</url>
      <content type="html"><![CDATA[<p>了解了 JavaScriptCore 的使用方式，本篇从 demo 入手对 JSPatch 关键源码进行解读。<br><a id="more"></a></p><p>关于 JSPatch 的实现原理，JSPatch 作者本人 <a href="http://blog.cnbang.net/" target="_blank" rel="noopener">bang</a> 已经有一系列文章阐述:</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=1&amp;sn=c7d9ee27eff35688180bdc840d31120b&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;一&gt; 核心</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=2&amp;sn=44b62a84a122886b08874861df83d889&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;二&gt; 细节</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=3&amp;sn=9af2403895ff8e09bd7b7d767a34dd5e&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;三&gt; 扩展</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=4&amp;sn=03f7fcdb54ebc8cc49995bf690292ebb&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;四&gt; 新特性</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=5&amp;sn=22c304b6534b17c2ef36ee0afaa7576e&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">JSPatch 实现原理详解 &lt;五&gt; 优化</a></li></ul><p>这些文章是对 JSPatch 内部实现原理和细节诸如“require实现”、“property实现”、“self/super 关键字”、“nil处理”、“内存问题”等具体设计思路和解决方案的阐述，并没有对 JSPatch 源码进行解读。在未接触源码、不清楚整个热修复流程的情况下去读这几篇文章难免一头雾水，最好的方法是边读源码边对照上述文章，代码中不理解的地方可以去文章中寻找答案。<br>本文将从一个小demo入手，跟踪代码执行流程，从Cocoa层、JavaScript层、Native层对热修复流程中涉及到的重要步骤和函数进行解析。</p><h1 id="JSPatch-使用流程"><a href="#JSPatch-使用流程" class="headerlink" title="JSPatch 使用流程"></a>JSPatch 使用流程</h1><p>引入JSPatch，JSPatch 核心部分只有三个文件，十分精巧：<br><img src="/pic/005YhI8igy1fwa5yc63m9j30f0052wei.jpeg" alt=""><br>建立一个小demo，在<code>ViewController</code>屏幕中央放置一个button，button 点击事件为空:</p><pre><code class="Objective-C">// in ViewController.m ------------------ (IBAction)handle:(id)sender {}</code></pre><p>热修复js文件（main.js）内容就是添加这个点击事件（弹出一个<code>AlertView</code>）：</p><pre><code class="JavaScript">// in main.js ------------------------defineClass(&#39;ViewController&#39;, {  handle: function(sender) {    require(&#39;UIAlertView&#39;);    var alert = UIAlertView.alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(&quot;alert&quot;, null, null, &quot;ok&quot;, null, null);    alert.show();  }})</code></pre><blockquote><p>js 文件编写方法查看<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">JSPatch 基础用法</a>。</p></blockquote><p><code>didFinishLaunchingWithOptions:</code>中开启 JSPatch 引擎、执行 js 脚本：</p><pre><code class="Objective-C">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // 开启 JPEngine.    [JPEngine startEngine];    NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];    NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil];    // 执行js脚本代码.    [JPEngine evaluateScript:script];    return YES;}</code></pre><p>修复成功！<br><img src="/pic/005YhI8igy1fwrgwu4hoqj30hu0rigml.jpeg" alt=""></p><h1 id="修复-step-1：startEngine"><a href="#修复-step-1：startEngine" class="headerlink" title="修复 step 1：startEngine"></a>修复 step 1：startEngine</h1><pre><code class="Objective-C">[JPEngine startEngine];</code></pre><p>该方法向<code>JSContext</code>环境注册了一系列供js调用oc方法的block，这些 block 内部大多是 调用 <code>runtime</code> 相关接口的 static 函数。最终读取<code>JSPatch.js</code>中的代码到<code>JSContext</code>环境，使得<code>main.js</code>可以调用<code>JSPatch.js</code>中定义的方法。<br>调用关系大致如下：</p><pre><code>main.js ---&gt;  JSPatch.js ---&gt; OC Block ---&gt; runtime </code></pre><p><strong>源码解读：</strong></p><pre><code class="Objective-C">+ (void)startEngine{//    1.判断是否存在 JSContext 类. ---&gt; iOS 7.0 以下不支持 JavaScriptCore    if (![JSContext class] || _context) {        return;    }//    2.创建一个 JS 运行环境.    JSContext *context = [[JSContext alloc] init];//    3.为了使 JSPatch.js 可以访问 JPEngine 中定义的 C 函数，需为 context 注册 block.//    3.1 创建类.    context[@&quot;_OC_defineClass&quot;] = ^(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) {        return defineClass(classDeclaration, instanceMethods, classMethods);    };//    3.2 给类实现某协议.    context[@&quot;_OC_defineProtocol&quot;] = ^(NSString *protocolDeclaration, JSValue *instProtocol, JSValue *clsProtocol) {        return defineProtocol(protocolDeclaration, instProtocol,clsProtocol);    };//    3.3 js调用oc的实例方法.    context[@&quot;_OC_callI&quot;] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) {        return callSelector(nil, selectorName, arguments, obj, isSuper);    };//    3.4 js调用oc的类方法.    context[@&quot;_OC_callC&quot;] = ^id(NSString *className, NSString *selectorName, JSValue *arguments) {        return callSelector(className, selectorName, arguments, nil, NO);    };//    3.5 js 对象转 oc 对象.    context[@&quot;_OC_formatJSToOC&quot;] = ^id(JSValue *obj) {        return formatJSToOC(obj);    };//    3.6 oc 对象 转 js 对象.    context[@&quot;_OC_formatOCToJS&quot;] = ^id(JSValue *obj) {        return formatOCToJS([obj toObject]);    };//    3.7 获取对象的动态成员变量.    context[@&quot;_OC_getCustomProps&quot;] = ^id(JSValue *obj) {        id realObj = formatJSToOC(obj);        return objc_getAssociatedObject(realObj, kPropAssociatedObjectKey);    };//    3.8 给对象动态添加成员变量.    context[@&quot;_OC_setCustomProps&quot;] = ^(JSValue *obj, JSValue *val) {        id realObj = formatJSToOC(obj);        objc_setAssociatedObject(realObj, kPropAssociatedObjectKey, val, OBJC_ASSOCIATION_RETAIN_NONATOMIC);    };//    3.9 给 js 对象设置 weak.    context[@&quot;__weak&quot;] = ^id(JSValue *jsval) {        id obj = formatJSToOC(jsval);        return [[JSContext currentContext][@&quot;_formatOCToJS&quot;] callWithArguments:@[formatOCToJS([JPBoxing boxWeakObj:obj])]];    };//    3.10 给 js 对象设置 strong.    context[@&quot;__strong&quot;] = ^id(JSValue *jsval) {        id obj = formatJSToOC(jsval);        return [[JSContext currentContext][@&quot;_formatOCToJS&quot;] callWithArguments:@[formatOCToJS(obj)]];    };//    3.11 获取 oc 对象超类.    context[@&quot;_OC_superClsName&quot;] = ^(NSString *clsName) {        Class cls = NSClassFromString(clsName);        return NSStringFromClass([cls superclass]);    };//    3.12 是否自动转换类型.    context[@&quot;autoConvertOCType&quot;] = ^(BOOL autoConvert) {        _autoConvert = autoConvert;    };//    3.13 oc number 转换为 string.    context[@&quot;convertOCNumberToString&quot;] = ^(BOOL convertOCNumberToString) {        _convertOCNumberToString = convertOCNumberToString;    };//    3.14 在JS中调用include方法,可以在一个JS文件中加载其他JS文件.    context[@&quot;include&quot;] = ^(NSString *filePath) {        NSString *absolutePath = [_scriptRootDir stringByAppendingPathComponent:filePath];        if (!_runnedScript) {            _runnedScript = [[NSMutableSet alloc] init];        }        if (absolutePath &amp;&amp; ![_runnedScript containsObject:absolutePath]) {            [JPEngine _evaluateScriptWithPath:absolutePath];            [_runnedScript addObject:absolutePath];        }    };//    3.15 获取资源文件路径.    context[@&quot;resourcePath&quot;] = ^(NSString *filePath) {        return [_scriptRootDir stringByAppendingPathComponent:filePath];    };//    3.16 让 js 方法延迟执行.    context[@&quot;dispatch_after&quot;] = ^(double time, JSValue *func) {        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{            [func callWithArguments:nil];        });    };//    3.17 让js方法在 main queue dispatch async 执行.    context[@&quot;dispatch_async_main&quot;] = ^(JSValue *func) {        dispatch_async(dispatch_get_main_queue(), ^{            [func callWithArguments:nil];        });    };//    3.18 让js方法在 main queue dispatch sync 执行.    context[@&quot;dispatch_sync_main&quot;] = ^(JSValue *func) {        if ([NSThread currentThread].isMainThread) {            [func callWithArguments:nil];        } else {            dispatch_sync(dispatch_get_main_queue(), ^{                [func callWithArguments:nil];            });        }    };//    3.19 让js方法在 global queue dispatch async 执行.    context[@&quot;dispatch_async_global_queue&quot;] = ^(JSValue *func) {        dispatch_async(dispatch_get_global_queue(0, 0), ^{            [func callWithArguments:nil];        });    };//    3.20 释放js创建的oc对象.    context[@&quot;releaseTmpObj&quot;] = ^void(JSValue *jsVal) {        if ([[jsVal toObject] isKindOfClass:[NSDictionary class]]) {            void *pointer =  [(JPBoxing *)([jsVal toObject][@&quot;__obj&quot;]) unboxPointer];            id obj = *((__unsafe_unretained id *)pointer);            @synchronized(_TMPMemoryPool) {                [_TMPMemoryPool removeObjectForKey:[NSNumber numberWithInteger:[(NSObject*)obj hash]]];            }        }    };//    3.21 js调用oc方法进行打印.    context[@&quot;_OC_log&quot;] = ^() {        NSArray *args = [JSContext currentArguments];        for (JSValue *jsVal in args) {            id obj = formatJSToOC(jsVal);            NSLog(@&quot;JSPatch.log: %@&quot;, obj == _nilObj ? nil : (obj == _nullObj ? [NSNull null]: obj));        }    };//    3.22 将js捕捉到的异常交给oc方法处理.    context[@&quot;_OC_catch&quot;] = ^(JSValue *msg, JSValue *stack) {        _exceptionBlock([NSString stringWithFormat:@&quot;js exception, \nmsg: %@, \nstack: \n %@&quot;, [msg toObject], [stack toObject]]);    };//    4. 注册 JSContext 执行出现异常时的回调.    context.exceptionHandler = ^(JSContext *con, JSValue *exception) {        NSLog(@&quot;%@&quot;, exception);        _exceptionBlock([NSString stringWithFormat:@&quot;js exception: %@&quot;, exception]);    };//    5. 创建OC中的null对象，转换成js的null对象，并设置到JSContext实例让js代码可以获取.    _nullObj = [[NSObject alloc] init];    context[@&quot;_OC_null&quot;] = formatOCToJS(_nullObj);//    6. 保存 context.    _context = context;//    7. oc 中的 nil 对象.    _nilObj = [[NSObject alloc] init];//    8. 同步锁.    _JSMethodSignatureLock = [[NSLock alloc] init];    _JSMethodForwardCallLock = [[NSRecursiveLock alloc] init];//    9. 在 JSPatch 中注册过的结构体定义（键：结构体名）.    _registeredStruct = [[NSMutableDictionary alloc] init];//    10. 注册内存警告通知.#if TARGET_OS_IPHONE    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleMemoryWarning) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];#endif//    11. 读取JSPatch.js，方便传入的js代码中使用JSPatch.js提供的函数.    NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@&quot;JSPatch&quot; ofType:@&quot;js&quot;];    if (!path) _exceptionBlock(@&quot;can&#39;t find JSPatch.js&quot;);    NSString *jsCore = [[NSString alloc] initWithData:[[NSFileManager defaultManager] contentsAtPath:path] encoding:NSUTF8StringEncoding];//    12. 加载 JSPatch.js 中的所有 js 代码到JSContext.    if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) {        [_context evaluateScript:jsCore withSourceURL:[NSURL URLWithString:@&quot;JSPatch.js&quot;]];    } else {        [_context evaluateScript:jsCore];    }}</code></pre><p>一张图总结 JSPatch 的功能结构：<br><img src="/pic/005YhI8igy1fwrgx6km6jj31g20oejvf.jpeg" alt=""></p><h1 id="修复-step-2：-c-元函数"><a href="#修复-step-2：-c-元函数" class="headerlink" title="修复 step 2：__c()元函数"></a>修复 step 2：__c()元函数</h1><p>接下来读取<code>main.js</code>代码后执行：</p><pre><code class="Objective-C">[JPEngine evaluateScript:script];</code></pre><p>该接口并非直接将<code>main.js</code>代码提交到<code>JSContext</code>环境执行，而是先调用<code>_evaluateScript: withSourceURL:</code>方法对<code>main.js</code>原始代码做些修改。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">+ (JSValue *)_evaluateScript:(NSString *)script withSourceURL:(NSURL *)resourceURL{//    1. script 不存在或当前 iOS 版本低于 7.0 退出.    if (!script || ![JSContext class]) {        _exceptionBlock(@&quot;script is nil&quot;);        return nil;    }    [self startEngine];//    2. 正则式构建 (?&lt;!\\\\)\\.\\s*(\\w+)\\s*\\(    if (!_regex) {        _regex = [NSRegularExpression regularExpressionWithPattern:_regexStr options:0 error:nil];    }//    3. 使用正则式处理 传入的 js代码 &gt;&gt;&gt; 将 alloc()这样的函数调用 替换成 __c(&quot;alloc&quot;)()    NSString *formatedScript = [NSString stringWithFormat:@&quot;;(function(){try{%@}catch(e){_OC_catch(e.message, e.stack)}})();&quot;, [_regex stringByReplacingMatchesInString:script options:0 range:NSMakeRange(0, script.length) withTemplate:_replaceStr]];//    4.将正则处理后的js代码加载到 context 执行.(进入 JavaScriptCore)    @try {        if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) {            return [_context evaluateScript:formatedScript withSourceURL:resourceURL];        } else {            return [_context evaluateScript:formatedScript];        }    }    @catch (NSException *exception) {        _exceptionBlock([NSString stringWithFormat:@&quot;%@&quot;, exception]);    }    return nil;}</code></pre><p>断点调试看一下<code>script</code>经正则处理之后的结果：</p><pre><code class="JavaScript">;(function(){try{defineClass(&#39;ViewController&#39;, {  pushAlertView: function(sender) {    require(&#39;UIAlertView&#39;);    var alert = UIAlertView.__c(&quot;alloc&quot;)().__c(&quot;initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles&quot;)(&quot;alert&quot;, null, null, &quot;ok&quot;, null, null);    alert.__c(&quot;show&quot;)();  }})}catch(e){_OC_catch(e.message, e.stack)}})();</code></pre><p>除了添加一些关键字和异常处理外，最大的变化在于所有函数调用变成了<code>__c(&quot;function&quot;)</code>的形式。据作者讲这是<code>JSPatch</code>开发过程中最核心的问题，该问题的解决方案也是<code>JSPatch</code>中最精妙之处。<br>我们进行热修复期望的效果是这样：<br><img src="/pic/005YhI8igy1fwrgxnadadj307008u75a.jpeg" alt=""><br>但JS 对于调用没定义的属性/变量，只会马上抛出异常，而不像 OC/Lua/ruby 那样有转发机制。因此对于用户传入的js代码中，类似<code>UIView().alloc().init()</code>这样的代码，js其实根本没办法进行处理。<br><img src="/pic/005YhI8igy1fwrgxwfj9fj30dx01zgma.jpeg" alt=""><br>一种解决方案是实现所有js类继承机制，每一个类和方法都事先定义好：<br><img src="/pic/005YhI8igy1fwrgy4x9ovj30hg0403zr.jpeg" alt=""><br>这种方案是不太现实的，为了调用某个方法需要把该类的所有方法都引进来，占用内存极高（<code>NSObject</code>类有将近1000个方法）。</p><p>作者最终想出了第二种方案：</p><blockquote><p>在 OC 执行 JS 脚本前，通过正则把所有方法调用都改成调用 __c() 函数，再执行这个 JS 脚本，做到了类似 OC/Lua/Ruby 等的消息转发机制。</p></blockquote><pre><code class="JavaScript">UIView.alloc().init()-&gt;UIView.__c(&#39;alloc&#39;)().__c(&#39;init&#39;)()</code></pre><p><img src="/pic/005YhI8igy1fwrgyd3gl2j30cf0b6dhf.jpeg" alt=""><br>给 JS 对象基类 Object 的 <code>prototype</code> 加上 c 成员，这样所有对象都可以调用到 c，根据当前对象类型判断进行不同操作：</p><pre><code class="JavaScript">__c: function(methodName) {      ...      ...      return function(){        var args = Array.prototype.slice.call(arguments)        return _methodFunc(slf.__obj, slf.__clsName, methodName, args, slf.__isSuper)      }    }</code></pre><p><code>_methodFunc()</code> 把相关信息传给OC，OC用 Runtime 接口调用相应方法，返回结果值，这个调用就结束了。<br><strong>源码解读：</strong></p><pre><code class="JavaScript"> /**   *  instance: 对象   *  clsName: 类名   *  methodName: 方法名   *  args: 参数列表   *  isSuper: 是否调用super父类的方法   *  isPerformSelector:是否用performSelector方式调用   */  var _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) {    var selectorName = methodName    if (!isPerformSelector) {//  不是 performSelector方式的方法调用流程//  处理得到OC中的方法SEL      methodName = methodName.replace(/__/g, &quot;-&quot;)      selectorName = methodName.replace(/_/g, &quot;:&quot;).replace(/-/g, &quot;_&quot;)      var marchArr = selectorName.match(/:/g)      var numOfArgs = marchArr ? marchArr.length : 0      if (args.length &gt; numOfArgs) {        selectorName += &quot;:&quot;      }    }//  获取调用OC方法后的返回值//  如果是获取一个OC对象，那么ret = {&quot;__obj&quot;:OC对象},因为OC把对象返回给js之前会先包装成NSDictionary    var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):                         _OC_callC(clsName, selectorName, args)//  获取OC方法执行完毕的返回值，并转化成JS对象    return _formatOCToJS(ret)  }</code></pre><h1 id="修复-step-3：global-defineClass"><a href="#修复-step-3：global-defineClass" class="headerlink" title="修复 step 3：global.defineClass"></a>修复 step 3：global.defineClass</h1><p>原脚本代码经过正则处理后交由<code>JSContext</code>环境去执行：</p><pre><code class="Objective-C">[_context evaluateScript:formatedScript withSourceURL:resourceURL];</code></pre><p>回过头看<code>main.js</code>的代码（处理后的）：</p><pre><code class="JavaScript">defineClass(`ViewController`,{instaceMethods...},{classMethods...})</code></pre><p>参数依次为类名、实例方法列表、类方法列表。阅读<code>global.defineClass</code>源码会发现<code>defineClass</code>首先会分别对两个方法列表调用<code>_formatDefineMethods</code>，该方法参数有三个：方法列表（js对象）、空js对象、真实类名：</p><pre><code class="Javascript">  var _formatDefineMethods = function(methods, newMethods, realClsName) {    for (var methodName in methods) {      if (!(methods[methodName] instanceof Function)) return;      (function(){        var originMethod = methods[methodName]        newMethods[methodName] = [originMethod.length, function() {          try {            var args = _formatOCToJS(Array.prototype.slice.call(arguments))            var lastSelf = global.self            global.self = args[0]            if (global.self) global.self.__realClsName = realClsName            args.splice(0,1)            var ret = originMethod.apply(originMethod, args)            global.self = lastSelf            return ret          } catch(e) {            _OC_catch(e.message, e.stack)          }        }]      })()    }  }</code></pre><p>该段代码遍历方法列表对象的方法名，向js空对象中添加属性：方法名为键，一个数组为值。数组第一个元素为对应实现函数的参数个数，第二个元素是方法的具体实现。也就是说，<code>_formatDefineMethods</code>将 <code>defineClass</code>传递过来的js对象进行了修改：</p><pre><code class="JavaScript">{    methodName:function(args...){...}}--&gt;{    methodName:[argCount,function(args...){...新实现}]}</code></pre><p><strong><em>1. 为什么要传递参数个数？</em></strong><br>因为<code>runtime</code>修复类的时候无法直接解析js实现函数，也就无法知道参数个数，但方法替换的过程需要生成方法签名，所以只能从js端拿到js函数的参数个数，并传递给OC。</p><p><strong><em>2. 为什么要修改方法实现？</em></strong></p><ul><li>参数转化为js对象。这涉及到对象生命周期的管理，具体查看<a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=1&amp;sn=c7d9ee27eff35688180bdc840d31120b&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">&lt;实现原理一&gt;</a>4.对象持有／转换。</li><li>self 处理。使得js修复代码中我们可以像在 OC 中一样使用self，具体查看<a href="http://mp.weixin.qq.com/s?__biz=MzIzNTQ2MDg2Ng==&amp;mid=2247483662&amp;idx=1&amp;sn=c7d9ee27eff35688180bdc840d31120b&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">&lt;实现原理一&gt;</a>6.self 关键字。</li><li><code>args.splice(0,1)</code>删除前两个参数：<br>OC中进行消息转发，前两个参数是<code>self</code>和<code>selector</code>，实际调用js的具体实现的时候，需要把这两个参数删除。</li></ul><p>我们可以使用 safari 对 JSPatch.js 进行调试（<a href="https://github.com/bang590/JSPatch/wiki/JS-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95" target="_blank" rel="noopener">JS 断点调试</a>）看看处理之后的<code>newInstMethods</code>：<br><img src="/pic/005YhI8igy1fwrgyn54lfj30r80opn5m.jpeg" alt=""></p><p>回到<code>defineClass</code>，调用<code>_formatDefineMethods</code>之后，拿着要重写的类名和经过处理的js对象，调用<code>_OC_defineClass</code>，也就是OC端定义的block方法。</p><h1 id="修复-step-4：-OC-defineClass"><a href="#修复-step-4：-OC-defineClass" class="headerlink" title="修复 step 4：_OC_defineClass"></a>修复 step 4：_OC_defineClass</h1><p><code>JPEngine</code>中的<code>defineClass</code>对类进行真正的重写操作，将类名、<code>selector</code>、方法实现（IMP）、方法签名等<code>runtime</code>重写方法所需的基本元素提取出来。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  定义一个类／覆盖或新增一个方法. * *  @param classDeclaration 类的声明（需要替换或者新增的类名:继承的父类名 &lt;实现的协议1，实现的协议2&gt;） *  @param instanceMethods  {实例方法} *  @param classMethods     {类方法} * *  @return 返回@{@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName} */static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods){//    1.使用 NSScanner 分离 classDeclaration.    NSScanner *scanner = [NSScanner scannerWithString:classDeclaration];    NSString *className;        //类名    NSString *superClassName;   //父类名    NSString *protocolNames;    //实现的协议名    [scanner scanUpToString:@&quot;:&quot; intoString:&amp;className];    if (!scanner.isAtEnd) {        scanner.scanLocation = scanner.scanLocation + 1;        [scanner scanUpToString:@&quot;&lt;&quot; intoString:&amp;superClassName];        if (!scanner.isAtEnd) {            scanner.scanLocation = scanner.scanLocation + 1;            [scanner scanUpToString:@&quot;&gt;&quot; intoString:&amp;protocolNames];        }    }    if (!superClassName) superClassName = @&quot;NSObject&quot;;    className = trim(className);    superClassName = trim(superClassName);    NSArray *protocols = [protocolNames length] ? [protocolNames componentsSeparatedByString:@&quot;,&quot;] : nil;//    2.获取该Class对象.    Class cls = NSClassFromString(className);    if (!cls) {        Class superCls = NSClassFromString(superClassName);        if (!superCls) {            _exceptionBlock([NSString stringWithFormat:@&quot;can&#39;t find the super class %@&quot;, superClassName]);            return @{@&quot;cls&quot;: className};        }//        2.1 该Class对象为nil，为JS端添加一个新的类.        cls = objc_allocateClassPair(superCls, className.UTF8String, 0);        objc_registerClassPair(cls);    }    if (protocols.count &gt; 0) {        for (NSString* protocolName in protocols) {            Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:NSUTF8StringEncoding]);            class_addProtocol (cls, protocol);        }    }    for (int i = 0; i &lt; 2; i ++) {        BOOL isInstance = i == 0;        JSValue *jsMethods = isInstance ? instanceMethods: classMethods;//        3.若是添加实例方法，直接使用Class对象；//          若是添加类方法，需要获取元类.        Class currCls = isInstance ? cls: objc_getMetaClass(className.UTF8String);//      把js对象转换成OC的字典，从而可以取到方法名、参数个数、具体实现.        NSDictionary *methodDict = [jsMethods toDictionary];        for (NSString *jsMethodName in methodDict.allKeys) {//            遍历字典的key，即方法名，根据方法名取出的值还是JSValue对象，它代表的是数组，第一个值是参数的个数，第二个值是函数的实现.            JSValue *jsMethodArr = [jsMethods valueForProperty:jsMethodName];            int numberOfArg = [jsMethodArr[0] toInt32];            NSString *selectorName = convertJPSelectorString(jsMethodName);            if ([selectorName componentsSeparatedByString:@&quot;:&quot;].count - 1 &lt; numberOfArg) {                selectorName = [selectorName stringByAppendingString:@&quot;:&quot;];            }            JSValue *jsMethod = jsMethodArr[1];            if (class_respondsToSelector(currCls, NSSelectorFromString(selectorName))) {//                4.如果要替换的类已经定义了该方法，直接对该方法替换和实现消息转发.                overrideMethod(currCls, selectorName, jsMethod, !isInstance, NULL);            } else {                BOOL overrided = NO;                for (NSString *protocolName in protocols) {//                    5.1 遍历protocolsNames，依次获取协议对象和协议方法中的type和name                    char *types = methodTypesInProtocol(protocolName, selectorName, isInstance, YES);                    if (!types) types = methodTypesInProtocol(protocolName, selectorName, isInstance, NO);                    if (types) {//                        对协议方法实现消息转发.                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, types);                        free(types);                        overrided = YES;                        break;                    }                }                if (!overrided) {//                    5.2 上述两种情况都不满足.js端请求添加一个新的方法.                    if (![[jsMethodName substringToIndex:1] isEqualToString:@&quot;_&quot;]) {//                      方法名的处理：_改为:                        NSMutableString *typeDescStr = [@&quot;@@:&quot; mutableCopy];                        for (int i = 0; i &lt; numberOfArg; i ++) {                            [typeDescStr appendString:@&quot;@&quot;];                        }//                        构造一个typeDescription为&quot;@@:\@*&quot;的IMP.将这个IMP添加到类中.                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, [typeDescStr cStringUsingEncoding:NSUTF8StringEncoding]);                    }                }            }        }    }//    6.为该类添加两个方法，使js脚本拥有设置property的方法.#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;    class_addMethod(cls, @selector(getProp:), (IMP)getPropIMP, &quot;@@:@&quot;);    class_addMethod(cls, @selector(setProp:forKey:), (IMP)setPropIMP, &quot;v@:@@&quot;);#pragma clang diagnostic pop//    7.返回字典给js脚本    return @{@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName};}</code></pre><p>由源码可见，方法名、实现等处理好之后最终执行<code>overrideMethod</code>方法。</p><h1 id="修复-step-5：overrideMethod"><a href="#修复-step-5：overrideMethod" class="headerlink" title="修复 step 5：overrideMethod"></a>修复 step 5：overrideMethod</h1><p><code>overrideMethod</code>是实现<strong>“替换”</strong>的最后一步。通过调用一系列runtime 方法增加／替换实现的api，使用<code>jsvalue</code>中将要替换的方法实现来替换oc类中的方法实现。<br>该函数做的事情比较多，一张图概括如下：<br><img src="/pic/005YhI8igy1fwrgyvh58sj313o0u0785.jpeg" alt=""><br><strong><em>4.向class添加名为ORIG＋selector，对应原始selector的IMP。</em></strong><br>这一步是为了让js通过这个方法调用原来的实现。</p><p><strong><em>5.向class添加名为<code>ORIGforwardInvocation</code>的方法，实现是原始的<code>forwardInvocation</code>的IMP。</em></strong><br>这一步是为了保存<code>forwardInvocation</code>的旧有实现，在新的实现中做判断，如果转发的方法是欲改写的，就走新逻辑，反之走原来的流程。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  使用jsvalue中将要替换的方法实现来替换oc类中的方法实现 * *  @param cls             被替换的类 *  @param selectorName    被替换实现的SEL *  @param function        在js中定义的将要替换的新的实现 *  @param isClassMethod   是否类方法（如果是--&gt;寻找MetaClass） *  @param typeDescription 被替换的实现方法的编码 */static void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription){//    1. 要重写的方法的SEL.    SEL selector = NSSelectorFromString(selectorName);//    2. 获取重写方法的具体实现函数的格式编码.    if (!typeDescription) {        Method method = class_getInstanceMethod(cls, selector);        typeDescription = (char *)method_getTypeEncoding(method);    }//    3.获取 class 中被重写 SEL 对应的原始IMP.    IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : NULL;//    4.准备进入消息转发处理的系统函数实现IMP.    IMP msgForwardIMP = _objc_msgForward;//    5.针对“非 arm64”架构，消息转发应使用 _objc_msgForward_stret 系统函数.//      因为_objc_msgForward函数在cpu架构不是 arm64 时，处理返回值是一些特殊 struct 时可能造成 crash.    #if !defined(__arm64__)        if (typeDescription[0] == &#39;{&#39;) {            //In some cases that returns struct, we should use the &#39;_stret&#39; API:            //http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html            //NSMethodSignature knows the detail but has no API to return, we can only get the info from debugDescription.            NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:typeDescription];            if ([methodSignature.debugDescription rangeOfString:@&quot;is special struct return? YES&quot;].location != NSNotFound) {                msgForwardIMP = (IMP)_objc_msgForward_stret;            }        }    #endif#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;    if (class_getMethodImplementation(cls, @selector(forwardInvocation:)) != (IMP)JPForwardInvocation) {//     6.将cls中原来 forwardInvocaiton: 的实现替换成 JPForwardInvocation:函数实现.//       class_replaceMethod()返回的是替换之前的 IMP.        IMP originalForwardImp = class_replaceMethod(cls, @selector(forwardInvocation:), (IMP)JPForwardInvocation, &quot;v@:@&quot;);        if (originalForwardImp) {//     7.为cls添加新的SEL(ORIGforwardInvocation:)，指向原始 forwardInvocation: 的实现IMP.            class_addMethod(cls, @selector(ORIGforwardInvocation:), originalForwardImp, &quot;v@:@&quot;);        }    }#pragma clang diagnostic pop    [cls jp_fixMethodSignature];    if (class_respondsToSelector(cls, selector)) {        NSString *originalSelectorName = [NSString stringWithFormat:@&quot;ORIG%@&quot;, selectorName];        SEL originalSelector = NSSelectorFromString(originalSelectorName);        if(!class_respondsToSelector(cls, originalSelector)) {//      8.为cls添加新的SEL(ORIG...:)指向被替换方法的原始实现IMP.            class_addMethod(cls, originalSelector, originalImp, typeDescription);        }    }//      9.构造替换实现后的新SEL:(JP...)    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];//     10.记录新SEL对应js传过来的待替换目标方法的实现.    _initJPOverideMethods(cls);    _JSOverideMethods[cls][JPSelectorName] = function;//    11.替换原SEL的实现IMP为msgForwardIMP//       让被替换的方法调用时，直接进入“消息转发”流程（_objc_msgForward 或 _objc_msgForward_stret）//       这一步放到最后是为了避免在 overrideMethod 过程中调用原sel导致的线程问题.    class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);}</code></pre><p>至此，<code>selector</code>具体实现 IMP 的替换工作已经完成了。接下来便可以分析一下点击button后的<code>handle</code>事件。</p><h1 id="调用-step-1：JPForwardInvocation"><a href="#调用-step-1：JPForwardInvocation" class="headerlink" title="调用 step 1：JPForwardInvocation"></a>调用 step 1：JPForwardInvocation</h1><p>经过上一步处理，<code>handle:</code>直接走<code>objc_msgForward</code>进行消息转发环节。当点击button，调用<code>handle:</code>的时候，函数调用的参数会被封装到<code>NSInvocation</code>对象，走到<code>forwardInvocation</code>方法。上一步中<code>forwardInvocation</code>方法的实现替换成了<code>JPForwardInvocation</code>，<strong>负责拦截系统消息转发函数传入的<code>NSInvocation</code>并从中获取到所有的方法执行参数值，是实现替换和新增方法的核心</strong>。<br><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  替换原有的forwarInvocation:方法 * *  @param assignSlf  self *  @param selector   原始SEL *  @param invocation 封装了函数调用参数的NSInvocation对象 */static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation){//    1.表示oc对象是否已经被释放    BOOL deallocFlag = NO;    id slf = assignSlf;//    2.获取invocation中参数的数量    NSMethodSignature *methodSignature = [invocation methodSignature];    NSInteger numberOfArguments = [methodSignature numberOfArguments];//    3.转化调用的SEL为JPSEL（这是JSPatch中缓存JSValue* function的key格式）    NSString *selectorName = NSStringFromSelector(invocation.selector);    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];//    4.判断JPSEL是否有对应的js函数的实现，如果没有就走原始方法的消息转发的流程.    JSValue *jsFunc = getJSFunctionInObjectHierachy(slf, JPSelectorName);    if (!jsFunc) {        JPExecuteORIGForwardInvocation(slf, selector, invocation);        return;    }//    5.从NSInvocation中获取调用的参数，把self与相应的参数都转换成js对象并封装到一个集合中//      js端重写的函数，传递过来是JSValue类型，用callWithArgument:调用js方法，参数也要是js对象.//    5.1 初始化数组，存储NSInvacation中获取的参数列表，传给对应的js函数    NSMutableArray *argList = [[NSMutableArray alloc] init];    if ([slf class] == slf) {//        5.2 类方法：设置__clsName标识表明这是一个类对象        [argList addObject:[JSValue valueWithObject:@{@&quot;__clsName&quot;: NSStringFromClass([slf class])} inContext:_context]];    } else if ([selectorName isEqualToString:@&quot;dealloc&quot;]) {//        5.3 要被释放的对象：使用assign来保存self指针        [argList addObject:[JPBoxing boxAssignObj:slf]];        deallocFlag = YES;    } else {//        5.4 使用 weak 保存self 指针        [argList addObject:[JPBoxing boxWeakObj:slf]];    }//    5.5 NSInvocation 对象的前两个参数是self和_cmd（http://stackoverflow.com/questions/5788346/calling-a-selector-with-unknown-number-of-arguments-using-reflection-introspec）//    所以直接从第3个参数开始获取    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];//        返回值如果是const，获取encoding来判断类型.        switch(argumentType[0] == &#39;r&#39; ? argumentType[1] : argumentType[0]) {//                从invocation中获取参数，添加到argList中.            #define JP_FWD_ARG_CASE(_typeChar, _type) \            case _typeChar: {   \                _type arg;  \                [invocation getArgument:&amp;arg atIndex:i];    \                [argList addObject:@(arg)]; \                break;  \            }            JP_FWD_ARG_CASE(&#39;c&#39;, char)            JP_FWD_ARG_CASE(&#39;C&#39;, unsigned char)            JP_FWD_ARG_CASE(&#39;s&#39;, short)            JP_FWD_ARG_CASE(&#39;S&#39;, unsigned short)            JP_FWD_ARG_CASE(&#39;i&#39;, int)            JP_FWD_ARG_CASE(&#39;I&#39;, unsigned int)            JP_FWD_ARG_CASE(&#39;l&#39;, long)            JP_FWD_ARG_CASE(&#39;L&#39;, unsigned long)            JP_FWD_ARG_CASE(&#39;q&#39;, long long)            JP_FWD_ARG_CASE(&#39;Q&#39;, unsigned long long)            JP_FWD_ARG_CASE(&#39;f&#39;, float)            JP_FWD_ARG_CASE(&#39;d&#39;, double)            JP_FWD_ARG_CASE(&#39;B&#39;, BOOL)            case &#39;@&#39;: {//                id类型参数使用__unsafe__unretained                __unsafe_unretained id arg;                [invocation getArgument:&amp;arg atIndex:i];//                block参数使用copy，_nilObj表示nil                if ([arg isKindOfClass:NSClassFromString(@&quot;NSBlock&quot;)]) {                    [argList addObject:(arg ? [arg copy]: _nilObj)];                } else {                    [argList addObject:(arg ? arg: _nilObj)];                }                break;            }            case &#39;{&#39;: {//                处理结构体类型参数//                获取结构体类型名称，把参数包装成JSValue类型                NSString *typeString = extractStructName([NSString stringWithUTF8String:argumentType]);                #define JP_FWD_ARG_STRUCT(_type, _transFunc) \                if ([typeString rangeOfString:@#_type].location != NSNotFound) {    \                    _type arg; \                    [invocation getArgument:&amp;arg atIndex:i];    \                    [argList addObject:[JSValue _transFunc:arg inContext:_context]];  \                    break; \                }                JP_FWD_ARG_STRUCT(CGRect, valueWithRect)                JP_FWD_ARG_STRUCT(CGPoint, valueWithPoint)                JP_FWD_ARG_STRUCT(CGSize, valueWithSize)                JP_FWD_ARG_STRUCT(NSRange, valueWithRange)//                自定义类型的结构体处理                @synchronized (_context) {                    NSDictionary *structDefine = _registeredStruct[typeString];                    if (structDefine) {                        size_t size = sizeOfStructTypes(structDefine[@&quot;types&quot;]);                        if (size) {                            void *ret = malloc(size);                            [invocation getArgument:ret atIndex:i];                            NSDictionary *dict = getDictOfStruct(ret, structDefine);                            [argList addObject:[JSValue valueWithObject:dict inContext:_context]];                            free(ret);                            break;                        }                    }                }                break;            }            case &#39;:&#39;: {//                selector类型处理                SEL selector;                [invocation getArgument:&amp;selector atIndex:i];                NSString *selectorName = NSStringFromSelector(selector);                [argList addObject:(selectorName ? selectorName: _nilObj)];                break;            }            case &#39;^&#39;:            case &#39;*&#39;: {//                指针类型处理                void *arg;                [invocation getArgument:&amp;arg atIndex:i];                [argList addObject:[JPBoxing boxPointer:arg]];                break;            }            case &#39;#&#39;: {//                Class类型                Class arg;                [invocation getArgument:&amp;arg atIndex:i];                [argList addObject:[JPBoxing boxClass:arg]];                break;            }            default: {                NSLog(@&quot;error type %s&quot;, argumentType);                break;            }        }    }    if (_currInvokeSuperClsName) {        Class cls = NSClassFromString(_currInvokeSuperClsName);        NSString *tmpSelectorName = [[selectorName stringByReplacingOccurrencesOfString:@&quot;_JPSUPER_&quot; withString:@&quot;_JP&quot;] stringByReplacingOccurrencesOfString:@&quot;SUPER_&quot; withString:@&quot;_JP&quot;];        if (!_JSOverideMethods[cls][tmpSelectorName]) {            NSString *ORIGSelectorName = [selectorName stringByReplacingOccurrencesOfString:@&quot;SUPER_&quot; withString:@&quot;ORIG&quot;];            [argList removeObjectAtIndex:0];            id retObj = callSelector(_currInvokeSuperClsName, ORIGSelectorName, [JSValue valueWithObject:argList inContext:_context], [JSValue valueWithObject:@{@&quot;__obj&quot;: slf, @&quot;__realClsName&quot;: @&quot;&quot;} inContext:_context], NO);            id __autoreleasing ret = formatJSToOC([JSValue valueWithObject:retObj inContext:_context]);            [invocation setReturnValue:&amp;ret];            return;        }    }//    6.将上面获得的参数列表数组转化为对应的js对象数组    NSArray *params = _formatOCToJSList(argList);    char returnType[255];//    7.获取返回值类型    strcpy(returnType, [methodSignature methodReturnType]);    // Restore the return type    if (strcmp(returnType, @encode(JPDouble)) == 0) {        strcpy(returnType, @encode(double));    }    if (strcmp(returnType, @encode(JPFloat)) == 0) {        strcpy(returnType, @encode(float));    }//    7.1 返回值是否为const，如果是，获取后面的encoding来判断类型    switch (returnType[0] == &#39;r&#39; ? returnType[1] : returnType[0]) {    ...(返回值的其它封装规则，具体看源码)    }    if (_pointersToRelease) {        for (NSValue *val in _pointersToRelease) {            void *pointer = NULL;            [val getValue:&amp;pointer];            CFRelease(pointer);        }        _pointersToRelease = nil;    }//    8.待替换的方法是 delloc 需要特殊处理：    if (deallocFlag) {        slf = nil;        Class instClass = object_getClass(assignSlf);        Method deallocMethod = class_getInstanceMethod(instClass, NSSelectorFromString(@&quot;ORIGdealloc&quot;));        //获取原delloc imp 指针，调用delloc，防止内存泄漏.        void (*originalDealloc)(__unsafe_unretained id, SEL) = (__typeof__(originalDealloc))method_getImplementation(deallocMethod);        originalDealloc(assignSlf, NSSelectorFromString(@&quot;dealloc&quot;));    }}</code></pre><p>接下来执行JS中定义的方法实现。“修复 step 2”中已经讨论过，现在main.js中所有的函数都被替换成名为<code>__c(&#39;methodName&#39;)</code>的函数调用，<code>__c</code>调用了<code>_methodFunc</code>函数，<code>_methodFunc</code>会根据方法类型调用<code>_OC_call</code>：</p><pre><code class="JavaScript">var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):                         _OC_callC(clsName, selectorName, args)</code></pre><p><code>_OC_callI</code>或<code>_OC_callC</code>最终都会调用一个<code>static</code>函数<code>callSelector</code>。</p><h1 id="调用-step-2：callSelector"><a href="#调用-step-2：callSelector" class="headerlink" title="调用 step 2：callSelector"></a>调用 step 2：callSelector</h1><p><code>main.js</code>中类似<code>UIAlertView.alloc().init()</code>实际是通过<code>callSelector</code>调用 OC 的方法。</p><ul><li>将 js 对象和参数转化为 OC 对象；</li><li>判断是否调用的是父类的方法，如果是，就走父类的方法实现；</li><li>把参数等信息封装成NSInvocation对象，并执行，然后返回结果。</li></ul><p><strong>源码解读：</strong></p><pre><code class="Objective-C">/** *  完成oc中的方法调用 * *  @param className    类名（nil --&gt; 表示实例方法） *  @param selectorName 方法SEL值 *  @param arguments    方法执行参数 *  @param instance     对象（js对象中的变量，如: var UIAlertView = { __clsName : &#39;UIAlertView&#39;}） *  @param isSuper      是否调用的是父类方法 * *  @return 方法执行后的结果值，返回给js代码中. */static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper){    NSString *realClsName = [[instance valueForProperty:@&quot;__realClsName&quot;] toString];    if (instance) {//    1.将js封装的instance对象进行拆装，得到oc对象.        instance = formatJSToOC(instance);        if (!instance || instance == _nilObj || [instance isKindOfClass:[JPBoxing class]]) return @{@&quot;__isNil&quot;: @(YES)};    }//    2.将js封装的参数列表转为oc类型.    id argumentsObj = formatJSToOC(arguments);    if (instance &amp;&amp; [selectorName isEqualToString:@&quot;toJS&quot;]) {//      3.如果要执行的方法是&quot;toJS&quot;，即转化为js类型，对于NSString/NSDictory/NSArray/NSData需进行特殊处理//        因为JSPatch中需使用JPBoxing包装OC中的上述对象，防止JavaScriptCore.framework转换类型.        if ([instance isKindOfClass:[NSString class]] || [instance isKindOfClass:[NSDictionary class]] || [instance isKindOfClass:[NSArray class]] || [instance isKindOfClass:[NSDate class]]) {            return _unboxOCObjectToJS(instance);        }    }//    4.根据类名与selectorName获得对应的类对象与selector    Class cls = instance ? [instance class] : NSClassFromString(className);    SEL selector = NSSelectorFromString(selectorName);    NSString *superClassName = nil;//    5.判断是否调用的是父类的方法，如果是，走父类的方法实现    if (isSuper) {//        5.1 定义新的SEL:SUPERSEL        NSString *superSelectorName = [NSString stringWithFormat:@&quot;SUPER_%@&quot;, selectorName];        SEL superSelector = NSSelectorFromString(superSelectorName);        Class superCls;        if (realClsName.length) {            Class defineClass = NSClassFromString(realClsName);            superCls = defineClass ? [defineClass superclass] : [cls superclass];        } else {            superCls = [cls superclass];        }        Method superMethod = class_getInstanceMethod(superCls, selector);        IMP superIMP = method_getImplementation(superMethod);//        5.2  将SUPERSEL指向superIMP的实现        class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod));//        5.3  查找父类中是否有添加JPSEL的实现        NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];        JSValue *overideFunction = _JSOverideMethods[superCls][JPSelectorName];        if (overideFunction) {//            如果有，进行imp替换            overrideMethod(cls, superSelectorName, overideFunction, NO, NULL);        }        selector = superSelector;        superClassName = NSStringFromClass(superCls);    }    NSMutableArray *_markArray;//    6.通过类对象与selector构造对应的NSMethodSignature签名    NSInvocation *invocation;    NSMethodSignature *methodSignature;    if (!_JSMethodSignatureCache) {        _JSMethodSignatureCache = [[NSMutableDictionary alloc]init];    }    if (instance) {        [_JSMethodSignatureLock lock];        if (!_JSMethodSignatureCache[cls]) {            _JSMethodSignatureCache[(id&lt;NSCopying&gt;)cls] = [[NSMutableDictionary alloc]init];        }        methodSignature = _JSMethodSignatureCache[cls][selectorName];        if (!methodSignature) {            methodSignature = [cls instanceMethodSignatureForSelector:selector];            methodSignature = fixSignature(methodSignature);            _JSMethodSignatureCache[cls][selectorName] = methodSignature;        }        [_JSMethodSignatureLock unlock];        if (!methodSignature) {            _exceptionBlock([NSString stringWithFormat:@&quot;unrecognized selector %@ for instance %@&quot;, selectorName, instance]);            return nil;        }//        7.根据签名构造NSInvocation对象        invocation = [NSInvocation invocationWithMethodSignature:methodSignature];//        8.为invocation对象设置target        [invocation setTarget:instance];    } else {        methodSignature = [cls methodSignatureForSelector:selector];        methodSignature = fixSignature(methodSignature);        if (!methodSignature) {            _exceptionBlock([NSString stringWithFormat:@&quot;unrecognized selector %@ for class %@&quot;, selectorName, className]);            return nil;        }        invocation= [NSInvocation invocationWithMethodSignature:methodSignature];        [invocation setTarget:cls];    }//        9.为invocation对象设置selector    [invocation setSelector:selector];//    10.根据签名得知每个参数的实际类型    NSUInteger numberOfArguments = methodSignature.numberOfArguments;    NSInteger inputArguments = [(NSArray *)argumentsObj count];    if (inputArguments &gt; numberOfArguments - 2) {//        10.1 多参数方法仅支持 id 类型参数和 id 类型返回,直接revoke并返回.        id sender = instance != nil ? instance : cls;        id result = invokeVariableParameterMethod(argumentsObj, methodSignature, sender, selector);        return formatOCToJS(result);    }//    10.2 将JS传递过来的参数进行对应的转换(如 NSNumber -&gt; int)，转换后为 NSInvocation 对象设置参数.    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) {        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];        id valObj = argumentsObj[i-2];        switch (argumentType[0] == &#39;r&#39; ? argumentType[1] : argumentType[0]) {            //...(具体转换规则看源代码)        }    }    if (superClassName) _currInvokeSuperClsName = superClassName;//    11.执行 invoke 方法,并且传递指定的参数    [invocation invoke];    if (superClassName) _currInvokeSuperClsName = nil;    if ([_markArray count] &gt; 0) {        for (JPBoxing *box in _markArray) {            void *pointer = [box unboxPointer];            id obj = *((__unsafe_unretained id *)pointer);            if (obj) {                @synchronized(_TMPMemoryPool) {                    [_TMPMemoryPool setObject:obj forKey:[NSNumber numberWithInteger:[(NSObject*)obj hash]]];                }            }        }    }    char returnType[255];    strcpy(returnType, [methodSignature methodReturnType]);    // Restore the return type    if (strcmp(returnType, @encode(JPDouble)) == 0) {        strcpy(returnType, @encode(double));    }    if (strcmp(returnType, @encode(JPFloat)) == 0) {        strcpy(returnType, @encode(float));    }    id returnValue;    if (strncmp(returnType, &quot;v&quot;, 1) != 0) {        if (strncmp(returnType, &quot;@&quot;, 1) == 0) {            void *result;//            12. 获取 invocation 运行返回值.            [invocation getReturnValue:&amp;result];//            13. 将返回值封装成JS对应的对象并返回.            //For performance, ignore the other methods prefix with alloc/new/copy/mutableCopy            if ([selectorName isEqualToString:@&quot;alloc&quot;] || [selectorName isEqualToString:@&quot;new&quot;] ||                [selectorName isEqualToString:@&quot;copy&quot;] || [selectorName isEqualToString:@&quot;mutableCopy&quot;]) {                returnValue = (__bridge_transfer id)result;            } else {                returnValue = (__bridge id)result;            }            return formatOCToJS(returnValue);        } else {            switch (returnType[0] == &#39;r&#39; ? returnType[1] : returnType[0]) {            //...（具体转换规则见源代码）            return returnValue;        }    }    return nil;}</code></pre><p>至此，JSPatch 热修复核心步骤<strong>方法替换</strong>和<strong>方法调用</strong>就结束了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JSPatch 基于<code>JavaScriptCore.framework</code>和Objective-C中的runtime技术。</p><ul><li>采用 iOS7 后引入的 <code>JavaScriptCore.framework</code>作为 JavaScript 引擎解析js脚本，执行js代码并与OC端代码进行桥接。</li><li>使用Objective-C <code>runtime</code>中的<code>method swizzling</code>方式达到使用js脚本动态替换原有OC方法的目的，并利用<code>forwardInvocation</code>消息转发机制使得在js脚本中调用OC的方法成为可能。</li></ul><p>JSPatch 实现过程中还有许多细节问题诸如 Special Struct、内存管理、<code>JPBoxing</code>、<code>nil</code>处理等，更多详细内容可以阅读作者的原理详解系列文章以及<a href="https://github.com/bang590/JSPatch/wiki" target="_blank" rel="noopener">GitHub wiki</a>。学习 JSPatch 不仅可以弄清 iOS 热修复机制，也可以体会到如何利用 runtime 这一 OC 最重要的特性来实现一些强大的功能。这里不得不佩服作者深厚的编程功底和各种精彩的奇思妙想。<br><img src="/pic/005YhI8igy1fwrgz3wjngj30h30ckmzt.jpeg" alt=""></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 动态化 </tag>
            
            <tag> JSPatch </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 热更新解读（三）—— JSPatch 之于 Swift</title>
      <link href="/2019/04/15/jspatch-swift/"/>
      <url>/2019/04/15/jspatch-swift/</url>
      <content type="html"><![CDATA[<p>本篇探索 jspatch 能否用于 swift 项目实现热更新。<br><a id="more"></a></p><h1 id="继承自-NSObject-的-Swift-类"><a href="#继承自-NSObject-的-Swift-类" class="headerlink" title="继承自 NSObject 的 Swift 类"></a>继承自 NSObject 的 Swift 类</h1><h2 id="修改属性"><a href="#修改属性" class="headerlink" title="修改属性"></a>修改属性</h2><p>新建 Swift 工程 <code>SwiftJSPatch</code>。<br><code>AppDelegate.swift</code>：</p><pre><code class="swift">// in AppDelegate.swift ----------------func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {        let path = NSBundle.mainBundle().pathForResource(&quot;main&quot;, ofType: &quot;js&quot;)        do {            let patch = try String(contentsOfFile: path!)            JPEngine.startEngine()            JPEngine.evaluateScript(patch)        } catch {}        return true    }</code></pre><p><code>ViewController</code>中设置两个自定义属性：<code>public</code>属性<code>a</code>，<code>private</code>属性<code>pa</code>：</p><pre><code class="swift">// in ViewController.swift ---------------------class ViewController: UIViewController {    var a = &quot;a&quot;    dynamic private var pa = &quot;pa&quot;    override func viewDidLoad() {        print(&quot;ORIG title:\(self.title!)&quot;)        print(&quot;ORIG a:\(a)&quot;)        print(&quot;ORIG pa:\(pa)&quot;)        super.viewDidLoad()    }    override func didReceiveMemoryWarning() {        super.didReceiveMemoryWarning()    }}</code></pre><p><code>main.js</code>中去获取这两个自定义属性并各自赋新值，此外为<code>ViewController</code>继承自父类<code>UIViewController</code>的属性<code>title</code>设置新值：</p><pre><code class="JavaScript">// in main.js --------------------------defineClass(&#39;SwiftJSPatch.ViewController&#39;, {    viewDidLoad: function() {        self.setTitle(&#39;NEW VC&#39;)        console.log(&#39;title: &#39;+self.title().toJS())        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.setA(&#39;new_a&#39;)        self.setPa(&#39;new_pa&#39;)        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.ORIGviewDidLoad();    }});</code></pre><p>运行结果输出：</p><pre><code class="Objective-c">2016-07-29 11:19:26.165 SwiftJSPatch[3789:222439] JSPatch.log: a: a2016-07-29 11:19:26.169 SwiftJSPatch[3789:222439] *** Assertion failure in _exceptionBlock_block_invoke(), /Users/Leon/Desktop/SwiftJSPatch/SwiftJSPatch/JPEngine.m:1422016-07-29 11:19:26.174 SwiftJSPatch[3789:222439] *** Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, reason: &#39;unrecognized selector pa for instance &lt;SwiftJSPatch.ViewController: 0x7a760bb0&gt;&#39;</code></pre><p><code>title</code>修改成功，<code>a</code>获取成功，<code>pa</code>访问失败：找不到<code>selector(pa)</code>，查看 OC 端调用堆栈：<br><img src="/pic/005YhI8igy1fwrgzj76mxj31kw0vj1fy.jpeg" alt=""><br>js端调试：<br><img src="/pic/005YhI8igy1fwrgzr25pgj30tg0kigpi.jpeg" alt=""><br>经过<code>_evaluateScript:withSourceURL:</code>处理，<code>main.js</code>中的方法都被替换成<code>__C(&#39;methodName&#39;)</code>。<br><img src="/pic/005YhI8igy1fwrgzxs7h8j31ii12onds.jpeg" alt=""><br><code>defineClass</code>对js对象method的改写也没问题。<br>由以上信息可知，JSPatch 方法替换成功，方法调用环节js调用oc私有方法<code>pa()</code>也就是在<code>callSelector</code>环节出错，获取不到方法签名导致后续消息转发无法进行。<code>public</code>方法则可以成功替换实现并调用。</p><p>现在在<code>private</code>变量前声明<code>dynamic</code>：</p><pre><code class="Swift">dynamic private var pa = &quot;pa&quot;</code></pre><p>输出：</p><pre><code class="Objective-C">2016-07-29 14:54:01.374 SwiftJSPatch[5368:357904] JSPatch.log: title: NEW VC2016-07-29 14:54:01.381 SwiftJSPatch[5368:357904] JSPatch.log: a: a2016-07-29 14:54:01.382 SwiftJSPatch[5368:357904] JSPatch.log: pa: pa2016-07-29 14:54:01.384 SwiftJSPatch[5368:357904] JSPatch.log: a: new_a2016-07-29 14:54:01.384 SwiftJSPatch[5368:357904] JSPatch.log: pa: new_paORIG title:NEW VCORIG a:new_aORIG pa:new_pa</code></pre><p>变量都被成功修改，也就是说方法替换和调用都没问题。</p><blockquote><p>结论1：<code>JSPatch</code>作用于继承自<code>NSObject</code>的类，其继承自父类的属性／自定义<code>public</code>变量可以直接访问和修改，自定义<code>private</code>变量需要加上<code>dynamic</code>。</p></blockquote><h2 id="修改函数实现"><a href="#修改函数实现" class="headerlink" title="修改函数实现"></a>修改函数实现</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p>从上个修改属性的案例已经看出对于继承自<code>NSObject</code>的类的<strong>继承自父类的方法</strong>，<code>JSPatch</code>实现热更新是没问题的。所以直接看自定义函数的情况。</p><p>在<code>ViewController</code>自定义两个函数，其中一个是<code>private</code>方法：</p><pre><code class="Swift">// in ViewController ---------------------class ViewController: UIViewController {    var a = &quot;a&quot;    dynamic private var pa = &quot;pa&quot;    override func viewDidLoad() {        super.viewDidLoad()        self.fun()        self.pfun()    }    func fun() {        print(&quot;ORIG fun self.a: \(self.a)&quot;)    }    private func pfun() {        print(&quot;ORIG pfun self.pa: \(self.pa)&quot;)    }}</code></pre><p><code>main.js</code>中对这两个自定义函数实现进行修改。<code>fun()</code>给a赋新值，<code>pfun()</code>给<code>pa</code>赋新值：</p><pre><code class="Javascript">// in main.js------------------------defineClass(&#39;SwiftJSPatch.ViewController&#39;, {    fun: function() {        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        self.setA(&#39;new_a&#39;)        var a = self.a()             console.log(&#39;a: &#39; + a.toJS())        self.ORIGfun();    },    pfun: function() {        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.setPa(&#39;new_pa&#39;)        var pa = self.pa()        console.log(&#39;pa: &#39; + pa.toJS())        self.ORIGpfun();    }});</code></pre><p>运行：</p><pre><code>ORIG fun self.a: aORIG pfun self.pa: pa</code></pre><p>热更新失败！<br><img src="/pic/005YhI8igy1fwrh066y9fj31ic12swvr.jpeg" alt=""><br>从js调试结果看脚本是被执行过的，且「方法替换」成功，说明是OC端「方法调用」时<strong>没有走运行时的消息转发流程</strong>。<br>为两个函数添加<code>dynamic</code>声明：</p><pre><code class="Swift">dynamic func fun() {    print(&quot;ORIG fun self.a: \(self.a)&quot;)}dynamic private func pfun() {    print(&quot;ORIG pfun self.pa: \(self.pa)&quot;)}</code></pre><p>hook成功：</p><pre><code class="Swift">2016-07-29 15:49:14.903 SwiftJSPatch[5639:391073] JSPatch.log: a: a2016-07-29 15:49:14.906 SwiftJSPatch[5639:391073] JSPatch.log: a: new_aORIG fun self.a: new_a2016-07-29 15:49:14.909 SwiftJSPatch[5639:391073] JSPatch.log: pa: pa2016-07-29 15:49:14.910 SwiftJSPatch[5639:391073] JSPatch.log: pa: new_paORIG pfun self.pa: new_pa</code></pre><h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>Swift 中静态函数分两种：class 函数／static 函数：</p><pre><code class="Swift">override func viewDidLoad() {      super.viewDidLoad()      ViewController.sfun()      ViewController.cfun()    }    dynamic static func sfun() {        print(&quot;ORIG static func.&quot;)    }    dynamic class func cfun() {        print(&quot;ORIG class func.&quot;)    }</code></pre><p>从结果看出，class 函数得到替换并调用成功，static 函数调用时没有进行消息转发：</p><pre><code class="Swift">ORIG static func.2016-07-29 16:01:16.186 SwiftJSPatch[5701:398350] JSPatch.log: NEW class fun.</code></pre><h1 id="纯-Swift-类"><a href="#纯-Swift-类" class="headerlink" title="纯 Swift 类"></a>纯 Swift 类</h1><p>新建<code>Pure</code>类：</p><pre><code class="Swift">// in Pure.swift ---------------------------class Pure {    var a = &quot;a&quot;    dynamic private var pa = &quot;pa&quot;    func call() {        self.fun()        self.pfun()    }    dynamic func fun() {        print(&quot;ORIG fun self.a: \(self.a)&quot;)    }    dynamic private func pfun() {        print(&quot;ORIG pfun self.pa: \(self.pa)&quot;)    }}</code></pre><p><code>main.js</code>修改<code>fun()</code>和<code>pfun()</code>的实现：</p><pre><code class="Javascript">// in main.js ---------------------------defineClass(&#39;SwiftJSPatch.Pure&#39;, {    fun: function() {        console.log(&#39;NEW static fun.&#39;)    },    pfun: function() {        console.log(&#39;NEW class fun.&#39;)    }});</code></pre><p>调用<code>call()</code>结果：<br>直接崩溃：<br><img src="/pic/005YhI8igy1fwrh18e6muj31kw0so19w.jpeg" alt=""><br>由上图知，<code>JSPatch</code>在进行到<code>overrideMethod</code>进行方法实现IMP替换时要求<code>class</code>实现<code>NSCoping</code>协议，而不继承自<code>NSObject</code>的swift类是不遵循该协议的，因此崩溃。<br><img src="/pic/005YhI8igy1fwrh0moletj31e411u7da.jpeg" alt=""><br>回到崩溃代码:</p><pre><code class="Objective-C">if (!_JSOverideMethods[cls]) {        _JSOverideMethods[(id&lt;NSCopying&gt;)cls] = [[NSMutableDictionary alloc] init];    }</code></pre><p>此处<code>JSPatch</code>在初始化缓冲区的时候将<code>Class</code>作为<code>Dictionary</code>的<code>key</code>进行保存，而<code>Dictionary</code>在设置<code>key-value</code>时会拷贝 <code>key</code>值，所以会导致给一个不遵循<code>NSCoying</code>协议的对象发送了<code>copyWithZone:</code>消息，导致崩溃。</p><h1 id="Swift-原生类热修复难点"><a href="#Swift-原生类热修复难点" class="headerlink" title="Swift 原生类热修复难点"></a>Swift 原生类热修复难点</h1><p>到这里「方法替换」的步骤已经进行不下去了。<code>JSPatch</code>对<code>Swift</code>原生类的热修复已经无能为力了。但<code>Swift</code>热修复的真正难点其实并不在这里，假如我们越过<code>NSCoping</code>通过某种 <strong><em>swift style</em></strong> 的方式实现了对类中方法名和对应js实现的缓存，也就是完成「方法替换」的话，热修复就能成功了吗？</p><p>「方法调用」才是 swift 热修复中目前真正无解的地方，最大原因是<strong>swift中runtime相对OC中的runtime动态性大大减弱</strong>。</p><ul><li>纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。</li><li>继承自NSObject的Swift类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加dynamic修饰才可以获得动态性。</li><li>若方法的参数、属性类型为Swift特有、无法映射到Objective-C的类型(如Character、Tuple)，则此方法、属性无法添加dynamic修饰（会编译错误）</li><li>Swift类在Objective-C中会有模块前缀。</li></ul><p>另外最要命的一点：<code>objc_msgSend</code>函数无法用于 Swift object。这个导致<code>JSPatch</code>实现方法调用（消息转发）的基础机制在 Swift 中失效了。</p><p>总结一下 <code>Swift</code> 项目中使用<code>JSPatch</code>需要注意的几点：</p><ul><li>只支持调用继承自 NSObject 的 Swift 类。</li><li>继承自 NSObject 的 Swift 类，其继承自父类的方法和属性可以在 JS 调用，其他自定义方法和属性同样需要加 dynamic 关键字才行。</li><li>若方法的参数/属性类型为 Swift 特有(如 Character / Tuple)，则此方法和属性无法通过 JS 调用。</li></ul><blockquote><p>参考资料：<br><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=403153173&amp;idx=1&amp;sn=c631f95b28a0eb4b842a9494e43a30e5" target="_blank" rel="noopener">Swift Runtime分析：还像OC Runtime一样吗？</a><br><a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95#11-swift" target="_blank" rel="noopener">JSPatch Github Wiki</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 动态化 </tag>
            
            <tag> JSPatch </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UITextView 输入字数限制</title>
      <link href="/2019/04/14/uitextview-max-length/"/>
      <url>/2019/04/14/uitextview-max-length/</url>
      <content type="html"><![CDATA[<p>最近需求中有一个常见场景：限制用户输入框的文字长度。乍一看很简单其实坑不少，网上的解决方案都不够严谨，记录一下。<br><a id="more"></a><br>一看这个需求立马想到监听文字变化通知<code>UITextView.textDidChangeNotification</code>：</p><pre><code class="Swift">NotificationCenter.default.addObserver(self, selector: #selector(onTextDidChange(sender:)), name: UITextView.textDidChangeNotification, object: textView)var textView: UITextView!/// 最大字数var maxTextSize: Int = 20@objc func onTextDidChange(sender: Notification) {   if(textView.text.count &gt; maxTextSize)    {      textView.text= String(textView.text[..&lt;String.Index(encodedOffset: maxTextSize)])   }}</code></pre><p>然而当使用系统自带键盘输入拼音时，会出现严重问题：你还没有选中要选的文字时,已经被键盘当做字母输入到 textView 当中了，比如用系统键盘输入“你好”，它会把<code>n i h a o</code>显示在 textView 中, 不但没有输入汉字,还每个字母占两个字符长度。<br><img src="/pic/007i4MEmgy1g0xoyzwnylg309q0hcb2a.gif" alt=""><br>处理方法是判断系统键盘输入拼音<strong>处于高亮状态时不截取字符</strong>。<br>另外注意一点，如果逻辑是先将文字铺上去，再在<code>onTextDidChange</code>去截取文字的话，被截掉的永远是末尾的文字。而我们希望的是一旦达到字数上限，用户从任意位置开始都无法继续输入文字了。<br>UITextView 有一个代理方法<br><code>- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;</code><br>这个方法可以拦截到你即将向 textView 输入的起始位置、个数和具体文字。显然在这个方法进行输入限制更合适。</p><pre><code class="Swift">func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool {    // range: The range of characters to be replaced.(location、count)    // 高亮控制    let selectedRange = textView.markedTextRange    if let selectedRange = selectedRange {        let position =  textView.position(from: (selectedRange.start), offset: 0)        if position != nil {            let startOffset = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)            let endOffset = textView.offset(from: textView.beginningOfDocument, to: selectedRange.end)            let offsetRange = NSMakeRange(startOffset, endOffset - startOffset) // 高亮部分起始位置            if offsetRange.location &lt; maxTextSize {                // 高亮部分先不进行字数统计                return true            } else {                Toast.showFail(message: &quot;字数已达上限&quot;)                return false            }        }    }    // 在最末添加    if range.location &gt;= maxTextSize {        Toast.showFail(message: &quot;字数已达上限&quot;)        return false    }    // 在其他位置添加    if textView.text.count &gt;= maxTextSize {        Toast.showFail(message: &quot;字数已达上限&quot;)        return false    }    return true}</code></pre><p>出现一个新问题，你会发现当字数达到上限时，用户无法删除文字或将选中文字进行 cut 或替代了。因此需要多加一个判断：</p><pre><code class="Swift">    ...    // 在其他位置添加    if textView.text.count &gt;= maxTextSize &amp;&amp; range.length &lt;  text.count {        Toast.showFail(message: &quot;字数已达上限&quot;)        return false    }    return true}</code></pre><p>这样已经实现了“阻止用户继续输入”的目的。但仅有<code>shouldChangeTextIn:</code>仍不够，当字数还未达上限，输入<strong>联想词</strong>和<strong>复制粘贴文字</strong>导致超出后，就需要进行截取了。如图：<br><img src="/pic/007i4MEmgy1g0xozzuz16g309q0hcnpe.gif" alt=""></p><pre><code class="Swift">@objc func onTextDidChange(sender: Notification) {    if textView.text.count &gt; maxTextSize {        let selectRange = textView.markedTextRange        if let selectRange = selectRange {            let position =  textView.position(from: (selectRange.start), offset: 0)            if (position != nil) {                // 高亮部分不进行截取，否则中文输入会把高亮区域的拼音强制截取为字母，等高亮取消后再计算字符总数并截取                return            }        }        textView.text = String(textView.text[..&lt;String.Index(encodedOffset: maxTextSize)])        // 对于粘贴文字的case，粘贴结束后若超出字数限制，则让光标移动到末尾处        textView.selectedRange = NSRange(location: textView.text.count, length: 0)    }}</code></pre><p>这样便把中文拼音高亮、联想词、复制粘贴等场景都考虑到了。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReactiveCocoa 入门与登录实战</title>
      <link href="/2019/04/13/reactivecocoa-tutorial/"/>
      <url>/2019/04/13/reactivecocoa-tutorial/</url>
      <content type="html"><![CDATA[<p>ReactiveCocoa 是 github 开源的一个<strong>函数式、响应式</strong>编程框架，是在 iOS 平台上对 FRP 的实现。<br><a id="more"></a></p><h1 id="RAC-解决的主要问题"><a href="#RAC-解决的主要问题" class="headerlink" title="RAC 解决的主要问题"></a>RAC 解决的主要问题</h1><p>iOS 开发中消息传递和回调机制一直很复杂，RAC 使用 Signal 来代替 KVO、Notification、Delegate 和 Target-Action 等传递消息，解决对象之间状态与状态依赖过多的问题，RAC 通常和 MVVM 结合在一起，在很多地方被用作 iOS 项目中 MVVM 架构的实践方式。</p><h1 id="常用几招"><a href="#常用几招" class="headerlink" title="常用几招"></a>常用几招</h1><h2 id="target-action类："><a href="#target-action类：" class="headerlink" title="target-action类："></a>target-action类：</h2><h3 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h3><p>需求：实时监听 textField 输入的字符串并打印。<br>传统 target-action 方式:</p><pre><code class="objc">//注册 selector[textField addTarget:self action:@selector(textChanged:) forControlEvents:UIControlEventEditingChanged];//实现 selector- (void)textChanged:(UITextField *)textField{      LxDBAnyVar(textField);}</code></pre><p>这里用到一个很方便的用于打印对象的工具<a href="https://github.com/DeveloperLx/LxDBAnything" target="_blank" rel="noopener">LxDBAnyVar</a><br>用 RAC 的方式:</p><pre><code class="objc">[[textField rac_signalForControlEvents:UIControlEventEditingChanged]   subscribeNext:^(id x) {    LxDBAnyVar(x);}];</code></pre><p>事实上对于所有 UIControl 子类的对象的事件监听都可以用这种方式。比如 UIButton 的<code>TouchUpInside</code>事件。<br>更简洁版本:</p><pre><code class="objc">[textField.rac_textSignal subscribeNext:^(NSString *x) {         LxDBAnyVar(x);}];</code></pre><h3 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h3><p>需求：为 UIView 添加点击事件。</p><pre><code class="objc">self.view.userInteractionEnabled = YES;UITapGestureRecognizer * tap = [[UITapGestureRecognizer alloc]init];      [[tap rac_gestureSignal] subscribeNext:^(UITapGestureRecognizer * tap) {        LxDBAnyVar(tap);    }];[self.view addGestureRecognizer:tap];</code></pre><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>需求：监听 app 进入后台的通知。</p><pre><code class="objc">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(NSNotification * notification) {        LxDBAnyVar(notification);}];</code></pre><p>注意：使用 RAC 监听通知不需要<code>removeObserver</code>。因为监听者是 RAC 内部持有的，RAC 会管理通知什么时候释放。</p><h3 id="定时器-NSTimer"><a href="#定时器-NSTimer" class="headerlink" title="定时器 NSTimer"></a>定时器 NSTimer</h3><p>需求1. 延迟某个时间后再做某件事。<br>更改<code>afterDelay</code>属性:</p><pre><code class="objc">[[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{        LxPrintAnything(rac);}];</code></pre><p>需求2. 每间隔多长时间做一件事。<br>更改<code>interval</code>属性:</p><pre><code class="objc">[[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]subscribeNext:^(NSDate * date) {        LxDBAnyVar(date);}];</code></pre><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>需求：监听点击了 AlertView 的哪一个按钮。</p><pre><code class="objc">UIAlertView * alertView = [[UIAlertView alloc]initWithTitle:@&quot;RAC&quot; message:@&quot;ReactiveCocoa&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Ensure&quot;, nil];  [[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple * tuple) {        LxDBAnyVar(tuple);        LxDBAnyVar(tuple.first);        LxDBAnyVar(tuple.second);        LxDBAnyVar(tuple.third);}];[alertView show];</code></pre><p><code>tuple</code>是 RAC 自己定义的集合类，特点是一个对象含有多个对象。此处对应 alertView 中的按钮。<br>更简单方式：</p><pre><code class="objc">[[alertView rac_buttonClickedSignal]subscribeNext:^(id x) {        LxDBAnyVar(x);}];</code></pre><p>RAC 取代代理有局限：<strong>只能是没有返回值（void）的代理方法。</strong></p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>需求：监听 scrollView 滑动时 contentOffset 的变化。</p><pre><code class="objc">[RACObserve(scrollView, contentOffset) subscribeNext:^(id x) {        LxDBAnyVar(x);}];</code></pre><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="RAC-常见类"><a href="#RAC-常见类" class="headerlink" title="RAC 常见类"></a>RAC 常见类</h2><h3 id="RACSignal-核心"><a href="#RACSignal-核心" class="headerlink" title="RACSignal (核心)"></a>RACSignal (核心)</h3><p>过程：创建信号 -&gt; 激活信号 -&gt; 废弃信号。<br>RAC的核心就是<code>RACSignal</code>，我们可以直接创建信号<code>createSignal</code>，并发送<code>sendNext</code>，当信号完成后用<code>dispose</code>销毁。</p><pre><code class="objc">// 1.创建信号RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        // block调用时刻：每当有订阅者订阅信号，就会调用block。        // 2.发送信号:注意signal本身不具备发送信号的能力，而是交给内部一个订阅者去发出。        [subscriber sendNext:@1];        // 如果不再发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。        [subscriber sendCompleted];        return [RACDisposable disposableWithBlock:^{            // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。            // 执行完Block后，当前信号就不在被订阅了。            NSLog(@&quot;信号被销毁&quot;);        }];    }];    // 3.订阅信号,才会激活信号.    [siganl subscribeNext:^(id x) {        // block调用时刻：每当有信号发出数据，就会调用block.        NSLog(@&quot;接收到数据:%@&quot;,x);    }error:^(NSError *error) {     NSLog(error);   }completed:^{     NSLog(@&quot;completed&quot;); }];</code></pre><h3 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h3><p>处理事件的类。如监听按钮点击，网络请求，可以把事件如何处理，事件中的数据如何传递等包装到这个类中。</p><pre><code class="objc">// 1.创建命令RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {    NSLog(@&quot;执行命令&quot;);    // 创建空信号,必须返回信号    //        return [RACSignal empty];    // 2.创建信号,用来传递数据    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [subscriber sendNext:@&quot;请求数据&quot;];        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。        [subscriber sendCompleted];        return nil;    }];}];// 强引用命令，不要被销毁，否则接收不到数据_conmmand = command;// 3.订阅RACCommand中的信号[command.executionSignals subscribeNext:^(id x) {    [x subscribeNext:^(id x) {        NSLog(@&quot;%@&quot;,x);    }];}];// RAC高级用法// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号[command.executionSignals.switchToLatest subscribeNext:^(id x) {    NSLog(@&quot;%@&quot;,x);}];// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。[[command.executing skip:1] subscribeNext:^(id x) {    if ([x boolValue] == YES) {        // 正在执行        NSLog(@&quot;正在执行&quot;);    }else{        // 执行完成        NSLog(@&quot;执行完成&quot;);    }}];// 5.执行命令[self.conmmand execute:@1];</code></pre><h2 id="RAC-常见宏"><a href="#RAC-常见宏" class="headerlink" title="RAC 常见宏"></a>RAC 常见宏</h2><h3 id="RAC-TARGET-KEYPATH-NIL-VALUE-…"><a href="#RAC-TARGET-KEYPATH-NIL-VALUE-…" class="headerlink" title="RAC(TARGET, [KEYPATH, [NIL_VALUE]]=…"></a>RAC(TARGET, [KEYPATH, [NIL_VALUE]]=…</h3><p>用于给某个对象的某个属性绑定信号。</p><pre><code class="objc">// 只要文本框文字改变，就会修改label的文字RAC(self.label,text) = _textField.rac_textSignal;</code></pre><h3 id="RACObserve-TARGET-KEYPATH"><a href="#RACObserve-TARGET-KEYPATH" class="headerlink" title="RACObserve(TARGET, [KEYPATH])"></a>RACObserve(TARGET, [KEYPATH])</h3><p>用于监听某个对象的某个属性,返回信号。</p><pre><code class="objc">[RACObserve(scrollView, contentOffset) subscribeNext:^(id x) {        NSLog(x);}];</code></pre><h2 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h2><h3 id="映射-flattenMap-Map"><a href="#映射-flattenMap-Map" class="headerlink" title="映射 flattenMap,Map"></a>映射 flattenMap,Map</h3><p>用于把源信号内容映射成新的内容。<br>Map 使用：</p><ol><li>传入一个block,类型是返回对象，参数是value。</li><li>value就是源信号的内容，直接拿到源信号的内容做处理。</li><li>把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。</li></ol><pre><code class="objc">[[_textField.rac_textSignal map:^id(id value) {        // 当源信号发出，就会调用这个block，修改源信号的内容        // 返回值：就是处理完源信号的内容。        return [NSString stringWithFormat:@&quot;输出:%@&quot;,value];    }] subscribeNext:^(id x) {        NSLog(@&quot;%@&quot;,x);}];</code></pre><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>多个异步请求都完成后，再做某件事。<br>将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的 signal 至少都有过一次 <code>sendNext</code>，才会触发合并的信号。</p><pre><code class="objc">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@1];   return nil;}];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@2];   return nil;}];// 把两个信号组合成一个信号,跟zip一样，没什么区别RACSignal *combineSignal = [signalA combineLatestWith:signalB];[combineSignal subscribeNext:^(id x) {   NSLog(@&quot;%@&quot;,x);}];</code></pre><p>当组合信号被订阅，内部会自动订阅signalA、signalB，必须两个信号都发出内容，才会被触发。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>用于信号发出的内容是元组，把信号发出元组的值聚合成一个值。<br>常见用法：先组合再聚合。</p><pre><code class="objc">combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock  RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@1];   return nil;}];RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {   [subscriber sendNext:@2];   return nil;}];// reduce中的block简介:// reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容// reduceblcok的返回值：聚合信号之后的内容。RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2){  return [NSString stringWithFormat:@&quot;%@ %@&quot;,num1,num2];}];[reduceSignal subscribeNext:^(id x) {   NSLog(@&quot;%@&quot;,x);}];</code></pre><h1 id="实战：用-RAC-实现登录模块"><a href="#实战：用-RAC-实现登录模块" class="headerlink" title="实战：用 RAC 实现登录模块"></a>实战：用 RAC 实现登录模块</h1><p><img src="/pic/005YhI8igy1fwa6avjzang30810ecaaw.gif" alt=""><br>如图是常见的一个登录需求，登录按钮在信息填写完整且符合规定前不可用，我们尝试用 RAC+MVVM 实现。项目结构如图：<br><img src="/pic/005YhI8igy1fwa6bdad76j30fc0jgzkf.jpeg" alt=""></p><h2 id="model-层"><a href="#model-层" class="headerlink" title="model 层"></a>model 层</h2><pre><code class="objc">@interface User : NSObject@property NSString  * user_id;@property NSString  * access_token;@property NSString  *phone_num;@property NSString  *password;@property BOOL      isLogin;@end</code></pre><h2 id="view-model-层"><a href="#view-model-层" class="headerlink" title="view-model 层"></a>view-model 层</h2><p><img src="/pic/005YhI8igy1fwa6bljc56j315y0d8wh7.jpeg" alt=""><br>MVVM 相比 MVC 多了 view-model 层，将原先 controller 层的大部分业务逻辑抽离出来，本案例主要涉及两个：</p><ol><li>判断是否允许登录</li><li>执行登录动作</li></ol><p>因此在 LoginViewModel 中设置两个信号。</p><pre><code class="objc">@interface LoginViewModel : NSObject@property(nonatomic,strong) User *user;//是否允许登录的信号@property(nonatomic,strong,readonly) RACSignal *enableLoginSignal;//执行登录操作的信号@property(nonatomic,strong,readonly) RACCommand *loginCommand;@end</code></pre><h3 id="判断是否允许登录"><a href="#判断是否允许登录" class="headerlink" title="判断是否允许登录"></a>判断是否允许登录</h3><pre><code class="objc">//    监听账号的属性值改变，把它们聚合为一个信号。_enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.user, phone_num),RACObserve(self.user, password)] reduce:^id(NSString *phone_num,NSString *password){    NSPredicate *phoneNum_prdicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;^1[3|4|5|7|8][0-9]\\d{8}$&quot;];    NSPredicate *pwd_predicate     = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;^.{6,}$&quot;];    return @([phoneNum_prdicate evaluateWithObject:phone_num] &amp;&amp; [pwd_predicate evaluateWithObject:password]);}];</code></pre><p>看得出来相比以前用<code>target-action</code>监听 textField 变化，再用<code>if...else</code>判断两个值是否都存在且合法，现在利用 RAC <code>conbine + reduce</code>处理信号，只需单个函数即可实现，代码清爽很多。</p><h3 id="执行登录动作"><a href="#执行登录动作" class="headerlink" title="执行登录动作"></a>执行登录动作</h3><pre><code class="objc">_loginCommand = [[RACCommand alloc]initWithSignalBlock:^RACSignal *(id input) {    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {        [User loginWithParameters:_user.mj_keyValues SuccessBlock:^(id returnValue) {            User* newUser = [User mj_objectWithKeyValues:returnValue];            _user.user_id      = newUser.user_id;            _user.access_token = newUser.access_token;            _user.isLogin      = YES;            [subscriber sendNext:@&quot;success&quot;];            [subscriber sendCompleted];        } FailureBlock:^(NSError *error) {            [subscriber sendNext:[NSString stringWithFormat:@&quot;登录失败!%@&quot;,error]];            [subscriber sendCompleted];        }];        return nil;    }];}];</code></pre><p>注意<code>raccommand</code>返回的需是一个信号，登录操作就在这里面，登录之后发送信号。<br><code>loginCommand</code>还可以监听登录状态。</p><pre><code class="objc">[[_loginCommand.executing skip:1]subscribeNext:^(id x) {    if ([x isEqualToNumber:@(YES)]) {        [Config showProgressHUDwithStatus:@&quot;登录中...&quot;];    } else {        [Config dismissHUD];    }}];@end</code></pre><h2 id="controller-层"><a href="#controller-层" class="headerlink" title="controller 层"></a>controller 层</h2><pre><code class="objc">@interface LoginVC : UIViewController@property (strong, nonatomic) IBOutlet UITextField    *accountTextField;@property (strong, nonatomic) IBOutlet UITextField    *pwdTextField;@property (strong, nonatomic) IBOutlet UIButton       *loginBtn;@property (strong,nonatomic ) LoginViewModel          *loginViewModel;@end</code></pre><h3 id="视图模型绑定"><a href="#视图模型绑定" class="headerlink" title="视图模型绑定"></a>视图模型绑定</h3><pre><code class="objc">// 给模型的属性绑定信号// 账号文本框一改变，就给 User 属性赋值    RAC(self.loginViewModel.user,phone_num) = _accountTextField.rac_textSignal;RAC(self.loginViewModel.user,password)  = _pwdTextField.rac_textSignal;// 为登录按钮的&quot;enable&quot;属性绑定信号RAC(self.loginBtn,enabled)              = self.loginViewModel.enableLoginSignal;</code></pre><h3 id="监听登录动作"><a href="#监听登录动作" class="headerlink" title="监听登录动作"></a>监听登录动作</h3><pre><code class="objc">// 监听登录按钮的点击,执行loginCommand[[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside]subscribeNext:^(id x) {// 执行登录    [self.loginViewModel.loginCommand execute:nil];}];</code></pre><h3 id="监听登录结果"><a href="#监听登录结果" class="headerlink" title="监听登录结果"></a>监听登录结果</h3><p>订阅<code>loginCommand</code>返回的信号，如果返回 success 就存储登录信息。</p><pre><code class="objc">[self.loginViewModel.loginCommand.executionSignals.switchToLatest subscribeNext:^(NSString* x) {    if ([x isEqualToString:@&quot;success&quot;]) {//  存储用户信息及登录状态，此处不能使用 realm 作数据库,realm 不允许在 observer 中 addObject。        NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];        [defaults setValue:_loginViewModel.user.phone_num forKey:@&quot;phone_num&quot;];        [defaults setValue:_loginViewModel.user.access_token forKey:@&quot;access_token&quot;];        [defaults setValue:[NSNumber numberWithInteger:_loginViewModel.user.user_id] forKey:@&quot;user_id&quot;];        [defaults setValue:[NSNumber numberWithBool:_loginViewModel.user.isLogin] forKey:@&quot;isLogin&quot;];        [defaults synchronize];        [self performSegueWithIdentifier:@&quot;toTabBarController&quot; sender:nil];    }}];</code></pre><blockquote><p>上述登录代码可<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">参考这里</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ReactiveCocoa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TableView 动态 cell 高度自适应方案</title>
      <link href="/2019/04/12/dynamic-height-cell/"/>
      <url>/2019/04/12/dynamic-height-cell/</url>
      <content type="html"><![CDATA[<p>相比安卓 ListView/RecylerView，iOS 中 TableViewCell 高度自适应是需要开发者自己想办法解决的，原因在于 tableview 的渲染机制默认是先获取 cell 高度，然后再去绘制 cell 体。由于 label/textview 等通常是高度不定的，cell 高度动态化是个很常见的需求。<br><a id="more"></a></p><h1 id="方案一：高度固定"><a href="#方案一：高度固定" class="headerlink" title="方案一：高度固定"></a>方案一：高度固定</h1><p>针对所有 Cell 具有固定高度的情况：</p><ol><li><code>self.tableView.rowHeight = 88;</code></li><li>实现协议方法 <code>heightForRowAtIndexPath:</code>。</li></ol><p><strong>缺点：</strong>不支持动态高度。</p><h1 id="方案二：cell-预估高度（iOS-7-）"><a href="#方案二：cell-预估高度（iOS-7-）" class="headerlink" title="方案二：cell 预估高度（iOS 7+）"></a>方案二：cell 预估高度（iOS 7+）</h1><p><strong>设计思路：</strong><br>加载 tableview 时一次性计算所有 cell 高度太耗性能。所以把计算 height 的任务从 load time 转移到 scrolling time。只有滑动到的 cell 会计算，屏幕外边的不会计算。<br>方法：<code>tableView: estimatedHeightForRowAtIndexPath:</code><br>这是 iOS 7.0 出现的 UITableViewDelegate 中的方法,表示返回某行 cell 的预估高度。这个方法改变了 TableView 代理方法的调用顺序。<br>未调用<code>estimatedHeightForRow...</code>方法时：<br><img src="/pic/005YhI8igy1fwa5hooy28j30f105z75c.jpeg" alt=""><br>调用<code>estimatedHeightForRow...</code>后：<br><img src="/pic/005YhI8igy1fwa5i5kg83j30fb03t0th.jpeg" alt=""><br>此时 tableView 工作原理：</p><ol><li>tableView 先向代理拿得到每个 cell 的预估高度(<code>estimatedHeightForRow...</code>方法)，并且拿这个高度去计算整个 tableView 应该显示的范围。</li><li>根据每行预估的高度，算出一屏显示的 cell 的个数，并先对这些 cell(调用<code>cellForRow...</code>方法)进行绘制。</li><li>绘制时拿到 cell 的真实高度,然后放在<code>heightForRow...</code>方法里面拿给 tabelView 去用。</li><li>屏幕滚动(有 cell 进入屏幕)的时候,仍然会调用绘制以及获取真实高度的方法。</li></ol><p>简单点说，预估高度用来让 tableView 心里有个底，把 cell 先绘制出来，但最后实际的 cell 高度还是会从<code>heightForRow...</code>方法中获取。</p><p><strong>缺点：</strong></p><ol><li>设置估算高度后，<code>tableview.contentSize.height</code>根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</li><li>估算高度使加载速度更快，但侵害滑动流畅性，cell较多情况下滑动时实时计算高度带来的卡顿是明显能体验到的。</li></ol><h1 id="方案三：self-sizing-cell-（iOS-8-）"><a href="#方案三：self-sizing-cell-（iOS-8-）" class="headerlink" title="方案三：self-sizing cell （iOS 8+）"></a>方案三：self-sizing cell （iOS 8+）</h1><p><strong>设计思路：</strong><br>如图，row123 是已经在屏幕上被展示的cell, 而 row4 是下一个会被展示的cell, 这时 row4 这个 cell 的 rowHeight 是预先为其设置的 estimated height， 又或者是  UITableViewDelegate 中返回的 height。<br>当用户滚动的时候，首先 cell 会被创建或重用，然后 cell 会被调用调整 size 的方法， 接着 cell 会根据 tableView 的size去调整自身的 contentSize，最后cell被展示出来。<br><img src="http://ww2.sinaimg.cn/mw690/005tGCqhjw1f9fwywhi35j308p07zq31.jpg" alt=""><br>如何让一个cell去调整自己的高度？</p><ol><li>cell 要使用 Autolayout 布局；</li><li>在 tableView 中启动动态布局, 告诉 tableView 用新的方法来布局行高.而不是 rowHeight 或者 delegate 方法。<br><code>tableView.rowHeight = UITableViewAutomaticDimension;</code></li></ol><p><strong>缺点：</strong></p><ol><li>仅支持iOS 8+；</li><li>高度没有缓存。iOS 7 计算高度后有”缓存“机制，不会重复计算；iOS 8 不论何时都会重新计算 cell 高度。</li></ol><h1 id="方案四：FDTemplateLayoutCell（iOS-6-）"><a href="#方案四：FDTemplateLayoutCell（iOS-6-）" class="headerlink" title="方案四：FDTemplateLayoutCell（iOS 6+）"></a>方案四：FDTemplateLayoutCell（iOS 6+）</h1><p>好处：既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。</p><ol><li>根据 autolayout 约束自动计算高度。使用了系统在 iOS6 提供的 API：<code>-systemLayoutSizeFittingSize:</code></li><li>根据 indexPath 的一套高度缓存机制。<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了多余计算。</li><li>自动的缓存失效机制。<br>UITableView 刷新时，已有的高度缓存将以最小的代价失效。如删除一个 indexPath 为 [0:5] 的 cell，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li><li>预缓存机制（通过 runloop 实现）。<br>UITableView 没有滑动的空闲时刻会计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性。</li></ol><p><strong>缺点：</strong><br>要求约束设置完整准确，保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。（这个实际上是<code>systemLayoutSizeFittingSize:</code>的要求）。</p><p>从易用性、性能、高度自适应效果、适配 iOS 最低版本综合来看，方案四是最佳的。但需要引入第三方库，同时要保证 autolayout 约束完整准确才行，关于这点<a href="https://www.jianshu.com/p/386b792054b1" target="_blank" rel="noopener">《UITableViewCell高度自适应的关键点》</a>总结得很好：</p><blockquote><p>Cell 内部的 Constraints 一定要有一条从 Cell 顶部到底部的一条可联通线。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ruby on Rails 初探</title>
      <link href="/2019/04/11/rails-tutorial/"/>
      <url>/2019/04/11/rails-tutorial/</url>
      <content type="html"><![CDATA[<p><a href="https://rubyonrails.org" target="_blank" rel="noopener">Ruby on Rails</a> 是一个使用 Ruby 语言写的开源 Web 应用框架，它是严格按照 MVC 结构开发的。目标是努力使自身保持简单，使用最少的配置和代码。后来的 Django(Python)、Laravel(PHP)、 ChicagoBoss(Erlang)等框架都借鉴了 rails 的设计思想。Twitter、GitHub、Groupon，国内的暴走漫画、薄荷网等前期都是用 rails 作为主要的开发框架。虽然现在已经每况日下（ruby小众、性能不佳、社区活跃度低、学习门槛高…），但 rails 仍是一个了不起的框架。本文使用 rails 搭建一个类似 <a href="https://www.meetup.com" target="_blank" rel="noopener">Meetup</a> 的平台，体会 rails 开发的一些基础要素。<br><a id="more"></a></p><h1 id="Vagrant-VirtualBox-打造跨平台开发环境"><a href="#Vagrant-VirtualBox-打造跨平台开发环境" class="headerlink" title="Vagrant+VirtualBox 打造跨平台开发环境"></a>Vagrant+VirtualBox 打造跨平台开发环境</h1><p><a href="https://www.vagrantup.com/" target="_blank" rel="noopener">Vagrant</a> + <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VirtualBox</a> 应该是目前为止我找到的安装 ubuntu 虚拟机最简单的方式。在 rails 项目中使用 vagrant 搭建开发环境最直观的好处有三个：</p><ul><li>快。vagrant 重新封包后的 box 很小（远小于 Vmware 克隆出来的虚拟机），因此安装 ubuntu 不到10分钟完成。</li><li>共享文件夹。我可以用在 mac 使用 sublime+git 开发，同时在 ubuntu 虚拟机中运行 rails+mysql。二者同步。<br><img src="/pic/005YhI8igy1fwrgqo9erpj31j80ssgpf.jpeg" alt=""></li><li>方便协作。与队友合作的时候打包一个已经配置好的 package 直接拿给队友用就可以了。免去了不同机子上折腾环境的问题，极大提高了效率。</li></ul><blockquote><p>这里有一篇<a href="https://github.com/astaxie/Go-in-Action/blob/master/ebook/zh/01.1.md" target="_blank" rel="noopener">详细介绍</a></p></blockquote><h1 id="Rails-Way"><a href="#Rails-Way" class="headerlink" title="Rails Way"></a>Rails Way</h1><p><img src="/pic/005YhI8igy1fwrgqyivz0j30oj0dvdgy.jpeg" alt=""><br>rails 的根本骨架是上面的 MVC 结构。<br>浏览器一个请求进来(这个请求首次是由浏览器输入主页地址敲下 enter 之后，其它是从 view 中的<code>link_path</code>来的，比如按钮点击)，首先由路由代码分发给响应的 controller 来响应该次请求（首次是返回root主页，其它都是在 controller 中定义的 action），controller 选择合适的 html 文件渲染，同时可能有对 model 层的操作，最终响应这次请求。数据放在 model 中，处理后传递给 controller。 具体可见这张图：<br><img src="/pic/005YhI8igy1fwrgr4ou5mj31fu164nfh.jpeg" alt=""><br>如网址首页 root 请求由 page controller 响应，page controller 选择 views 下的同名文件夹之下的 welcome.html (后缀一般是.html.erb )进行渲染。其余请求处理过程都是如此。</p><h1 id="layout-解决代码重复问题"><a href="#layout-解决代码重复问题" class="headerlink" title="layout 解决代码重复问题"></a>layout 解决代码重复问题</h1><p>一个项目不同 html 间总有大量重复代码，如 welcome 和 about ，rails 用 layout 解决。打开本项目/layout/application.html.erb可以看到：<br><img src="/pic/005YhI8igy1fwrgrcap0jj30s40cc0v3.jpeg" alt=""><br>具体到需要复用该布局的html只要写<code>yield</code>中的内容即可。</p><h1 id="Asset-Pipeline"><a href="#Asset-Pipeline" class="headerlink" title="Asset Pipeline"></a>Asset Pipeline</h1><p>图片和css/js资源在assets下，分别由 application.js 和 application.css 统一管理。<br><img src="/pic/005YhI8igy1fwrgrieqkqj30co0d8wfq.jpeg" alt=""><br>这样在 application.html.erb 中不必再引入所有.css和.js，只要一句<code>&lt;%= stylesheet_link_tag &quot;application&quot; %&gt;</code> 就解决了，代码清爽了很多。多说一句，rails 自带支持 sass ，只要把后缀改为 .css.scss 就可以。</p><h1 id="Rails-接口操作数据库"><a href="#Rails-接口操作数据库" class="headerlink" title="Rails 接口操作数据库"></a>Rails 接口操作数据库</h1><p>本项目用 mysql, rails 操作数据库有一套非常简便的接口。<br>创建数据库:</p><pre><code class="ruby">rake db:create</code></pre><p>建表： 更改数据库的表结构，rails 给出的方法是<code>migration</code>。</p><pre><code class="ruby">rails g migration CreateIssues</code></pre><p>生成的数据库在 db/migrate 下：<br><img src="/pic/005YhI8igy1fwrgroxv1xj30ja0cutbj.jpeg" alt=""><br>数据库建好后就可以创建 model 了。</p><h1 id="Partial-实现数据与模版分离"><a href="#Partial-实现数据与模版分离" class="headerlink" title="Partial 实现数据与模版分离"></a>Partial 实现数据与模版分离</h1><p>先补充一点：上面那张 MVC 的图中 controller 和 view 之间那条线是可以传递数据的。这也是 controller 读取 model 层数据交给 view 层进行显示的方式。<br><img src="/pic/005YhI8igy1fwrgrubxxgj30yg0ih75q.jpeg" alt=""><br>主页下边需要显示 issues 列表，包括 issue 的标题、评论数、评论数目等属性。<br><img src="/pic/005YhI8igy1fwrgs04lf3j30v00e1whc.jpeg" alt=""><br>每条 issue 都从 controller 中添加数据和样式显然不合适。rails 的解决方案是<code>partials</code> ，把页面中固定的某个模块抽取出来。如本例中的_issue_list.html.erb 用来管理 issue_list 。具体步骤：先创建数据库并创建对应的 model，请求传来的时候，page_controller 读取数据库内容， partial 定义 model 的显示逻辑，html 用 render 插入 partial ，数据库的内容便呈现给用户了。rails 中的 partials 和 layout 机制都为简化 html 代码，优化架构发挥了很大作用。<br><img src="/pic/005YhI8igy1fwrgs5d6frj3142056abn.jpeg" alt=""></p><h1 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h1><h2 id="读取展示"><a href="#读取展示" class="headerlink" title="读取展示"></a>读取展示</h2><ul><li>先在model层为issues添加content，对issues表执行add_column操作。</li><li>添加路由， get ‘/issues/:id’ =&gt; “issues#show”</li><li>generator 自动创建 controller,同时可以生成对应的 show 模版。controller中定义<code>show action</code>，view 中定义好样式。read 操作完成。</li></ul><h2 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a>删除资源</h2><ul><li>先从 view 入手，定义删除按钮和链接。</li><li>添加路由<code>delete &#39;issues/:id&#39; =&gt; &#39;issues#destroy&#39;</code></li><li>controller 中实现<code>destroy</code>方法（对 model 的操作）。</li></ul><h1 id="Strong-Parameters-防止表单攻击"><a href="#Strong-Parameters-防止表单攻击" class="headerlink" title="Strong Parameters 防止表单攻击"></a>Strong Parameters 防止表单攻击</h1><p>本项目中允许用户发布issue,是通过表单实现的。具体方法是 Issue 的<code>create</code>方法。</p><pre><code class="ruby">def create    Issue.create(params[:issue])  redirect_to :rootend</code></pre><p>这样可以向数据库中写入数据，但直接这么提交会报错。</p><pre><code class="ruby">ActiveModel::ForbiddenAttributesError</code></pre><p>这个是 rails 为了防止坏人通过表单提交攻击网站，而采用的自我保护机制。如果不加说明坏蛋们就可以在<code>params[:issue]</code> 中人为植入其他的参数，比如<code>admin: true</code>这样就可以给他自己管理员权限了，所以必须要你自己指明哪些字段是允许直接用 params 里的参数来修改的。<br>rails3 创建或更新 Active Record 对象时，Model 中需要列一个白名单，声明哪些属性可以被 parameter 的数据更新。rails4 中用的是 Strong Parameters 的机制，Model 不再负责白名单的维护，把过滤非法属性的职责推给了 Controller。<br>View 层穿过来的数据会转化为一个<code>ActionController::Parameters</code>对象<br>过滤老的<code>ActionController::Parameters</code>对象，生成一个新的。</p><ul><li>只保留白名单属性</li><li>实例变量 @permitted 赋为 true</li></ul><p>只有 @permitted 为 true 时才可传入 model 层。 具体到本例： 到 issue_controller.rb 中添加：</p><pre><code class="ruby">private    def issue_params    params.require(:issue).permit(:title, :content)  end</code></pre><p>create 方法改为：</p><pre><code class="ruby">Issue.create(issue_params)</code></pre><h1 id="rails-的-DRY-don’t-repeat-yourself-原则"><a href="#rails-的-DRY-don’t-repeat-yourself-原则" class="headerlink" title="rails 的 DRY(don’t repeat yourself) 原则"></a>rails 的 DRY(don’t repeat yourself) 原则</h1><p>rails 简化代码有许多优秀的机制。</p><ul><li>layout 抽取可复用代码。对应<code>&lt;%yield%&gt;</code>。</li><li>partials 抽取页面中相对独立的模块。对应<code>render</code>。同样可起到代码复用的作用。</li><li>resources 集成 model 的 CURD 操作<br><img src="/pic/005YhI8igy1fwrgsg5ztnj30mp0ip420.jpeg" alt=""></li></ul><h1 id="资源间建立一对多关系"><a href="#资源间建立一对多关系" class="headerlink" title="资源间建立一对多关系"></a>资源间建立一对多关系</h1><p>前面创建了 issues 表，接着要为每个 issue 添加 comment。 先创建 model：</p><pre><code class="ruby">rails g model comment content:text username:string email:string issue_id:integer</code></pre><p>再创建对应的路由和 controller, controller 中定义 comment 的 create 方法。如何在/issues/show.html 中显示所有 comment? 这就涉及到在两个 model 间建立一对多的关系。</p><ul><li>确保 comments 表里面有<code>issue_id</code>这个字段，注意，<strong>名字一个字都不能错</strong>，因为要用它是和 issues 表产生映射关系的纽带。</li><li>到 issue.rb 文件中添加<code>has_many :comments</code></li><li>到 comment.rb 中，添加<code>belongs_to :issue</code></li></ul><p>同理，user 和 comment/issues 各自之间的一对多关系都是这么映射的。<br><img src="/pic/005YhI8igy1fwrgsmz306j30k006sgmo.jpeg" alt=""><br><img src="/pic/005YhI8igy1fwrgt1cvz8j30is05ojse.jpeg" alt=""><br>这样就可以直接使用<code>issue.comments</code>,<code>comment.issue</code>这样方便的表达。</p><pre><code class="ruby">def show     @issue = Issue.find(params[:id])   @comments = @issue.commentsend</code></pre><h1 id="加密及验证"><a href="#加密及验证" class="headerlink" title="加密及验证"></a>加密及验证</h1><p>注册登录是一个网站最基本的用户管理模块。如何把注册表单中提交的明文密码进行加密存储，登录时又如何将用户输入的明文密码与加密后的密码进行匹配？rails 提供一个强大的接口解决 —— <a href="http://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html" target="_blank" rel="noopener">has_secure_password</a>.</p><ul><li>在 Gemfile 里面添加 Bcrypt。</li><li>users 这张表里设置<code>password_digest</code>字段。（表明要存储的是加密后的密码）</li><li>User model添加<code>has_secure_password</code>.</li><li>controller 定义<code>reate</code>方法：</li></ul><pre><code class="ruby">def create    user = User.new(user_params)  user.save  redirect_to :rootendprivate    def user_params    params.require(:user).permit!  end</code></pre><p>注意这里的<code>strong parameter</code>。使用<code>has_secure_password</code>方法后sign up 的行为（数据库创建新用户，密码加密后存储）就都自动完成了。至于登录时的密码匹配工作是由 authenticate 这个方法完成的（后边会看到）。 去数据库看一下：</p><pre><code class="ruby">rails c  u = User.first  </code></pre><p><img src="/pic/005YhI8igy1fwrgt95ughj30zc04o760.jpeg" alt=""><br>可以看到密码是加密后的。</p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>session 是 rails 中一个默认就有的方法，可以向里面存放数据，那么只要一直打开网站，那么用户存储的数据就一直存在。<br><img src="/pic/005YhI8igy1fwrgtfy8a1j30mg0ca0ux.jpeg" alt=""><br>规定 session 中存放<code>user_id</code>，怎么显示用户名？rails 中有一个约定俗成的方法<code>current_user</code>:</p><pre><code class="ruby">def current_user    @current_user ||= User.find(session[:user_id]) if session[:user_id]end  helper_method :current_user  </code></pre><p>这样随时可以知道当前是否有用户在线以及在线用户信息。</p><h1 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h1><p>session 存放的数据是临时性的，如果网站关闭了或是关机重启了，session 中的数据也就丢失了。实现<code>remember me</code>需要 cookie 。cookie 可以把服务器发过来的数据保留成一个<strong>本地硬盘</strong>上的一个文件。另外，rails 同样提供了一个方法叫<code>cookies</code> 可以方便开发者操作 cookie。<br>实现remember的关键代码：</p><pre><code class="ruby">cookies.permanent[:auth_token] = user.auth_token  </code></pre><p>如果用户不打算 remember me:</p><pre><code class="ruby">cookies[:auth_token] = user.auth_token</code></pre><p>这种效果跟 session 是一样的。<br>用户在 cookie 中怎么存储？<br>cookie 中的数据是要存到本地的，显然不能直接把用户id存起来。所以通过为每一个用户生成一串随机数，用来代表他的身份。数据库中为每个 User 添加<code>auth token</code>字段（base 64存储）：</p><pre><code class="ruby">rails g migration AddAuthTokenToUsers auth_token:string  </code></pre><p>生成<code>auth_token</code>方法：</p><pre><code class="ruby">before_create { generate_token(:auth_token) }def generate_token(column)    begin    self[column] = SecureRandom.urlsafe_base64  end while User.exists?(column =&gt; self[column])end  </code></pre><h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><p>rails 自带的<code>validator</code>接口基本满足最常用的情况。user model中：</p><pre><code class="ruby">validates :name, :email, presence: true  validates :name, :email, uniqueness: { case_sensitive: false }  </code></pre><p><code>presence: true</code>表明 name/email 都是必填项。<code>uniqueness</code>保证唯一性。<code>validator</code> 接口方法的触发时机是在向数据库中 save 之前。因此之前 user 的 create 方法中保存 cookie 前要加判断条件<code>if user.save</code> 。save 成功说明已经通过 validator 的验证。</p><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><p>rails中使用<code>i18N</code>实现国际化。<br>application.rb 设置语言类型： </p><pre><code class="ruby">config.i18n.default_locale = &#39;zh-CN&#39;</code></pre><p>书写 zh-CN.yml, 将需要翻译的词进行翻译。</p><h1 id="优化体验"><a href="#优化体验" class="headerlink" title="优化体验"></a>优化体验</h1><h2 id="atwho"><a href="#atwho" class="headerlink" title="atwho"></a>atwho</h2><p>用到<a href="https://github.com/ichord/jquery-atwho-rails" target="_blank" rel="noopener">jquery-atwho-rails gem</a>, comment_box 添加<br><img src="/pic/005YhI8igy1fwrgpvuzw9j314s0eawhr.jpeg" alt=""><br>基本原理就是定义一个数组，拿到页面上的所有用户名，检查有无重复。</p><h2 id="hot-keys"><a href="#hot-keys" class="headerlink" title="hot keys"></a>hot keys</h2><p>用到<a href="https://github.com/jeresig/jquery.hotkeys" target="_blank" rel="noopener">jquery.hotkeys</a>, comment_box 添加<br><img src="/pic/005YhI8igy1fwrgtpfnkpj314o0aw76k.jpeg" alt=""><br><code>13</code>对应回车键，<code>ctrKey</code>对应 ctrl，<code>metaKey</code>在 Mac 下对应 Command 键， Windows 下应该对应 Window 键。</p><h2 id="markdown-格式支持"><a href="#markdown-格式支持" class="headerlink" title="markdown 格式支持"></a>markdown 格式支持</h2><p>用到<a href="https://github.com/vmg/redcarpet" target="_blank" rel="noopener">redcarpet</a>, application_helper.rb 中：<br><img src="/pic/005YhI8igy1fwrgu5dmk1j31380hsq6a.jpeg" alt=""><br><code>html_safe :</code>如果去掉，页面中刷新会出现 html 标签，这是一种<strong>安全机制</strong>，防止有人嵌入 html 代码来实现对网站的攻击。不过前面<code>filter_html: true</code>已经过滤掉了可能导致安全隐患的 html 标签。所以就可以放心的来添加 <code>.html_safe</code>来让 rails 放弃这种安全机制了。</p><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>用到<a href="https://github.com/tmm1/pygments.rb" target="_blank" rel="noopener">pygemnt</a></p><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>这里涉及到的只是非常简单的权限控制，包括只有登录用户<code>(@current_user)</code>能发布 issue，只有 issue 的作者本人可以删除或编辑<br>issue: </p><pre><code class="ruby">&lt;% if current_user &amp;&amp; current_user == @issue.user %&gt; </code></pre><p>可以看出主要是通过<code>current_user</code>实现的，同时要设置好 user 和 issue 的一对多关系。</p><h1 id="ActionMailer-实现-mail-服务"><a href="#ActionMailer-实现-mail-服务" class="headerlink" title="ActionMailer 实现 mail 服务"></a>ActionMailer 实现 mail 服务</h1><p>ActionMailer 用户注册后发送欢迎邮件。 代码写在<code>user.save</code>之后： </p><pre><code class="ruby">UserMailer.welcome_email(@user).deliver</code></pre><p>生成 UserMailer 和 welcome email 方法。再修改 user mailer.rb，就跟 controller action 差不多，再写一个 view 文件－－邮件正文。实现发邮件功能需要集成第三方服务<a href="https://www.mailgun.com" target="_blank" rel="noopener">Mailgun</a>或国内的<a href="https://www.sendcloud.net" target="_blank" rel="noopener">sendCloud</a>。</p><blockquote><p><a href="https://github.com/zltunes/Meetup" target="_blank" rel="noopener">源码</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> rails </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为 ViewControllers 瘦身</title>
      <link href="/2019/04/10/light-viewcontrollers/"/>
      <url>/2019/04/10/light-viewcontrollers/</url>
      <content type="html"><![CDATA[<p>目标：写可维护的代码。<br><a id="more"></a></p><h2 id="把-TableView-从-VC-中抽离"><a href="#把-TableView-从-VC-中抽离" class="headerlink" title="把 TableView 从 VC 中抽离"></a>把 TableView 从 VC 中抽离</h2><p>UITableView 可以说是 iOS 界面开发中用的最广泛的组件，就我自己做过的项目而言，绝大部份 ViewController 都是在围绕 UITableViewDelegate 和 UITableViewDataSource 中的方法打交道。但说到底这些函数都是 View 层面的，全部在 VC 中处理显得不太合适，也不利于日后的维护和扩展，所以关于瘦身 VC 很容易想到一点是从 VC 中抽离 tableView 的表示逻辑。这种思想其实与最近火热的<a href="http://www.cnblogs.com/ludashi/p/4211556.html" target="_blank" rel="noopener">MVVM</a>设计模式相通。核心是<strong>把逻辑代码尽量移到 model 层</strong>, 你可以认为它是一个中间层 , 逻辑代码可以是各种 delegate,网络请求,缓存,数据库,coredata 等, 而 controller 正是用来组织串联他们，使得整个程序走通。</p><h3 id="把-Data-Source-分离出来"><a href="#把-Data-Source-分离出来" class="headerlink" title="把 Data Source 分离出来"></a>把 Data Source 分离出来</h3><p>举例:当需要将一个数组映射到一个 tableView 进行显示，这种一一对应关系可以单独写一个类<code>ArrayDataSource</code>，使用 block 或者 delegate 设置 cell。ArrayDataSource 类完全可以复用到任何需要将一个数组的内容映射到一个 tableView 的场景。<br>ArrayDataSource 中声明 <code>block(cell,item)</code> 来初始化 cell，block实现方式（item 和 cell 如何对应）则可以在 cell+Configure 的 category 中声明。<br>使用<code>ArrayDataSource</code>，在<code>ViewController</code>中执行<code>setUpTableView</code>即可。<code>setUpTableView</code>中实现 block（可以是执行 configure 方法的方式）。使用 cell 类 category 的方式是为了避免向 dataSource 暴露 cell 的设计,说白了是为了更好得分离 view 和 model 层。</p><blockquote><p><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank" rel="noopener">1.1 参考项目看这里</a></p></blockquote><h3 id="把-Data-Source-和-Delegate-都分离出来"><a href="#把-Data-Source-和-Delegate-都分离出来" class="headerlink" title="把 Data Source 和 Delegate 都分离出来"></a>把 Data Source 和 Delegate 都分离出来</h3><p>1.1中的方法是在<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a>一文中提到的。但该文讲的只是把<code>UITableViewDataSource</code>中的方法提取到一个单独的类，从结果来看，是把<code>numberOfRowsInSection</code>和<code>cellForRowAtIndexPath</code>从 VC 中提取出去。但实际上<code>UITableViewDelegate</code>也是可以抽象出去的。例如 cell 的生成, cell 行高, 点击事件等等。这里用 block 实现回调。<br>处理类<code>TableViewDataSourceDelegate.h</code></p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void    (^TableViewCellConfigureBlock)(NSIndexPath *indexPath, id item, XTRootCustomCell *cell) ;typedef CGFloat (^CellHeightBlock)(NSIndexPath *indexPath, id item) ;typedef void    (^DidSelectCellBlock)(NSIndexPath *indexPath, id item) ;@interface TableViewDataSourceDelegate : NSObject &lt;UITableViewDelegate,UITableViewDataSource&gt;//初始化方法: 传数据源, cellIdentifier, 三个block分别对应配置, 行高, 点击。- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock ;//将UITableViewDataSource和UITableViewDelegate设于TableViewDataSourceDelegate。- (void)handleTableViewDatasourceAndDelegate:(UITableView *)table ;//默认indexPath.row对应每个dataSource相应返回item。- (id)itemAtIndexPath:(NSIndexPath *)indexPath ;@end</code></pre><p>在 1.1 中为了避免 model 和 view 的耦合，将 cell 的配置用 category 方法处理。但使用的方式是每一个<code>UITableViewCell</code>都做了扩展，实际上可以做得更彻底 ——直接对这些子类的父类<code>UITableViewCell</code>进行扩展。这样做的好处是比 1.1 的扩展方法更加灵活，可以提供多个 configure 方法，针对不同类型的 model 进行数据展示，同时也增强 cell 的移植性。<br>为 UITableViewCell 提供扩展<code>UITableViewCell+Extension.h</code></p><pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;@interface UITableViewCell (Extension)//实际是tableView reigister nib，由于是与cell(view)紧密相关的方法，故在cell本身进行实现，而非在vc中。+(void) registerTable:(UITableView*)table        nibIdentifier:(NSString*)identifier;//根据数据源配置并绘制cell 子类需重写该方法-(void)configure:(UITableViewCell*)cell       customObj:(id)obj       indexPath:(NSIndexPath*)indexPath;//根据数据源计算cell的高度 子类可重写该方法, 若不写为默认值44.0+(CGFloat)getCellHeightWithCustomObj:(id)obj                        indexPath:(NSIndexPath*)indexPath;@end</code></pre><p>如此，对于每一个 cell 子类，实现两个新方法:</p><pre><code class="objc">- (void)configure:(UITableViewCell *)cell        customObj:(id)obj        indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}+ (CGFloat)getCellHeightWithCustomObj:(id)obj                            indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}</code></pre><p>OK,做了这么多工作，返回 VC 看一下最后的成果吧！瘦身后的 viewController 对于 tableView 的所有处理都只需要一个方法<code>setUpTableView</code></p><pre><code class="objc">- (void)setupTableView{    TableViewCellConfigureBlock configureCell = ^(NSIndexPath *indexPath, MyObj *obj, XTRootCustomCell *cell) {        [cell configure:cell customObj:obj indexPath:indexPath] ;    } ;    CellHeightBlock heightBlock = ^CGFloat(NSIndexPath *indexPath, id item) {        return [MyCell getCellHeightWithCustomObj:item indexPath:indexPath] ;    } ;    DidSelectCellBlock selectedBlock = ^(NSIndexPath *indexPath, id item) {        NSLog(@&quot;click row : %@&quot;,@(indexPath.row)) ;    } ;    self.tableHandler = [[TableDataDelegate alloc] initWithItems:self.list                                                   cellIdentifier:MyCellIdentifier                                               configureCellBlock:configureCell                                                  cellHeightBlock:heightBlock                                                   didSelectBlock:selectedBlock] ;    [self.tableHander handleTableViewDatasourceAndDelegate:self.table] ;}</code></pre><blockquote><p>1.2 <a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">参考项目看这里</a></p></blockquote><h3 id="抽离-TableView-终极版"><a href="#抽离-TableView-终极版" class="headerlink" title="抽离 TableView 终极版"></a>抽离 TableView 终极版</h3><p>经过 1.2 的处理，<code>UITableViewDelegate</code> 和 <code>UITableViewDataSource</code> 的方法都已经移到<code>TableViewDataSourceDelegate</code>这个类中处理，但根据<br><a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">1.2参考项目</a>可以发现1.2的处理方式有局限性，我们观察<code>TableViewDataSourceDelegate</code>中的核心方法:</p><pre><code class="objc">- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock;</code></pre><p><code>TableViewDataSourceDelegate</code>进行初始化时需传递参数<code>CellIdentifier</code>和<code>aHeightBlock</code>,实际开发工作中这两者通常是和<code>UITableViewCell</code>类紧密相关的。一类 <code>UITableViewCell</code>往往对应一个它自己的 <code>CellIdentifier</code> 和 <code>cellHeight</code>，如果初始化<code>TableViewDataSourceDelegate</code>对象时就指定这两个属性，则<code>TableViewDataSourceDelegate</code>仅局限于被一种 tableView 复用:cell种类都相同，也就是用一个tableView展示一个数组( indexPath.row 对应数组下标)。如图：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezscp180r2j30af0hz755.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005tGCqhjw1ezscrw6qbyj30ah0icgnm.jpg" alt=""><br>这些 cell 都是同一种类，但实际开发中往往面临着更复杂的 cell 样式，如我在开发<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">校友圈</a>时：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezsd219avzj30ag0ikaau.jpg" alt=""><br>这种情况怎么使用<code>TableViewDataSourceDelegate</code>呢？修改<code>TableViewDataSourceDelegate</code>的 init 方法：</p><pre><code class="objc">(id)initWithItems:(NSDictionary *)anItemsconfigureCellBlock:(TableViewCellConfigureCellBlock)aConfigureCellBlock   cellHeightBlock:(CellHeightBlock)aHeightBlock    didSelectBlock:(DidSelectCellBlock)aDidSelectBlock;</code></pre><h2 id="业务逻辑移到-model-中"><a href="#业务逻辑移到-model-中" class="headerlink" title="业务逻辑移到 model 中"></a>业务逻辑移到 model 中</h2><p>尽管 viewController 最主要功能是处理业务逻辑，但对于一些和 model 联系紧密，和 view 关系不大（即不是 model 和 view 进行交互的逻辑）的代码应移到 model 中，通常是用 category 的处理方法，更加清晰。</p><h2 id="网络请求逻辑移到-model"><a href="#网络请求逻辑移到-model" class="headerlink" title="网络请求逻辑移到 model"></a>网络请求逻辑移到 model</h2><p>用 category 方式处理。viewController 使用 block 回调请求网络。</p><h2 id="view-代码移到-view-层"><a href="#view-代码移到-view-层" class="headerlink" title="view 代码移到 view 层"></a>view 代码移到 view 层</h2><p>不要在 viewController 中构建复杂的 view 层次结构。<br>要注意的是，IB 并非只能和 viewControllers 一起使用，可以加载单独的 nib 文件到自定义的 view 中。</p><blockquote><p>参考：<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 程序证书及签名机制</title>
      <link href="/2019/04/06/iosapp-certificate-signature/"/>
      <url>/2019/04/06/iosapp-certificate-signature/</url>
      <content type="html"><![CDATA[<p>最近在研究除了 Apple 官方途径，iPhone手机上安装应用的其他途径。顺便总结下 iOS 开发中涉及的一套证书及签名机制。<br><a id="more"></a></p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是非对称加密和摘要算法的结合。防止中途篡改文本内容，保证文本的完整性，以及文本是由指定的权限者发的。<br>发布方加密过程:<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9n5536maxj307k0gwjru.jpg" alt=""><br>接收方验证过程：<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9n560603pj30hw0ja407.jpg" alt=""></p><h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>数字证书就是通过数字签名实现的数字化的证书。简单讲数字证书包含以下信息:</p><ul><li>签发机构：CA（苹果公司）</li><li>被签发人：企业 / 开发者</li><li>验证方：iOS 设备</li><li>验证过程：固化在 iOS 系统中</li><li>证书链：根是苹果的CA</li></ul><h1 id="iOS-开发：证书申请、签名打包"><a href="#iOS-开发：证书申请、签名打包" class="headerlink" title="iOS 开发：证书申请、签名打包"></a>iOS 开发：证书申请、签名打包</h1><p><img src="/pic/ioscertificate1.png" alt=""><br>这张图阐述了，开发iOS应用程序时，从申请证书，到打包的大致过程。简单总结如下：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9nxlzvnsvj31kw0g678v.jpg" alt=""><br><strong>数字证书的作用：</strong><br>证明app的所属以及app的完整性，保证app本身是安全的。</p><h1 id="iOS授权和描述文件"><a href="#iOS授权和描述文件" class="headerlink" title="iOS授权和描述文件"></a>iOS授权和描述文件</h1><p><code>mobileprovision</code>是为了证明 app 所使用的某些服务是被苹果认可的，如 Push 证书。<br><code>mobileprovision</code>包含：</p><ul><li>AppId。</li><li>使用哪些证书。</li><li>功能授权列表。</li><li>可安装的设备列表（UDID）。</li><li>苹果签名。</li></ul><h1 id="ipa文件"><a href="#ipa文件" class="headerlink" title=".ipa文件"></a>.ipa文件</h1><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9nzfmyp6uj30n204imxu.jpg" alt=""><br><code>.iTunesMetadata.plist</code>文件用来记录app的基本信息，例如购买者的appleID，app购买时间、app支持的设备体系结构，app的版本、app标识符等。<br>解压/payload中的.app文件可看到.ipa主要的文件结构：<br><img src="http://pchou.qiniudn.com/ipa%E7%BB%84%E6%88%90.png" alt=""></p><ul><li>_CodeSignature/CodeResources：程序包中（除 Frameworks）所有文件的签名。</li><li>embedded.mobileprovision：打包时使用。</li><li>SC_Info(图中未列出)：包含两个文件<ol><li>appname.sinf 为 metadata 文件</li><li>appname.supp 为解密可执行文件的密钥</li></ol></li></ul><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f9nzic64qtj30w80i6tb7.jpg" alt=""><br>Xcode 打包生成 ipa 文件过程中利用当前证书私钥进行代码、资源文件的数字签名，将其存放在_CodeSignature文件夹下。</p><h1 id="关于-iTunes-授权"><a href="#关于-iTunes-授权" class="headerlink" title="关于 iTunes 授权"></a>关于 iTunes 授权</h1><p>每个 Apple ID 最多授权5台电脑（用来登录iTunes下载app和管理同步手机）。5的限制是通过扫描硬盘序列号来确认。<br>iTunes 授权时，需要连接 Apple 服务器进行验证，通过验证后，会将授权信息以加密文件的形式，存放在<a href="https://discussions.apple.com/thread/1715932?tstart=0" target="_blank" rel="noopener">SC_Info</a>文件夹。这些文件是隐藏的，可通过<a href="http://www.bresink.com/osx/TinkerTool.html" target="_blank" rel="noopener">TinkerTool</a>查看。<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9o6jx1dq8j30j402oab9.jpg" alt=""><br>iTunes 授权后，即可登录 Apple ID 并将该账号下购买过的应用同步到 iPhone 中。XX 助手工具便通过“欺骗授权”的方式，为每个用户修改或虚拟出一个相同的硬盘序列号，接着，“这台电脑”取得一个公共 id 的授权，然后把公共id买过的 app 装到某 iOS 设备中。达到一个账号给多台设备（5台以上）共享使用的目的。</p><h1 id="账号共享分发"><a href="#账号共享分发" class="headerlink" title="账号共享分发"></a>账号共享分发</h1><p><a href="http://www.pc6.com/edu/53793.html" target="_blank" rel="noopener">这篇文章</a>讲到在 windows 平台下使用账号共享分发app的方法。简单总结如下：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f9o8njxtpoj312a0acdhu.jpg" alt=""><br>同步授权后可以使用iTunes，也可以使用itools安装分享者另外发布出来的所有应用。</p><h1 id="ipa-文件安装后的校验过程"><a href="#ipa-文件安装后的校验过程" class="headerlink" title="ipa 文件安装后的校验过程"></a>ipa 文件安装后的校验过程</h1><p>App安装到ios系统上时，系统首先通过描述文件找到数字证书，通过证书里的苹果数字签名，验证证书的有效性。如果证书有效，取出证书中的开发者公钥，解密App的数字签名。如果发现摘要一致，则验证通过，App成功安装在手机上，其中一个环节有问题，验证工作就失败。</p><blockquote><p><a href="http://www.pchou.info/ios/2015/12/14/ios-certification-and-code-sign.html" target="_blank" rel="noopener">漫谈iOS程序的证书和签名机制</a><br><a href="http://e-intuit.hk/kuaiyong-piracy.html" target="_blank" rel="noopener">iTools第三方市场分发原理</a><br><a href="https://objccn.io/issue-17-2/" target="_blank" rel="noopener">代码签名探析</a><br><a href="https://xiuchundao.me/post/code-resources-and-embedded-mobileprovision-included-in-ipa-file" target="_blank" rel="noopener">签过名的ipa文件</a><br><a href="http://www.pc6.com/edu/53793.html" target="_blank" rel="noopener">多个授权文件共存的正确方法</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器人操作系统（ROS/Android）对比</title>
      <link href="/2019/04/05/robot-operating-system-intro/"/>
      <url>/2019/04/05/robot-operating-system-intro/</url>
      <content type="html"><![CDATA[<p>目前很多互联网公司都在开发自己的硬件产品（小米的小爱同学，腾讯听听音箱、叮当等），包括深圳这边一家非常有名的人形机器人公司<a href="https://www.ubtrobot.com/cn/" target="_blank" rel="noopener">优必选</a>，有的机器人产品注重屏幕和交互，有的则注重路径、物体、语音及人脸识别等高级算法，除了安卓，还有不少人形机器人是基于 ROS 开发的。<br><a id="more"></a></p><h1 id="ROS"><a href="#ROS" class="headerlink" title="ROS"></a>ROS</h1><p>ROS(Robot Operating System) 是一个在计算机上对机器人进行操作的一个开源系统（严格来讲是一种操作系统中间件）。它提供类似操作系统所提供的功能，包含硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间的消息传递、程序发行包管理，它也提供一些工具程序和库用于获取、建立、编写和运行多机整合的程序。支持多种语言，C++、Python、Octave和LISP，也支持多种语言混合使用。</p><h1 id="基本框架和概念"><a href="#基本框架和概念" class="headerlink" title="基本框架和概念"></a>基本框架和概念</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li>main：核心部分，提供一些分布式计算的基本工具，以及整个ROS的核心部分。</li><li>universe：一种是库的代码，如OpenCV、PCL等；库的上一层是从功能角度提供的代码，如人脸识别，他们调用下层的库；最上层的代码是应用级的代码，让机器人完成某一确定的功能。</li></ul><h2 id="三个级别"><a href="#三个级别" class="headerlink" title="三个级别"></a>三个级别</h2><p>计算图级—&gt;文件系统级—&gt;社区级。</p><h3 id="计算图级"><a href="#计算图级" class="headerlink" title="计算图级"></a>计算图级</h3><p>计算图是ROS处理数据的一种点对点的网络形式。程序运行时，所有进程以及他们所进行的数据处理，将会通过一种点对点的网络形式表现出来。<br><img src="http://images.ncnynl.com/ros/2016/1365775358_7354.png" alt=""></p><ul><li>节点：执行运算任务的进程。</li><li>消息：节点之间是通过传送消息进行通讯的（标准数据类型或嵌套结构和数组）。</li><li>主题：消息以一种发布/订阅的方式传递。一个节点可以在一个给定的主题中发布消息。一个节点针对某个主题关注与订阅特定类型的数据。<br><img src="http://images.ncnynl.com/ros/2016/1365775624_5015.png" alt=""></li><li>服务：主题是广播式的。单播（同步传输模式）用服务，服务以一个字符串和一对严格规范的消息定义：一个用于请求，一个用于回应。</li><li>ROS 控制器：给ROS的节点存储了主题和服务的注册信息，是一个超级管理员，管理系统中所有节点，包括节点之间的相互通信。</li></ul><p>ROS 系统基本结构：<br><img src="/pic/c455a744b61037c6472ae5f724adbb3d_b.png" alt=""><br>举例：机器人上有一个摄像头，我们希望能够从机器人图像处理单元以及另外一台计算机上观察摄像头的图像。<br><img src="/pic/2bbba65b21edd83177b4e8a8c24bd7ee_b.png" alt=""></p><ol><li>需要一个管理员 ROS Master 管理整个系统，然后建立三个节点，分别是摄像头节点、机器人中的图像处理节点以及计算机上的显示节点。</li><li>在ROS Master的管理下，摄像头节点(Camera Node)发起一个主题(Topic)发送图像信息，同时，另外两个节点订阅这个主题(Topic)。</li><li>当摄像头节点从摄像头获得一帧新的图像时，它将立刻将获得的图像发送给另外两个节点（基于TCP/IP）。</li><li>如果机器人图像处理节点需要在某一个特定的时刻向摄像头节点请求一个信息，这种情况采用服务。图像处理节点可以告诉ROS Master，我需要向摄像头节点请求一项服务，然后ROS Master 将在摄像头节点和图像处理节点之间建立一个请求服务/应答的联系通道。图像处理节点将首先请求图像信息，然后摄像头节点将收集所需要的信息发送给图像处理节点。<br><img src="/pic/73c32ee87d2d30c4c6674202ed24f28d_b.png" alt=""></li></ol><h3 id="文件系统级"><a href="#文件系统级" class="headerlink" title="文件系统级"></a>文件系统级</h3><p>在硬盘上面查看的ROS源代码的组织形式。<br><img src="http://images.ncnynl.com/ros/2016/1365776297_4808.png" alt=""><br>ROS的软件以包的方式组织起来。包包含节点、ROS依赖库、数据套、配置文件、第三方软件、或者任何其他逻辑构成。<br>堆是包的集合，它提供一个完整的功能，像“navigation stack”。<br><img src="http://images.ncnynl.com/ros/2016/1365776550_5049.png" alt=""></p><h2 id="对ros的一些理解"><a href="#对ros的一些理解" class="headerlink" title="对ros的一些理解"></a>对ros的一些理解</h2><p>根据<a href="http://courses.cs.washington.edu/courses/cse466/11au/calendar/ros_cc_1_intro-jrsedit.pdf" target="_blank" rel="noopener">这个教程</a>，ROS 虽然号称是操作系统，但实际并不是传统意义上的操作系统。它只是一个通信的架构、一个代码管理的框架。操作系统的功能：任务的时序规划和CPU资源分配等等工作都是依靠linux来实现的，因此ROS不可能脱离linux，他们是一体的。</p><p>机器人的核心平台——多传感器和处理器之间的通信、处理器和执行器之间的通信，这些通信必须有统一的时钟，比如做传感器数据融合，如果从传感器抓回来的数据时间上都不同步，那融合根本没法做。ROS的通信架构，主要解决的就是这个问题：让设备之间的通信有一个统一的调度中枢(roscore)，通过这个调度中枢不但可以让信号传递更好控制，还能够通过构建通信设备之间的关系来让开发者明白自己的机器人内部在干什么。</p><p>综上总结：我们可以把ros理解成一套基于Linux的能够协调各种传感器和CPU工作的开发框架。</p><h1 id="基于安卓系统的机器人开发"><a href="#基于安卓系统的机器人开发" class="headerlink" title="基于安卓系统的机器人开发"></a>基于安卓系统的机器人开发</h1><p>在安卓进行机器人开发没有像在 Ubuntu 上ROS一样被广泛使用的开发框架。从网上看到的一些例子来看，基于安卓的机器人开发主要涉及以下内容：</p><ul><li>硬件平台：器件选型以及主要运动模块的制作和实现。</li><li>软件平台：Linux 内核和<br>Android 操作系统在实体机上的编译，往实验平台上烧写在实体<br>机中编译的 Linux 内核镜像和 Android 操作系统镜像。</li><li>针对实际需要对实验平台的硬件接口进行功能重设：设计编写硬件驱动程序，并将其在 Linux 内核中进行编译识别，最后为新编译的驱动设计编写硬件驱动层和硬件访问服务层的实现程序，使得 Android 应用程序中能够使用这些硬件。</li><li>安卓应用程序开发。可以是开发板应用软件，也可以有远程控制端软件，实现对机器人的运动控制。</li></ul><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ol><li>Ubuntu 和 Android 都可以看做基于Linux内核的不同版本。Ubuntu是机器人领域里开发最受欢迎的一个版本，就是因为ROS。80%的ROS都是运行在Ubuntu上的。从官方信息看，ros移植到安卓上是可行的，官网也有一些不成熟的教程。（有人做了这样的尝试：<a href="https://en.wikipedia.org/wiki/Robot_Operating_System" target="_blank" rel="noopener">文章来源</a>）。<blockquote><p>The native Java ROS client library, rosjava, has enabled ROS-based software to be written for the Android OS.</p></blockquote></li><li>ROS能够支持多种语言，如C++、python、Octave和LISP，甚至支持多种语言混合使用。Android支持Java和C++（NDK层）。</li><li>如果只是一个交互，像触摸屏，让它发声，Android是没有问题的，但如果让机器人做人脸、声音、路径识别，这些算法自己来实现是很困难的，而ros有很多人会把库贡献在这个平台上，为开发者提供了很多方便。</li><li>如果产品是重交互，轻路径、人脸识别，或者人工智能这样场景的产品，安卓比较好；但是如果产品有更多的机会用到一些复杂算法，则 Ubuntu+ROS 应该是更好的选择。</li></ol><h1 id="其他机器人系统"><a href="#其他机器人系统" class="headerlink" title="其他机器人系统"></a>其他机器人系统</h1><ul><li><a href="http://36kr.com/p/211741.html" target="_blank" rel="noopener">V-sido</a>：日本一家公司开发的系统，做的是类似于ros的事情。</li></ul><blockquote><p>参考资料：<br><a href="http://www.fabiao.net/content-43-2074548-1.html" target="_blank" rel="noopener">基于Android的双目视觉机器人运动平台无线网络控制系统</a><br><a href="http://download.farsight.com.cn/download/pdf/Farsight120317bj-2-Android.pdf" target="_blank" rel="noopener">基于Android机器人–智能家居</a><br><a href="http://v.youku.com/v_show/id_XMTc4MDgxOTg1Ng==.html?f=28518141&amp;o=0" target="_blank" rel="noopener">Ubuntu Core 和SNAP 开发技术介绍</a><br><a href="https://zhuanlan.zhihu.com/p/20769823" target="_blank" rel="noopener">Programming Robots with ROS</a><br><a href="http://www.ncnynl.com/archives/201609/838.html" target="_blank" rel="noopener">ros教程</a><br><a href="http://www.devstore.cn/new/newInfo/19371.html" target="_blank" rel="noopener">机器人开源项目盘点</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ROS </tag>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iPhone &amp; Android 换机通信方案分析</title>
      <link href="/2019/03/08/ios-android-transfer/"/>
      <url>/2019/03/08/ios-android-transfer/</url>
      <content type="html"><![CDATA[<p>目前市面上的换机产品（QQ同步助手、闪电换机等）都是支持 Android to Android 的场景，如果在 iPhone 作为旧机，安卓做新机，可将 libmobiledevice 库（目前支持Mac、Windows、Linux平台）移植到安卓，拿到 iPhone 手机的本地应用信息、多媒体文件、通讯录等，从而进行换机操作。<br><a id="more"></a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f9itoognq5j30nq0bwju0.jpg" alt=""><br>如图，通过某种方式将 iOS 与 Android 设备相连，在 Android 设备上读取 iPhone 手机上的通讯录、图片、音乐、视频、app 等信息，进一步实现：</p><ol><li>在两台设备间实现数据迁移。</li><li>通过 Android 设备给 iPhone 分发下载应用。 </li></ol><p>可以简单理解为安卓手机上实现类似 iTunes 的功能。</p><h1 id="现在市场上有没有类似应用"><a href="#现在市场上有没有类似应用" class="headerlink" title="现在市场上有没有类似应用"></a>现在市场上有没有类似应用</h1><p>有的。</p><h2 id="借助-PC-端通信"><a href="#借助-PC-端通信" class="headerlink" title="借助 PC 端通信"></a>借助 PC 端通信</h2><p><a href="http://www.itools.cn/" target="_blank" rel="noopener">iTools</a> / <a href="http://www.25pp.com/" target="_blank" rel="noopener">PP助手</a> / <a href="http://www.kuaiyong.com/" target="_blank" rel="noopener">快用</a> 等都是 有着“无需越狱，即可同步”功能类似 itunes 的苹果设备同步管理软件。均提供 PC 端和手机端应用。从官网描述看，这些应用可以提供的服务主要有两个：</p><ol><li>数据管理、同步与备份（短信、联系人、照片、音乐等）。</li><li>和 iTunes 一样进行 iOS 应用程序的安装与卸载（<strong>这种功能是违反苹果规定的</strong>）。</li></ol><p><img src="https://4.bp.blogspot.com/-E2wAUHVmKqw/Whgk4bPYF6I/AAAAAAAB468/VSAVGPxKmVMovRNDjSRUMRTtzV8aGWSKQCLcBGAs/s1600/iTools_2017-11-24_214021.png" alt=""></p><h2 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h2><p>诸如 <a href="https://play.google.com/store/apps/details?id=com.sec.android.easyMover&amp;hl=en" target="_blank" rel="noopener">Samsung Smart Switch Mobile</a> 或 <a href="https://play.google.com/store/apps/details?id=com.sonymobile.xperiatransfermobile&amp;hl=en" target="_blank" rel="noopener">Xperia™ Transfer Mobile</a> 均提供两台设备间数据传输的功能，初衷是为了满足换机用户将旧手机里的所有资料、数据、应用导入新手机的需求。既支持 Android -&gt; Android，也支持 iOS -&gt; Android。具体用法<a href="http://www.samsung.com/hk_en/support/smartswitch/" target="_blank" rel="noopener">看这里</a>。</p><h1 id="获取-iDevice-数据可能的途径"><a href="#获取-iDevice-数据可能的途径" class="headerlink" title="获取 iDevice 数据可能的途径"></a>获取 iDevice 数据可能的途径</h1><h2 id="iTunes"><a href="#iTunes" class="headerlink" title="iTunes"></a>iTunes</h2><p><a href="http://www.apple.com/cn//itunes/download/" target="_blank" rel="noopener">iTunes</a> 既是一款媒体播放器，也是苹果官方提供的用于管理 iOS 设备的主要工具。通过 iTunes 可同步和备份 iPhone 上的音乐、视频、录音、电子书等。<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f9ivq6q6qcj30xk07q76t.jpg" alt=""><br>此外还可以<a href="http://stackoverflow.com/questions/26720764/install-ipa-with-itunes-12" target="_blank" rel="noopener">通过 iTunes 向 iOS 设备安装 ipa 文件</a>。</p><h2 id="iCloud"><a href="#iCloud" class="headerlink" title="iCloud"></a>iCloud</h2><p><a href="https://www.icloud.com/" target="_blank" rel="noopener">iCloud</a> 是苹果公司所提供的云存储和云计算服务。用户能在 iCloud 中存储音乐、照片、App、联系人和日历等，并将无线推送到用户所有支持 iCloud 同步的设备上，这也是它和 iTunes 提供的同步功能不同的一点 —— 不用使用连接线。<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f9iw0q1pnij30xw0aotb6.jpg" alt=""></p><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>参考 iTunes 和 iCloud 工作方式，可以猜想实现 iPhone 与安卓设备数据同步的方式有两种（不借助 PC 端，Samsung Smart Switch Mobile 确实提供了这两种同步方式）：</p><ol><li><a href="https://www.youtube.com/watch?v=KbV5Qkl8xl0" target="_blank" rel="noopener">有线</a>。（通过 Micro USB 相连，iPhone 识别相连设备并信任后，打开安卓应用直接进行同步）。</li><li><a href="https://www.youtube.com/watch?v=Oz4chv6gRw8" target="_blank" rel="noopener">无线</a>。（在安卓应用输入 iCloud 账号和密码，登录后获取 iCloud 中的备份数据并同步）。</li></ol><p>而如果要在安卓设备进行 iOS 应用的管理（获取现有应用列表、安装、卸载），则只能是通过有线的方式实现。</p><h1 id="libimobiledevice"><a href="#libimobiledevice" class="headerlink" title="libimobiledevice"></a>libimobiledevice</h1><p>苹果官方提供了 iTunes 的 Mac 版和 windows 版，不支持Linux系统。一些 Linux 高手不能忍受因为要连接 iOS 设备就换用操作系统，因此就有人逆向出 <strong>iOS 设备与 Windows/Mac Host 接口的<a href="http://www.libimobiledevice.org/docs/mobilesync.html" target="_blank" rel="noopener">通讯协议</a></strong>，最终成就了横跨三大桌面平台的非官方版本 USB 接口 library —— <a href="http://www.libimobiledevice.org/" target="_blank" rel="noopener">libimobiledevice</a>。官方描述：</p><blockquote><p>libimobiledevice is a cross-platform software library that talks the protocols to support iPhone®, iPod Touch®, iPad® and Apple TV® devices. Unlike other projects, it does not depend on using any existing proprietary libraries and does not require jailbreaking. It allows other software to easily access the device’s filesystem, retrieve information about the device and it’s internals, backup/restore the device, manage SpringBoard® icons, manage installed applications, retrieve addressbook/calendars/notes and bookmarks and (using libgpod) synchronize music and video to the device. The library is in development since August 2007 with the goal to bring support for these devices to the Linux Desktop.</p></blockquote><p>简而言之就是它不依赖于第三方库，跨平台的实现了 iPhone，iPod Touch，iPad 等苹果设备的通讯协议。可以看作和 iTools 一样，都是可以替代iTunes，进行 iOS 设备管理的工具。因为<a href="https://github.com/libimobiledevice" target="_blank" rel="noopener">源码是开放的</a>，可以自行编译，众多开发者便利用这个库开发出了各种基于不同平台的 iOS 设备管理工具。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> iOS </tag>
            
            <tag> iPhone </tag>
            
            <tag> 换机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Guetzli 图片透明优化方案调研</title>
      <link href="/2018/10/17/google-guetzli/"/>
      <url>/2018/10/17/google-guetzli/</url>
      <content type="html"><![CDATA[<p>介绍一种谷歌开源的新的 JPEG 图片压缩算法，以及和 libjpeg/webP/sharpP 的对比。<br><a id="more"></a></p><h1 id="结论要点"><a href="#结论要点" class="headerlink" title="结论要点"></a>结论要点</h1><ul><li>效果：Guetzli 算法可在图片质量不变的情况下，将 JPEG 文件大小降低35%.</li><li>原理：聚焦 JPEG 压缩算法流程的量化阶段；利用 Butteraugli 图像差异算法确定应该保留和丢弃哪些颜色和细节。</li><li>优势：相比 webP/sharpP，优势在于压缩后仍为标准 JPG 格式，无兼容问题；相比libjpeg，优势在于相同质量系数下，压缩率更低。</li><li>劣势：编码耗资源、时间长。</li></ul><h1 id="JPEG-压缩算法简介"><a href="#JPEG-压缩算法简介" class="headerlink" title="JPEG 压缩算法简介"></a>JPEG 压缩算法简介</h1><p><a href="http://blog.csdn.net/carson2005/article/details/7753499" target="_blank" rel="noopener">这篇文章</a>详细阐述了 JPEG 图像的压缩算法，基本系统的JPEG压缩编码算法一共分为11个步骤。为方便理解，这11个步骤又可以简化为三个过程：<strong>色彩空间变换——离散余弦变换——量化阶段</strong>。<br>前两个过程将图像数据转换为 DCT 频率系数，有些复杂，但不是该技术的核心。可以理解为在前两项技术压缩大小已经固定的情况下，<strong>优化最后一项量化阶段</strong>。而量化阶段的操作有点类似很多图像处理软件的“另存为”：选择的视觉质量越小，它就损失越多，图片就会被压缩越小。但这个量化阶段的重点是如何取舍图像质量和图像大小这些细节问题。</p><h1 id="Guetzli-原理"><a href="#Guetzli-原理" class="headerlink" title="Guetzli 原理"></a>Guetzli 原理</h1><p>量化阶段需要两个8*8量化矩阵数据，一个是专门处理亮度的频率系数，另一个是针对色度的频率系数，将频率系数除以量化矩阵的值之后取整，即完成了量化过程。当频率系数经过量化之后，将频率系数由浮点数转变为整数，这才便于执行最后的编码。<br>下图是常用 JPEG 的亮度量化表和色度量化表，该量化表是从广泛的实验中得出的。我们也可以自定义量化表。量化表是控制 JPEG 压缩比的关键，这个步骤除掉了一些高频量, 损失了很多细节信息。但事实上人眼对高频信号的敏感度远没有低频信号那么敏感。所以处理后的视觉损失很小，压缩方案的优化方向是在一定程度上得到<strong>相对清晰的图像和更高的压缩率</strong>。<br><img src="/pic/Guetzli1.png" alt=""><br><img src="/pic/Guetzli2.png" alt=""><br>Guetzli算法就是在这个步骤引入了一个叫做 <strong>Butteraugli</strong> 的精神视觉模型——它用来决定保存哪些颜色或者细节、压缩掉哪些细节，从而达到人们视觉上的最优，且图像文件更小。<br>这个模型如何以一种更全面更详细的方式来结合色彩感知和视觉掩蔽，从而在最小化损失和最小化图像尺寸中达到平衡？大致遵循如下的评价体系：</p><ul><li>人眼对强黄色光附近蓝光变化是不敏感的，因此黄光区域附近的蓝光可以用更少的bit来编码。</li><li>人眼对蓝光有着较低的空间分辨率，视网膜中用于分辨高清细节的区域没有蓝色光的受体，故高频区域的蓝色光部分可以用更粗的粒度编码。</li><li>将图像中的噪声区域分辨出来进行粗粒度的编码。</li></ul><p>基于这三点，Guetzli主要从两方面下手来进行：</p><ul><li>对全局量化表进行微调，枚举很多张 JPG 的全局量化表，看哪个量化表更合适。</li><li>对 DCT 系数的高频部分进行有选择的丢弃。</li></ul><p>Guetzli 算法的一次优化大致分为三个阶段：<br><img src="/pic/Guetzli3.jpeg" alt=""></p><h1 id="压缩效果肉眼观察质量"><a href="#压缩效果肉眼观察质量" class="headerlink" title="压缩效果肉眼观察质量"></a>压缩效果肉眼观察质量</h1><p><img src="/pic/Guetzli4.png" alt=""><br>（猫眼图）左为原图，中为 libjpeg 的处理，右为 Guetzli。<br>第三张看起来颜色较淡；猫眼之外第三张比第二张像素块更少。<br><img src="/pic/Guetzli5.png" alt=""><br>（天空中的一条电线）左为原图，中为 libjpeg 的处理，右为 Guetzli。<br>可以看出第二张和第三张电线均出现像素块，电线之外的天空里第三张像素块比第二张更少。</p><h1 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h1><p>公司有部门通过比较 libjpeg, guettzli, webp 的压缩率、压缩延时、压缩资源、解压性能，对 guetilz 在线上的可用性进行了评估。根据试验结果总结表格如下：<br><img src="/pic/Guetzli6.jpeg" alt=""><br>从表格看出：</p><ul><li>相比webp， guettzli 优势在于更广的兼容性，此外网络环境越好， guettzli 解压效率越高。</li><li>相比流行的 libjpeg 算法，其优势在于在压缩后图片质量表现差不多的情况下，guettzli 压缩率表现更好。</li><li>guettzli 最大的缺点是编码过程耗资源和时间。</li></ul><p><img src="/pic/Guetzli7.jpeg" alt=""></p><ul><li>整体压缩效果 guetzli &gt; libjpg（优12%-33%）.</li><li>guetzli在高质量系数下，压缩率表现更好。</li></ul>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 10 通知更新详解</title>
      <link href="/2018/10/16/ios10-notification/"/>
      <url>/2018/10/16/ios10-notification/</url>
      <content type="html"><![CDATA[<p>关于「通知」iOS 10 新增了一个框架 <a href="https://developer.apple.com/reference/usernotifications?language=objc" target="_blank" rel="noopener">UserNotifications.framework</a>，即“用户通知框架”，推送 “Push” 只是「通知」触发的一种方式，而「通知」是操作系统层面的一种UI展示。<br><a id="more"></a><br>苹果官方文档中 Notification 分为两类：</p><ul><li>Remote (远程，即 Push 方式)</li><li>Local (本地，通知由本地事件触发，iOS 10 中有三种不同的触发 “Trigger” 方式，下文有详细说明)</li></ul><p>所以，「推送」只是「通知」的一种触发方式，从 iOS 迭代更新的历史特征中看，「通知」一直是被苹果作为重点内容来延展的。iOS 10 中新增了独立框架（之前一直存在于 UIKit Framework 中）还有丰富的特性更新。</p><h1 id="更新概览"><a href="#更新概览" class="headerlink" title="更新概览"></a>更新概览</h1><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><ol><li>Familiar API with feature parity</li><li>Expanded content</li><li>Same code path for local and remote notification handling</li><li>Simplified delegate methods</li><li>Better notification management</li><li>In-app presentation option</li><li>Schedule and handle notifications in extensions</li><li>Notification Extensions</li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li>相同的特性使用类似API（之前的功能API使用方法类似但是还是稍有改变）</li><li>内容扩展（支持附件和展示更多内容）</li><li>本地通知和远程通知操作代码在相同调用路径（合并代理方法）</li><li>简化代理方法</li><li>更好的通知管理（支持通知查、改、删；增强本地通知管理，增加日历与地理位置事件的触发）</li><li>应用内通知展示（之前App在前台的情况下收到通知不会UI展示）</li><li>在Extensions中规划和操作通知（使更新通知内容和删除误发或过期的通知内容成为可能，另一个重要场景为端到端加密）</li><li>引入通知Extensions</li></ol><h1 id="用-UserNotifications-Framework-实现通知"><a href="#用-UserNotifications-Framework-实现通知" class="headerlink" title="用 UserNotifications Framework 实现通知"></a>用 UserNotifications Framework 实现通知</h1><h2 id="在-Xcode-中启用推送通知"><a href="#在-Xcode-中启用推送通知" class="headerlink" title="在 Xcode 中启用推送通知"></a>在 Xcode 中启用推送通知</h2><p>要使用 UserNotifications Framework 需在 Xcode 项目中开启推送通知：<br>Project Target –&gt; Capabilities –&gt; Push Notifications<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f7sxvwcvu0j30go0cidgz.jpg" alt=""></p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><pre><code class="Objective-C">#import &lt;UserNotifications/UserNotifications.h&gt;</code></pre><h2 id="注册推送"><a href="#注册推送" class="headerlink" title="注册推送"></a>注册推送</h2><pre><code class="Objective-C">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // iOS 10 before    UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];    [application registerUserNotificationSettings:settings];    // iOS 10    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];    [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) {        if (!error) {            NSLog(@&quot;request authorization succeeded!&quot;);        }    }];    return YES;}</code></pre><h2 id="Token-Registration"><a href="#Token-Registration" class="headerlink" title="Token Registration"></a>Token Registration</h2><p>跟之前一样：</p><pre><code class="Objective-C">[[UIApplication sharedApplication] registerForRemoteNotifications];</code></pre><h2 id="Notification-Settings"><a href="#Notification-Settings" class="headerlink" title="Notification Settings"></a>Notification Settings</h2><p>之前注册推送服务，首次安装 APP 后弹出授权推送通知框，用户点击了同意还是不同意，以及用户之后又做了怎样的更改我们是无从得知的，现在 apple 开放了这个 API，我们可以直接获取到用户的设定信息了。</p><pre><code class="Objective-C">[center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {        NSLog(@&quot;%@&quot;,settings);}];</code></pre><p>打印 settings 如下：</p><pre><code class="Objective-C">&lt;UNNotificationSettings: 0x16567310; authorizationStatus: Authorized, notificationCenterSetting: Enabled, soundSetting: Enabled, badgeSetting: Enabled, lockScreenSetting: Enabled, alertSetting: NotSupported,carPlaySetting: Enabled, alertStyle: Banner&gt;</code></pre><p><code>settings.authorizationStatus</code>有三个值：</p><pre><code class="Objective-C">typedef NS_ENUM(NSInteger, UNAuthorizationStatus) {    // 用户还没决定是否允许开启推送通知.    UNAuthorizationStatusNotDetermined = 0,    // 不允许开启通知.    UNAuthorizationStatusDenied,    // 允许开启.    UNAuthorizationStatusAuthorized} __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);</code></pre><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>以前只能展示一条文字，现在可以有 title 、subtitle 以及 body.<br><img src="http://ww4.sinaimg.cn/large/005tGCqhgw1f7syzclsj2j30og0dcmz8.jpg" alt=""><br>定制方法：</p><pre><code class="Objective-C">//Local NotificationUNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];content.title = @&quot;Introduction to Notifications&quot;;content.subtitle = @&quot;Session 707&quot;;content.body = @&quot;Woah! These new notifications look amazing! Don’t you agree?&quot;;content.badge = @1;//Remote Notification{&quot;aps&quot; : {    &quot;alert&quot; : {          &quot;title&quot; : &quot;Introduction to Notifications&quot;,          &quot;subtitle&quot; : &quot;Session 707&quot;,                  &quot;body&quot; : &quot;Woah! These new notifications look amazing! Don’t you agree?&quot;                },    &quot;badge&quot; : 1        },}</code></pre><h2 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h2><p>本地通知新增了两种新的 Triggers —— 日历和地理位置。日历 Triggers 让开发者可以根据指定的日期和时间来展示本地通知，并且支持循环条件，如“每周二上午十一点”这种条件。地理位置 Triggers 可以在进入或者离开指定区域时触发本地通知，如“某品牌App在你进入该品牌线下店铺的范围内即展示最新优惠信息”等。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f7t4uo402xj30og0dc75e.jpg" alt=""><br>Triggers 有三种值：</p><ul><li>UNTimeIntervalNotificationTrigger</li><li>UNCalendarNotificationTrigger</li><li>UNLocationNotificationTrigger</li></ul><pre><code class="Objective-C">//2 分钟后提醒UNTimeIntervalNotificationTrigger *trigger1 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:120 repeats:NO];//每小时重复 1 次（循环）UNTimeIntervalNotificationTrigger *trigger2 = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:3600 repeats:YES];//每周一早上 8：00 提醒我NSDateComponents *components = [[NSDateComponents alloc] init];components.weekday = 2;components.hour = 8;UNCalendarNotificationTrigger *trigger3 = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES];//#import &lt;CoreLocation/CoreLocation.h&gt;//一到麦当劳就喊我下车CLRegion *region = [[CLRegion alloc] init];UNLocationNotificationTrigger *trigger4 = [UNLocationNotificationTrigger triggerWithRegion:region repeats:NO];</code></pre><h2 id="Add-Request"><a href="#Add-Request" class="headerlink" title="Add Request"></a>Add Request</h2><pre><code class="Objective-C">NSString *requestIdentifier = @&quot;sampleRequest&quot;;UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifier                                                                          content:content                                                                          trigger:trigger1];[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {}];</code></pre><h2 id="通知实现小结"><a href="#通知实现小结" class="headerlink" title="通知实现小结"></a>通知实现小结</h2><ul><li>Local Notifications:<ol><li>定义 <code>Content</code>. </li><li>定义 <code>Trigger</code>.</li><li>向 <code>UNUserNotificationCenter</code> 发送 <code>request</code>.</li></ol></li></ul><p><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t52xcybqj30op0d6766.jpg" alt=""></p><ul><li>Remote Notifications: 向 APNs 发送 <code>Notification Payload</code>.</li></ul><h1 id="处理通知"><a href="#处理通知" class="headerlink" title="处理通知"></a>处理通知</h1><h2 id="UNUserNotificationCenterDelegate"><a href="#UNUserNotificationCenterDelegate" class="headerlink" title="UNUserNotificationCenterDelegate"></a>UNUserNotificationCenterDelegate</h2><p><code>UNUserNotificationCenterDelegate</code>提供了两个方法：</p><ul><li>在应用内展示通知。App 处于前台时捕捉并处理即将触发的推送：</li></ul><pre><code class="Objective-C">@interface AppDelegate () &lt;UNUserNotificationCenterDelegate&gt;-(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler{    completionHandler(UNNotificationPresentationOptionAlert | UNNotificationPresentationOptionSound);}</code></pre><ul><li>收到通知响应时的处理工作。用户与你推送的通知进行交互时被调用：</li></ul><pre><code class="Objective-C">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler{      completionHandler()//什么也不做}</code></pre><h2 id="Notification-Management"><a href="#Notification-Management" class="headerlink" title="Notification Management"></a>Notification Management</h2><p>可以对通知执行查、改、删操作。实现该功能需要有一个必要参数<code>identifer</code>，后续的查改删操作都是根据此参数去执行的。</p><ul><li>Local Notification：通过更新 request.</li><li>Remote Notification 通过新的字段 <code>apns-collapse-id</code>.</li></ul><p>更新原有推送：</p><pre><code class="Objective-C">NSString *requestIdentifier = @&quot;sampleRequest&quot;;UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:requestIdentifier                                                                      content:newContent                                                                      trigger:newTrigger1];[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {}];</code></pre><p>删除推送：</p><pre><code class="Objective-C">[center removePendingNotificationRequestsWithIdentifiers:@[requestIdentifier]];</code></pre><p>典型应用场景：</p><ul><li>赛事比分更新</li><li>撤回通知<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t9swwyxqj30og0dcta2.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f7t9t2wnu3j30og0dcgmw.jpg" alt=""></li></ul><h1 id="Notification-Extension"><a href="#Notification-Extension" class="headerlink" title="Notification Extension"></a>Notification Extension</h1><p><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f7xzisvg36j30l80fc0vp.jpg" alt=""></p><h2 id="Service-Extension"><a href="#Service-Extension" class="headerlink" title="Service Extension"></a>Service Extension</h2><p>Service Extension允许在收到远程推送的通知后，展示之前对通知内容进行修改。</p><pre><code class="Swift">class NotificationService: UNNotificationServiceExtension {    var contentHandler: ((UNNotificationContent) -&gt; Void)?    var bestAttemptContent: UNMutableNotificationContent?    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) {        self.contentHandler = contentHandler        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)        if let bestAttemptContent = bestAttemptContent {            if request.identifier == &quot;mutableContent&quot; {                bestAttemptContent.body = &quot;\(bestAttemptContent.body),tuneszhao&quot;            }            contentHandler(bestAttemptContent)        }    }    override func serviceExtensionTimeWillExpire() {        // Called just before the extension will be terminated by the system.        // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used.        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {            contentHandler(bestAttemptContent)        }    }}</code></pre><ul><li><code>didReceive:</code>方法中通过修改请求的<code>content</code>内容，然后在限制的时间内将修改后的内容调用通过 <code>contentHandler</code> 返还给系统，就可以显示这个修改过的通知了。<br>(本例中在原有 content 之后添加了字符串 “tuneszhao”)。</li><li><code>serviceExtensionTimeWillExpire:</code>：在一定时间内没有调用 <code>contentHandler</code> 的话，系统会调用这个方法。可以选择什么都不做，系统将当作什么都没发生，简单地显示原来的通知。可能你其实已经设置好了绝大部分内容，只是有很少一部分没有完成，这时你也可以像例子中这样调用 contentHandler 来显示一个变更“中途”的通知。</li></ul><p><code>Service Extension</code>只对远程推送的通知有效，启用内容修改要在推送<code>payload</code>中设置<code>mutable-content</code>值为1：</p><pre><code class="Java">{  &quot;aps&quot;:{    &quot;alert&quot;:{      &quot;title&quot;:&quot;Greetings&quot;,      &quot;body&quot;:&quot;Long time no see&quot;    },    &quot;mutable-content&quot;:1  }}</code></pre><p>该特性可用于推送内容加密。服务器推送 <code>payload</code> 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密，然后显示。这样可以保证传递内容的安全。</p><h2 id="Media-Attachments"><a href="#Media-Attachments" class="headerlink" title="Media Attachments"></a>Media Attachments</h2><p>iOS 10 的另一个亮眼功能是多媒体的推送，开发者可以在通知中嵌入图片或视频。</p><h3 id="为本地通知添加图片／视频"><a href="#为本地通知添加图片／视频" class="headerlink" title="为本地通知添加图片／视频"></a>为本地通知添加图片／视频</h3><p>通过本地磁盘上的文件 URL 创建一个 <code>UNNotificationAttachment</code> 对象，然后将这个对象放到数组中赋值给 <code>content</code> 的 <code>attachments</code> 属性：</p><pre><code class="Swift">let content = UNMutableNotificationContent()  content.title = &quot;Hey guys&quot;content.body = &quot;What&#39;s going on here?&quot;if let imageURL = Bundle.main.url(forResource: &quot;image&quot;, withExtension: &quot;jpg&quot;),   let attachment = try? UNNotificationAttachment(identifier: &quot;imageAttachment&quot;, url: imageURL, options: nil){    content.attachments = [attachment]}</code></pre><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f7xlo99zmsj30og0dc402.jpg" alt=""></p><h3 id="为远程推送添加多媒体内容"><a href="#为远程推送添加多媒体内容" class="headerlink" title="为远程推送添加多媒体内容"></a>为远程推送添加多媒体内容</h3><p>需要借助上面提到的<code>Notification Service Extension</code>。</p><ul><li><code>payload</code> 中指定需要加载的图片资源地址，这个地址可以是应用 bundle 内已经存在的资源，也可以是网络的资源。</li><li>如果多媒体不在本地的话，需要先将其下载到本地。</li><li>创建 <code>UNNotificationAttachment</code>,之后和本地通知一样，将多媒体资源设置给 <code>attachments</code> 属性，然后调用<code>contentHandler</code>。</li></ul><pre><code class="Java">{  &quot;aps&quot;:{    &quot;alert&quot;:{      &quot;title&quot;:&quot;Image Notification&quot;,      &quot;body&quot;:&quot;Show me an image from web!&quot;    },    &quot;mutable-content&quot;:1  },  &quot;image&quot;: &quot;http://ww2.sinaimg.cn/large/005tGCqhgw1f7xlo99zmsj30og0dc402.jpg&quot;}</code></pre><p>下载图片代码：</p><pre><code class="Swift">private func downloadAndSave(url: URL, handler: @escaping (_ localURL: URL?) -&gt; Void) {    let task = URLSession.shared.dataTask(with: url, completionHandler: {        data, res, error in        var localURL: URL? = nil        if let data = data {            let ext = (url.absoluteString as NSString).pathExtension            let cacheURL = URL(fileURLWithPath: FileManager.default.cachesDirectory)            let url = cacheURL.appendingPathComponent(url.absoluteString.md5).appendingPathExtension(ext)            if let _ = try? data.write(to: url) {                localURL = url            }        }        handler(localURL)    })    task.resume()}</code></pre><p><code>didReceive:</code>中接收通知获取图片地址后下载，并创建<code>attachment</code>展示：</p><pre><code class="Swift">if let imageURLString = bestAttemptContent.userInfo[&quot;image&quot;] as? String,   let URL = URL(string: imageURLString){    downloadAndSave(url: URL) { localURL in        if let localURL = localURL {            do {                let attachment = try UNNotificationAttachment(identifier: &quot;image_downloaded&quot;, url: localURL, options: nil)                bestAttemptContent.attachments = [attachment]            } catch {                print(error)            }        }        contentHandler(bestAttemptContent)    }}</code></pre><h1 id="关于适配"><a href="#关于适配" class="headerlink" title="关于适配"></a>关于适配</h1><p>关于通知原来的 API 已被标为弃用。但如果需要支持 iOS 10 之前的系统，还是需要使用原来的 API。若要针对 iOS 10 进行新通知的适配，为应用通知带来更多新特性，可以使用：</p><pre><code class="Swift">if #available(iOS 10.0, *) {    // 使用 UserNotification}</code></pre><h1 id="官方链接及实例代码"><a href="#官方链接及实例代码" class="headerlink" title="官方链接及实例代码"></a>官方链接及实例代码</h1><blockquote><p><a href="https://developer.apple.com/videos/play/wwdc2016/707/" target="_blank" rel="noopener">Introduction to Notifications</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/708/" target="_blank" rel="noopener">Advanced Notifications</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/724/" target="_blank" rel="noopener">What’s New in the Apple Push Notification Service</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 通知 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 10 之 Messages framework</title>
      <link href="/2018/10/16/ios10-messages-framework/"/>
      <url>/2018/10/16/ios10-messages-framework/</url>
      <content type="html"><![CDATA[<p>iMessage App 是一种全新的应用扩展，载体是 iOS 系统的 Message 应用，通过 iMessage App，用户可以发送更加丰富的消息内容，享受更具交互性的会话体验。<br>从 iOS 10 开始，消息扩展（Messages Extension）可以独立于宿主App(Container App) 开发，并提供了全新的消息模式。用户可以通过 Message 发送文本、表情包（sticker）、多媒体文件，以及其他可交互消息。<br><a id="more"></a></p><h1 id="Messages-App-Store"><a href="#Messages-App-Store" class="headerlink" title="Messages App Store"></a>Messages App Store</h1><p><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80b81p95wj309y024jrb.jpg" alt=""><br>Messages App Store 独立于之前的 App Store，只存在于系统的 Message 中，这里只显示 <strong>iMessage-related 应用</strong>。它可以干什么呢？</p><ul><li>显示iMessage App;</li><li>为未安装应用的用户提供安装途径(Inline App Attribution);</li><li>提供iap，Apple Pay和访问相机功能。<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80bdctvjej30ku112wkv.jpg" alt=""></li></ul><p>iMessage App 可以独立开发（iOS 10之后），也可以作为 Extension 添加在现有项目中。</p><ul><li>在现有项目中添加：File-&gt;New-&gt;Target-&gt;Application Extension-&gt;Sticker Pack Extension/iMessage Extension</li><li>独立开发：File-&gt;New-&gt;Project-&gt;Application-&gt;Sticker Pack Application/iMessage Application</li></ul><h1 id="基本表情包-Sticker-Packs"><a href="#基本表情包-Sticker-Packs" class="headerlink" title="基本表情包 (Sticker Packs)"></a>基本表情包 (Sticker Packs)</h1><p>Sticker 是 iOS 10 iMessage 引入的一种新的交互方式，可以当做消息发送，也可以附加在已有消息上。创建表情包不需要任何代码。图片文件需满足以下条件：</p><ul><li>图片格式：PNG, APNG, GIF, JPEG;</li><li>文件大小：小于 500 KB;</li><li>图片大小区间：[100 x 100,206 x 206]</li></ul><p>只需提供最大像素图片(@3x,[300 x 300,618 x 618])，系统会在需要的时候自动完成缩放。</p><p>苹果建议的表情文件大小：</p><ul><li>Small: 100 x 100 pt @3x scale (300 x 300 pixel image)</li><li>Medium: 136 x 136 pt @3x scale (378 x 378 pixel image)</li><li>Large: 206 x 206 pt @3x scale (618 x 618 pixel image)</li></ul><p>打开 Xcode，创建新工程 BasicStickerPack：<em>File-&gt;New-&gt;Project-&gt;Application-&gt;Sticker Pack Application</em>。<br>左边侧栏有个<code>Stickers.xcstickers</code>，包含了iMessage APP的icon 和表情，添加一组图片。如果要更改表情包默认名称和大小，可在右侧Attributes inspector 中更改。<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f80c1a8yuuj31kw085mzu.jpg" alt=""><br>运行，表情包将在 Message 的 Message App Store 打开，点击任何一个表情即可添加到当前信息并发送：<br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80cwi8ozbj30ku112422.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005tGCqhgw1f80cdyjxegj30ku112dhr.jpg" alt=""></p><h1 id="自定义表情包"><a href="#自定义表情包" class="headerlink" title="自定义表情包"></a>自定义表情包</h1><p>基本的表情应用程序提供的模板可能不完全满足需求，我们创建一个较复杂的表情包应用程序 CustomStickerPack，选择 iMessage Application 模版。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80d9jz8moj30ek0ik40n.jpg" alt=""><br>创建好的工程相比上面的 Sticker Pack Application 多了 MessagesExtension 文件夹。该文件夹包含四个部分：</p><ul><li>MessagesViewController.swift : iMessage app的程序入口;</li><li>MainInterface.storyboard: 可视化操作;</li><li>Assets.xcassets: 图片集合;</li><li>Info.plist : 配置一些扩展信息;</li></ul><p><code>MessagesViewController</code>是 <code>MSMessagesAppViewController</code> 的子类，它是用来展示消息扩展(Message Extension)的界面。自定义 Sticker 需要自定义<code>MSStickerBrowserViewController</code>。<code>MSStickerBrowserViewController</code>是用来显示 Sticker 的，它有两个协议方法需要实现：</p><pre><code class="Objective-C">@protocol MSStickerBrowserViewDataSource &lt;NSObject&gt;- (NSInteger)numberOfStickersInStickerBrowserView:(MSStickerBrowserView *)stickerBrowserView;//返回Sticker数量- (MSSticker *)stickerBrowserView:(MSStickerBrowserView *)stickerBrowserView stickerAtIndex:(NSInteger)index;//返回MSSticker对象</code></pre><p><code>MSStickerBrowserViewController</code>用法跟<code>UITableViewDataSource</code>很像，有一个<code>stickerBrowserView</code>对象：</p><pre><code class="Objective-C">@property (nonatomic, strong, readonly) MSStickerBrowserView *stickerBrowserView;</code></pre><p>刷新数据，调用：</p><pre><code class="Objective-C">[stickerBrowserView reloadData];</code></pre><p>一张图说明一下上述几个对象的关系：<br><img src="http://upload-images.jianshu.io/upload_images/1415843-cc9571b08a155105.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""><br>将 sticker 放入 MessagesExtension 文件夹，创建一个 <code>MSSticker</code> 数组存储表情包，并写一个加载表情包的方法：</p><pre><code class="swift">var stickers = [MSSticker]()func loadStickers() {    for i in 1...2 {        if let url = Bundle.main.url(forResource: &quot;Sticker \(i)&quot;, withExtension: &quot;png&quot;){            do {                let sticker = try MSSticker(contentsOfFileURL: url, localizedDescription: &quot;&quot;)                stickers.append(sticker)            } catch {                print(error)            }        }    }}</code></pre><p>实现<code>createStickerBrowser</code>方法, 初始化<code>MSStickerBrowserViewController</code>作为根视图, 并设置宽高约束:</p><pre><code class="swift">func createStickerBrowser() {    let controller = MSStickerBrowserViewController(stickerSize: .large)    addChildViewController(controller)    view.addSubview(controller.view)    controller.stickerBrowserView.backgroundColor = UIColor.blue    controller.stickerBrowserView.dataSource = self    view.topAnchor.constraint(equalTo: controller.view.topAnchor).isActive = true    view.bottomAnchor.constraint(equalTo: controller.view.bottomAnchor).isActive = true    view.leftAnchor.constraint(equalTo: controller.view.leftAnchor).isActive = true    view.rightAnchor.constraint(equalTo: controller.view.rightAnchor).isActive = true}</code></pre><p>实现<code>MSStickerBrowserViewDataSource</code>的代理方法：</p><pre><code class="swift">func numberOfStickers(in stickerBrowserView: MSStickerBrowserView) -&gt; Int {    return stickers.count}func stickerBrowserView(_ stickerBrowserView: MSStickerBrowserView, stickerAt index: Int) -&gt; MSSticker {    return stickers[index]}</code></pre><p><code>viewDidLoad</code> 中加载 sticker 、创建 MSStickerBrowserViewController：</p><pre><code class="swift">override func viewDidLoad() {    super.viewDidLoad()    loadStickers()    createStickerBrowser()}</code></pre><p>运行，跟上一个表情包差不多，但背景换成了自定义的颜色。<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80dm1uafej30ku112q69.jpg" alt=""></p><h1 id="自定义-APP"><a href="#自定义-APP" class="headerlink" title="自定义 APP"></a>自定义 APP</h1><p>本例将利用 iMessage App 创建一个独特的可交互消息。<br>创建 iMessage Application <code>MessageApp</code>，在<code>MainInterface.storyboard</code>添加一个 stepper 和 button：<br><img src="http://upload-images.jianshu.io/upload_images/326255-0dce497fdcdbe7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>选择 stepper 打开 Attributes inspector, 改变最小最大值为0和10:<br><img src="http://upload-images.jianshu.io/upload_images/326255-bf8a7f349311fcb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>介绍几个关键对象：</p><h2 id="MSConversation"><a href="#MSConversation" class="headerlink" title="MSConversation"></a>MSConversation</h2><p>指当前打开的会话，可以通过 MSConversation 插入消息。<br>在<code>MSMessagesAppViewController</code>中可以通过成员变量<code>activeConversatio</code>n获取当前的<code>MSConversation</code>，随后可调用以下方法插入不同的消息：</p><pre><code class="swift">// 添加交互型消息.open func insert(_ message: MSMessage, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加 sticker.open func insert(_ sticker: MSSticker, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加文本.open func insertText(_ text: String, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)// 添加多媒体（音视频）.open func insertAttachment(_ URL: URL, withAlternateFilename filename: String?, completionHandler: (@escaping (Error?) -&gt; Swift.Void)? = nil)</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1415843-bb2627708998cfe4.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><h2 id="MSMessage"><a href="#MSMessage" class="headerlink" title="MSMessage"></a>MSMessage</h2><p>代表单个消息体，包含两个部分：</p><ul><li><code>MSSession</code>：用来描述消息如何发送;</li><li><code>MSMessageLayout</code>：用来描述消息如何展示。<br>在 iMessage 中自定义 MSMessage 必须要设置两个属性：<code>layout</code> 和 <code>url</code>。 url 是链接某个 web 页面的一些内容, 这样 MacOS 用户可以看到 iMessage 的内容。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1415843-8f7716fc63e26aea.PNG?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><p><code>MSMessageLayout</code>是一个抽象类，目前系统只提供了一种展现方法<code>MSMessageTemplateLayout</code>，里边有许多属性和空间用来自定义message;：<br><img src="https://docs-assets.developer.apple.com/published/af521ba258/MSMessageTemplateLayout_2x_93d9e9b7-b99c-4def-a8e1-2df50a710a52.png" alt=""><br> 左上角的空间是展示icon， 所有的属性都是可选的，提供任何标题字符串将摆脱底部部分的布局。<br>添加<code>createImageForMessage()</code>方法，将当前的stepper的数值显示到圆形的label中, 然后将label放在UIImage对象中。</p><pre><code class="swift">func createImageForMessage() -&gt; UIImage? {    let background = UIView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))    background.backgroundColor = UIColor.white    let label = UILabel(frame: CGRect(x: 75, y: 75, width: 150, height: 150))    label.font = UIFont.systemFont(ofSize: 56.0)    label.backgroundColor = UIColor.red    label.textColor = UIColor.white    label.text = &quot;\(Int(stepper.value))&quot;    label.textAlignment = .center    label.layer.cornerRadius = label.frame.size.width/2.0    label.clipsToBounds = true    background.addSubview(label)    background.frame.origin = CGPoint(x: view.frame.size.width, y: view.frame.size.height)    view.addSubview(background)    UIGraphicsBeginImageContextWithOptions(background.frame.size, false, UIScreen.main.scale)    background.drawHierarchy(in: background.bounds, afterScreenUpdates: true)    let image = UIGraphicsGetImageFromCurrentImageContext()    UIGraphicsEndImageContext()    background.removeFromSuperview()    return image}</code></pre><p>设置 button 点击方法<code>didPress</code>，该方法中先创建message的布局, 并且设置 image 和 caption, 接着创建 MSMessage 对象并插入到会话中：</p><pre><code class="swift">@IBAction func didPress(button sender: AnyObject) {    if let image = createImageForMessage(), let conversation = activeConversation {        let layout = MSMessageTemplateLayout()        layout.image = image        layout.caption = &quot;Stepper Value&quot;        let message = MSMessage()        message.layout = layout        message.url = URL(string: &quot;emptyURL&quot;)        conversation.insert(message, completionHandler: { (error) in            print(error)        })    }}</code></pre><p>在这个例子中, 我们只是创建了简单的字符 url，如果用户点击该消息并且 url 是 http(s) 类型的，系统会通过浏览器打开相应的页面。<br>运行 App：<br><img src="http://ww1.sinaimg.cn/large/005tGCqhgw1f80fc9xq3ej30ku112td8.jpg" alt=""><br>点击 button 发送消息：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80fcp6fl0j30ku112q57.jpg" alt=""><br>stepper+2：<br><img src="http://ww2.sinaimg.cn/large/005tGCqhgw1f80fd9slruj30ku112mzf.jpg" alt=""></p><h1 id="iMessage-App-LifeCycle"><a href="#iMessage-App-LifeCycle" class="headerlink" title="iMessage App LifeCycle"></a>iMessage App LifeCycle</h1><p>看下 iMessage App 的生命周期。</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><pre><code class="objc">// Message Extension启动。- (void)didBecomeActiveWithConversation:(MSConversation *)conversation;- (void)viewWillAppear:(BOOL)animated;- (void)viewDidAppear:(BOOL)animated;</code></pre><h2 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h2><pre><code class="objc">- (void)viewWillDisappear:(BOOL)animated;- (void)viewDidDisappear:(BOOL)animated;- (void)willResignActiveWithConversation:(MSConversation *)conversation;// Message Extension被系统销毁。</code></pre><h2 id="唤起过程"><a href="#唤起过程" class="headerlink" title="唤起过程"></a>唤起过程</h2><pre><code class="objc">-(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;-(void)didTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;</code></pre><p>上面列出的回调方法均出现在<code>MSMessagesAppViewController</code>中，因此，iMessage App 的生命周期就是<code>MSMessagesAppViewController</code>的生命周期。</p><blockquote><p><a href="https://developer.apple.com/reference/messages" target="_blank" rel="noopener">官方文档 Messages Framework Reference</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/204/" target="_blank" rel="noopener">WWDC Session1</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/224/" target="_blank" rel="noopener">WWDC Session2</a><br><a href="https://developer.apple.com/library/prerelease/content/samplecode/IceCreamBuilder/Introduction/Intro.html" target="_blank" rel="noopener">官方 demo</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Messages </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cloak&amp;Dagger —— 一种新型Android点击劫持漏洞</title>
      <link href="/2017/09/18/cloak&amp;dagger/"/>
      <url>/2017/09/18/cloak&amp;dagger/</url>
      <content type="html"><![CDATA[<p><a href="http://cloak-and-dagger.org/" target="_blank" rel="noopener">Cloak&amp;Dagger</a> 是一种可出现于目前所有版本 Android 系统（&lt;8.0）的新型攻击技术，手机上安装恶意 APP 后，黑客能悄悄获取到目标 Android 设备的完整控制权，进而窃取到用户包括键盘记录、聊天数据、设备PIN码、在线账号密码、OTP密码和通讯录在内的多种隐私数据。针对该漏洞 Google 将在 Android O 版本通过加强权限检查机制来减少感染机会，但暂时还没有彻底封堵该漏洞的方案。</p><h1 id="攻击产生原理及场景"><a href="#攻击产生原理及场景" class="headerlink" title="攻击产生原理及场景"></a>攻击产生原理及场景</h1><p>Cloak&amp;Dagger 不需要利用 Android 生态系统中的任何安全漏洞，利用的是 Android 设备中两大合法基础权限：</p><ol><li>SYSTEM_ALERT_WINDOW (“draw on top”)：允许App在设备屏幕上显示额外的叠加窗口来覆盖其他的App界面。</li><li>BIND_ACCESSIBILITY_SERVICE (“a11y”)：帮助包括盲人和视力障碍用户在内的残疾人用户更好地通过语音命令来输入信息或通过屏幕阅读功能来了解屏幕内容。</li></ol><p>从2015年10月份发布的 Android Marshmallow（Version6）开始，Google 默认 会给那些直接从 GooglePlay 应用商店下载并安装的App提供”SYSTEM_ALERT_WINDOW”(“draw on top”)权限。有了这两个权限，恶意 APP 通过使用 TYPE_TOAST 类型窗口即可实现一系列监控与劫持的操作。</p><h2 id="示例1：获取用户键盘输入内容"><a href="#示例1：获取用户键盘输入内容" class="headerlink" title="示例1：获取用户键盘输入内容"></a>示例1：获取用户键盘输入内容</h2><p><img src="/pic/CloakDagger1.png" alt=""><br>如图，由于 TYPE_TOAST 类型窗口允许某APP在另一APP界面上方覆盖悬浮窗，且不需要请求 SYSTEM_ALERT_WINDOW 权限，恶意 APP 便可在用户无法察觉的情况下获取用户键盘输入的内容（实际攻击过程中该网格设置为不可见）。</p><h2 id="示例2：劫持用户点击，实现静默安装恶意-APP"><a href="#示例2：劫持用户点击，实现静默安装恶意-APP" class="headerlink" title="示例2：劫持用户点击，实现静默安装恶意 APP"></a>示例2：劫持用户点击，实现静默安装恶意 APP</h2><p>该示例展示了一个看似为教学APP，实为诱导用户点击某一特定区域，以开启系统 Accessibility 权限，利用 Accessibility 的检测视图以及模拟点击功能，进行恶意安装。<br><img src="/pic/CloakDagger2.png" alt=""><br><img src="/pic/CloakDagger3.png" alt=""><br>左边为用户看到的教学demo，右边为诱导用户开启 Accessibility 权限。最后用户观看视频的过程中背后完成了恶意 APP 的静默安装。<br>以下代码展示了上述两个攻击场景使用的两种 Toast 窗口，view1用于覆盖底部 GUI 并监听用户点击情况，view2用于诱导用户点击某一区域。<br><img src="/pic/CloakDagger4.png" alt=""></p><h1 id="漏洞解决方案"><a href="#漏洞解决方案" class="headerlink" title="漏洞解决方案"></a>漏洞解决方案</h1><p>查看 framework 相关源码可发现，通常在其他 APP 页面最上层展示悬浮窗口是需要进行权限检查（Permission Check）和操作检查（Operation Check）的，但如果是 TYPE_TOAST 窗口则不需要，权限自动开启。<br><img src="/pic/CloakDagger5.jpeg" alt=""><br>因此该漏洞是由于 Android 操作系统底层涉及缺陷导致的（涉及到两个标准功能，但这两个功能的行为符合系统预期），Google暂时未提供解决方案，但Google计划在 “Android O” 版本修改原有策略，增加合适的权限检查。<br>在 Android 7.1.2 上，防止 Cloak&amp;Dagger 攻击最简单的方法就是手动关闭 “draw on top” 权限。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
