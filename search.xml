<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>TableView 动态 cell 高度自适应方案</title>
      <link href="/2018/06/13/dynamic-height-cell/"/>
      <url>/2018/06/13/dynamic-height-cell/</url>
      <content type="html"><![CDATA[<p>相比安卓 ListView/RecylerView，iOS 中 TableViewCell 高度自适应是需要开发者自己想办法解决的，原因在于 tableview 的渲染机制默认是先获取 cell 高度，然后再去绘制 cell 体。由于 label/textview 等通常是高度不定的，cell 高度动态化是个很常见的需求。<br><a id="more"></a></p><h1 id="方案一：高度固定"><a href="#方案一：高度固定" class="headerlink" title="方案一：高度固定"></a>方案一：高度固定</h1><p>针对所有 Cell 具有固定高度的情况：</p><ol><li><code>self.tableView.rowHeight = 88;</code></li><li>实现协议方法 <code>heightForRowAtIndexPath:</code>。</li></ol><p><strong>缺点：</strong>不支持动态高度。</p><h1 id="方案二：cell-预估高度（iOS-7-）"><a href="#方案二：cell-预估高度（iOS-7-）" class="headerlink" title="方案二：cell 预估高度（iOS 7+）"></a>方案二：cell 预估高度（iOS 7+）</h1><p><strong>设计思路：</strong><br>加载 tableview 时一次性计算所有 cell 高度太耗性能。所以把计算 height 的任务从 load time 转移到 scrolling time。只有滑动到的 cell 会计算，屏幕外边的不会计算。<br>方法：<code>tableView: estimatedHeightForRowAtIndexPath:</code><br>这是 iOS 7.0 出现的 UITableViewDelegate 中的方法,表示返回某行 cell 的预估高度。这个方法改变了 TableView 代理方法的调用顺序。<br>未调用<code>estimatedHeightForRow...</code>方法时：<br><img src="http://seuzl.qiniudn.com/md/1528946585725.png" alt=""><br>调用<code>estimatedHeightForRow...</code>后：<br><img src="http://seuzl.qiniudn.com/md/1528946602952.png" alt=""><br>此时 tableView 工作原理：</p><ol><li>tableView 先向代理拿得到每个 cell 的预估高度(<code>estimatedHeightForRow...</code>方法)，并且拿这个高度去计算整个 tableView 应该显示的范围。</li><li>根据每行预估的高度，算出一屏显示的 cell 的个数，并先对这些 cell(调用<code>cellForRow...</code>方法)进行绘制。</li><li>绘制时拿到 cell 的真实高度,然后放在<code>heightForRow...</code>方法里面拿给 tabelView 去用。</li><li>屏幕滚动(有 cell 进入屏幕)的时候,仍然会调用绘制以及获取真实高度的方法。</li></ol><p>简单点说，预估高度用来让 tableView 心里有个底，把 cell 先绘制出来，但最后实际的 cell 高度还是会从<code>heightForRow...</code>方法中获取。</p><p><strong>缺点：</strong></p><ol><li>设置估算高度后，<code>tableview.contentSize.height</code>根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</li><li>估算高度使加载速度更快，但侵害滑动流畅性，cell较多情况下滑动时实时计算高度带来的卡顿是明显能体验到的。</li></ol><h1 id="方案三：self-sizing-cell-（iOS-8-）"><a href="#方案三：self-sizing-cell-（iOS-8-）" class="headerlink" title="方案三：self-sizing cell （iOS 8+）"></a>方案三：self-sizing cell （iOS 8+）</h1><p><strong>设计思路：</strong><br>如图，row123 是已经在屏幕上被展示的cell, 而 row4 是下一个会被展示的cell, 这时 row4 这个 cell 的 rowHeight 是预先为其设置的 estimated height， 又或者是  UITableViewDelegate 中返回的 height。<br>当用户滚动的时候，首先 cell 会被创建或重用，然后 cell 会被调用调整 size 的方法， 接着 cell 会根据 tableView 的size去调整自身的 contentSize，最后cell被展示出来。<br><img src="http://ww2.sinaimg.cn/mw690/005tGCqhjw1f9fwywhi35j308p07zq31.jpg" alt=""><br>如何让一个cell去调整自己的高度？</p><ol><li>cell 要使用 Autolayout 布局；</li><li>在 tableView 中启动动态布局, 告诉 tableView 用新的方法来布局行高.而不是 rowHeight 或者 delegate 方法。<br><code>tableView.rowHeight = UITableViewAutomaticDimension;</code></li></ol><p><strong>缺点：</strong></p><ol><li>仅支持iOS 8+；</li><li>高度没有缓存。iOS 7 计算高度后有”缓存“机制，不会重复计算；iOS 8 不论何时都会重新计算 cell 高度。</li></ol><h1 id="方案四：FDTemplateLayoutCell（iOS-6-）"><a href="#方案四：FDTemplateLayoutCell（iOS-6-）" class="headerlink" title="方案四：FDTemplateLayoutCell（iOS 6+）"></a>方案四：FDTemplateLayoutCell（iOS 6+）</h1><p>好处：既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。</p><ol><li>根据 autolayout 约束自动计算高度。使用了系统在 iOS6 提供的 API：<code>-systemLayoutSizeFittingSize:</code></li><li>根据 indexPath 的一套高度缓存机制。<br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了多余计算。</li><li>自动的缓存失效机制。<br>UITableView 刷新时，已有的高度缓存将以最小的代价失效。如删除一个 indexPath 为 [0:5] 的 cell，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li><li>预缓存机制（通过 runloop 实现）。<br>UITableView 没有滑动的空闲时刻会计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性。</li></ol><p><strong>缺点：</strong><br>要求约束设置完整准确，保证 contentView 内部上下左右所有方向都有约束支撑，设置不合理的话计算的高度就成了0。（这个实际上是<code>systemLayoutSizeFittingSize:</code>的要求）。</p><p>从易用性、性能、高度自适应效果、适配 iOS 最低版本综合来看，方案四是最佳的。但需要引入第三方库，同时要保证 autolayout 约束完整准确才行，关于这点<a href="https://www.jianshu.com/p/386b792054b1" target="_blank" rel="noopener">《UITableViewCell高度自适应的关键点》</a>总结得很好：</p><blockquote><p>Cell 内部的 Constraints 一定要有一条从 Cell 顶部到底部的一条可联通线。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为 ViewControllers 瘦身</title>
      <link href="/2018/05/30/light-viewcontrollers/"/>
      <url>/2018/05/30/light-viewcontrollers/</url>
      <content type="html"><![CDATA[<p>目标：写可维护的代码。<br><a id="more"></a></p><h2 id="把-TableView-从-VC-中抽离"><a href="#把-TableView-从-VC-中抽离" class="headerlink" title="把 TableView 从 VC 中抽离"></a>把 TableView 从 VC 中抽离</h2><p>UITableView 可以说是 iOS 界面开发中用的最广泛的组件，就我自己做过的项目而言，绝大部份 ViewController 都是在围绕 UITableViewDelegate 和 UITableViewDataSource 中的方法打交道。但说到底这些函数都是 View 层面的，全部在 VC 中处理显得不太合适，也不利于日后的维护和扩展，所以关于瘦身 VC 很容易想到一点是从 VC 中抽离 tableView 的表示逻辑。这种思想其实与最近火热的<a href="http://www.cnblogs.com/ludashi/p/4211556.html" target="_blank" rel="noopener">MVVM</a>设计模式相通。核心是<strong>把逻辑代码尽量移到 model 层</strong>, 你可以认为它是一个中间层 , 逻辑代码可以是各种 delegate,网络请求,缓存,数据库,coredata 等, 而 controller 正是用来组织串联他们，使得整个程序走通。</p><h3 id="把-Data-Source-分离出来"><a href="#把-Data-Source-分离出来" class="headerlink" title="把 Data Source 分离出来"></a>把 Data Source 分离出来</h3><p>举例:当需要将一个数组映射到一个 tableView 进行显示，这种一一对应关系可以单独写一个类<code>ArrayDataSource</code>，使用 block 或者 delegate 设置 cell。ArrayDataSource 类完全可以复用到任何需要将一个数组的内容映射到一个 tableView 的场景。<br>ArrayDataSource 中声明 <code>block(cell,item)</code> 来初始化 cell，block实现方式（item 和 cell 如何对应）则可以在 cell+Configure 的 category 中声明。<br>使用<code>ArrayDataSource</code>，在<code>ViewController</code>中执行<code>setUpTableView</code>即可。<code>setUpTableView</code>中实现 block（可以是执行 configure 方法的方式）。使用 cell 类 category 的方式是为了避免向 dataSource 暴露 cell 的设计,说白了是为了更好得分离 view 和 model 层。</p><blockquote><p><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank" rel="noopener">1.1 参考项目看这里</a></p></blockquote><h3 id="把-Data-Source-和-Delegate-都分离出来"><a href="#把-Data-Source-和-Delegate-都分离出来" class="headerlink" title="把 Data Source 和 Delegate 都分离出来"></a>把 Data Source 和 Delegate 都分离出来</h3><p>1.1中的方法是在<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a>一文中提到的。但该文讲的只是把<code>UITableViewDataSource</code>中的方法提取到一个单独的类，从结果来看，是把<code>numberOfRowsInSection</code>和<code>cellForRowAtIndexPath</code>从 VC 中提取出去。但实际上<code>UITableViewDelegate</code>也是可以抽象出去的。例如 cell 的生成, cell 行高, 点击事件等等。这里用 block 实现回调。<br>处理类<code>TableViewDataSourceDelegate.h</code></p><pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void    (^TableViewCellConfigureBlock)(NSIndexPath *indexPath, id item, XTRootCustomCell *cell) ;typedef CGFloat (^CellHeightBlock)(NSIndexPath *indexPath, id item) ;typedef void    (^DidSelectCellBlock)(NSIndexPath *indexPath, id item) ;@interface TableViewDataSourceDelegate : NSObject &lt;UITableViewDelegate,UITableViewDataSource&gt;//初始化方法: 传数据源, cellIdentifier, 三个block分别对应配置, 行高, 点击。- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock ;//将UITableViewDataSource和UITableViewDelegate设于TableViewDataSourceDelegate。- (void)handleTableViewDatasourceAndDelegate:(UITableView *)table ;//默认indexPath.row对应每个dataSource相应返回item。- (id)itemAtIndexPath:(NSIndexPath *)indexPath ;@end</code></pre><p>在 1.1 中为了避免 model 和 view 的耦合，将 cell 的配置用 category 方法处理。但使用的方式是每一个<code>UITableViewCell</code>都做了扩展，实际上可以做得更彻底 ——直接对这些子类的父类<code>UITableViewCell</code>进行扩展。这样做的好处是比 1.1 的扩展方法更加灵活，可以提供多个 configure 方法，针对不同类型的 model 进行数据展示，同时也增强 cell 的移植性。<br>为 UITableViewCell 提供扩展<code>UITableViewCell+Extension.h</code></p><pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;@interface UITableViewCell (Extension)//实际是tableView reigister nib，由于是与cell(view)紧密相关的方法，故在cell本身进行实现，而非在vc中。+(void) registerTable:(UITableView*)table        nibIdentifier:(NSString*)identifier;//根据数据源配置并绘制cell 子类需重写该方法-(void)configure:(UITableViewCell*)cell       customObj:(id)obj       indexPath:(NSIndexPath*)indexPath;//根据数据源计算cell的高度 子类可重写该方法, 若不写为默认值44.0+(CGFloat)getCellHeightWithCustomObj:(id)obj                        indexPath:(NSIndexPath*)indexPath;@end</code></pre><p>如此，对于每一个 cell 子类，实现两个新方法:</p><pre><code class="objc">- (void)configure:(UITableViewCell *)cell        customObj:(id)obj        indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}+ (CGFloat)getCellHeightWithCustomObj:(id)obj                            indexPath:(NSIndexPath *)indexPath{    //Rewrite according to your requirements.}</code></pre><p>OK,做了这么多工作，返回 VC 看一下最后的成果吧！瘦身后的 viewController 对于 tableView 的所有处理都只需要一个方法<code>setUpTableView</code></p><pre><code class="objc">- (void)setupTableView{    TableViewCellConfigureBlock configureCell = ^(NSIndexPath *indexPath, MyObj *obj, XTRootCustomCell *cell) {        [cell configure:cell customObj:obj indexPath:indexPath] ;    } ;    CellHeightBlock heightBlock = ^CGFloat(NSIndexPath *indexPath, id item) {        return [MyCell getCellHeightWithCustomObj:item indexPath:indexPath] ;    } ;    DidSelectCellBlock selectedBlock = ^(NSIndexPath *indexPath, id item) {        NSLog(@&quot;click row : %@&quot;,@(indexPath.row)) ;    } ;    self.tableHandler = [[TableDataDelegate alloc] initWithItems:self.list                                                   cellIdentifier:MyCellIdentifier                                               configureCellBlock:configureCell                                                  cellHeightBlock:heightBlock                                                   didSelectBlock:selectedBlock] ;    [self.tableHander handleTableViewDatasourceAndDelegate:self.table] ;}</code></pre><blockquote><p>1.2 <a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">参考项目看这里</a></p></blockquote><h3 id="抽离-TableView-终极版"><a href="#抽离-TableView-终极版" class="headerlink" title="抽离 TableView 终极版"></a>抽离 TableView 终极版</h3><p>经过 1.2 的处理，<code>UITableViewDelegate</code> 和 <code>UITableViewDataSource</code> 的方法都已经移到<code>TableViewDataSourceDelegate</code>这个类中处理，但根据<br><a href="https://github.com/Akateason/XTTableDatasourceDelegateSeparation" target="_blank" rel="noopener">1.2参考项目</a>可以发现1.2的处理方式有局限性，我们观察<code>TableViewDataSourceDelegate</code>中的核心方法:</p><pre><code class="objc">- (id)initWithItems:(NSArray *)anItems     cellIdentifier:(NSString *)aCellIdentifier configureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock    cellHeightBlock:(CellHeightBlock)aHeightBlock     didSelectBlock:(DidSelectCellBlock)didselectBlock;</code></pre><p><code>TableViewDataSourceDelegate</code>进行初始化时需传递参数<code>CellIdentifier</code>和<code>aHeightBlock</code>,实际开发工作中这两者通常是和<code>UITableViewCell</code>类紧密相关的。一类 <code>UITableViewCell</code>往往对应一个它自己的 <code>CellIdentifier</code> 和 <code>cellHeight</code>，如果初始化<code>TableViewDataSourceDelegate</code>对象时就指定这两个属性，则<code>TableViewDataSourceDelegate</code>仅局限于被一种 tableView 复用:cell种类都相同，也就是用一个tableView展示一个数组( indexPath.row 对应数组下标)。如图：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezscp180r2j30af0hz755.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/005tGCqhjw1ezscrw6qbyj30ah0icgnm.jpg" alt=""><br>这些 cell 都是同一种类，但实际开发中往往面临着更复杂的 cell 样式，如我在开发<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">校友圈</a>时：<br><img src="http://ww4.sinaimg.cn/large/005tGCqhjw1ezsd219avzj30ag0ikaau.jpg" alt=""><br>这种情况怎么使用<code>TableViewDataSourceDelegate</code>呢？修改<code>TableViewDataSourceDelegate</code>的 init 方法：</p><pre><code class="objc">(id)initWithItems:(NSDictionary *)anItemsconfigureCellBlock:(TableViewCellConfigureCellBlock)aConfigureCellBlock   cellHeightBlock:(CellHeightBlock)aHeightBlock    didSelectBlock:(DidSelectCellBlock)aDidSelectBlock;</code></pre><h2 id="业务逻辑移到-model-中"><a href="#业务逻辑移到-model-中" class="headerlink" title="业务逻辑移到 model 中"></a>业务逻辑移到 model 中</h2><p>尽管 viewController 最主要功能是处理业务逻辑，但对于一些和 model 联系紧密，和 view 关系不大（即不是 model 和 view 进行交互的逻辑）的代码应移到 model 中，通常是用 category 的处理方法，更加清晰。</p><h2 id="网络请求逻辑移到-model"><a href="#网络请求逻辑移到-model" class="headerlink" title="网络请求逻辑移到 model"></a>网络请求逻辑移到 model</h2><p>用 category 方式处理。viewController 使用 block 回调请求网络。</p><h2 id="view-代码移到-view-层"><a href="#view-代码移到-view-层" class="headerlink" title="view 代码移到 view 层"></a>view 代码移到 view 层</h2><p>不要在 viewController 中构建复杂的 view 层次结构。<br>要注意的是，IB 并非只能和 viewControllers 一起使用，可以加载单独的 nib 文件到自定义的 view 中。</p><blockquote><p>参考：<a href="http://objccn.io/issue-1-1/" target="_blank" rel="noopener">更轻量的ViewControllers</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
