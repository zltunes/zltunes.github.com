<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ReactiveCocoa 入门与登录实战 | zltunes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><link rel="stylesheet" type="text/css" href="/css/code-number.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="/js/code-number.js?v=0.0.0"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactiveCocoa 入门与登录实战</h1><a id="logo" href="/.">zltunes</a><p class="description">赵磊的博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/work/"><i class="fa fa-building"> 作品</i></a><a href="/resume/"><i class="fa fa-file"> 简历</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReactiveCocoa 入门与登录实战</h1><div class="post-meta">Jun 14, 2018<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RAC-解决的主要问题"><span class="toc-number">1.</span> <span class="toc-text">RAC 解决的主要问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常用几招"><span class="toc-number">2.</span> <span class="toc-text">常用几招</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#target-action类："><span class="toc-number">2.1.</span> <span class="toc-text">target-action类：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TextField"><span class="toc-number">2.1.1.</span> <span class="toc-text">TextField</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手势"><span class="toc-number">2.1.2.</span> <span class="toc-text">手势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通知"><span class="toc-number">2.1.3.</span> <span class="toc-text">通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时器-NSTimer"><span class="toc-number">2.1.4.</span> <span class="toc-text">定时器 NSTimer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理"><span class="toc-number">2.2.</span> <span class="toc-text">代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO"><span class="toc-number">2.3.</span> <span class="toc-text">KVO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进阶"><span class="toc-number">3.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RAC-常见类"><span class="toc-number">3.1.</span> <span class="toc-text">RAC 常见类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RACSignal-核心"><span class="toc-number">3.1.1.</span> <span class="toc-text">RACSignal (核心)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RACCommand"><span class="toc-number">3.1.2.</span> <span class="toc-text">RACCommand</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAC-常见宏"><span class="toc-number">3.2.</span> <span class="toc-text">RAC 常见宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAC-TARGET-KEYPATH-NIL-VALUE-…"><span class="toc-number">3.2.1.</span> <span class="toc-text">RAC(TARGET, [KEYPATH, [NIL_VALUE]]=…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RACObserve-TARGET-KEYPATH"><span class="toc-number">3.2.2.</span> <span class="toc-text">RACObserve(TARGET, [KEYPATH])</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号的处理"><span class="toc-number">3.3.</span> <span class="toc-text">信号的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#映射-flattenMap-Map"><span class="toc-number">3.3.1.</span> <span class="toc-text">映射 flattenMap,Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#combineLatest"><span class="toc-number">3.3.2.</span> <span class="toc-text">combineLatest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-number">3.3.3.</span> <span class="toc-text">reduce</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实战：用-RAC-实现登录模块"><span class="toc-number">4.</span> <span class="toc-text">实战：用 RAC 实现登录模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#model-层"><span class="toc-number">4.1.</span> <span class="toc-text">model 层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#view-model-层"><span class="toc-number">4.2.</span> <span class="toc-text">view-model 层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#判断是否允许登录"><span class="toc-number">4.2.1.</span> <span class="toc-text">判断是否允许登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行登录动作"><span class="toc-number">4.2.2.</span> <span class="toc-text">执行登录动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#controller-层"><span class="toc-number">4.3.</span> <span class="toc-text">controller 层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#视图模型绑定"><span class="toc-number">4.3.1.</span> <span class="toc-text">视图模型绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监听登录动作"><span class="toc-number">4.3.2.</span> <span class="toc-text">监听登录动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#监听登录结果"><span class="toc-number">4.3.3.</span> <span class="toc-text">监听登录结果</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>ReactiveCocoa 是 github 开源的一个<strong>函数式、响应式</strong>编程框架，是在 iOS 平台上对 FRP 的实现。<br><a id="more"></a></p>
<h1 id="RAC-解决的主要问题"><a href="#RAC-解决的主要问题" class="headerlink" title="RAC 解决的主要问题"></a>RAC 解决的主要问题</h1><p>iOS 开发中消息传递和回调机制一直很复杂，RAC 使用 Signal 来代替 KVO、Notification、Delegate 和 Target-Action 等传递消息，解决对象之间状态与状态依赖过多的问题，RAC 通常和 MVVM 结合在一起，在很多地方被用作 iOS 项目中 MVVM 架构的实践方式。</p>
<h1 id="常用几招"><a href="#常用几招" class="headerlink" title="常用几招"></a>常用几招</h1><h2 id="target-action类："><a href="#target-action类：" class="headerlink" title="target-action类："></a>target-action类：</h2><h3 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h3><p>需求：实时监听 textField 输入的字符串并打印。<br>传统 target-action 方式:</p>
<pre><code class="objc">//注册 selector
[textField addTarget:self action:@selector(textChanged:) forControlEvents:UIControlEventEditingChanged];
//实现 selector
- (void)textChanged:(UITextField *)textField
{
      LxDBAnyVar(textField);
}
</code></pre>
<p>这里用到一个很方便的用于打印对象的工具<a href="https://github.com/DeveloperLx/LxDBAnything" target="_blank" rel="noopener">LxDBAnyVar</a><br>用 RAC 的方式:</p>
<pre><code class="objc">[[textField rac_signalForControlEvents:UIControlEventEditingChanged]
   subscribeNext:^(id x) {
    LxDBAnyVar(x);
}];
</code></pre>
<p>事实上对于所有 UIControl 子类的对象的事件监听都可以用这种方式。比如 UIButton 的<code>TouchUpInside</code>事件。<br>更简洁版本:</p>
<pre><code class="objc">[textField.rac_textSignal subscribeNext:^(NSString *x) {     
    LxDBAnyVar(x);
}];
</code></pre>
<h3 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h3><p>需求：为 UIView 添加点击事件。</p>
<pre><code class="objc">self.view.userInteractionEnabled = YES;

UITapGestureRecognizer * tap = [[UITapGestureRecognizer alloc]init];  
    [[tap rac_gestureSignal] subscribeNext:^(UITapGestureRecognizer * tap) {
        LxDBAnyVar(tap);
    }];

[self.view addGestureRecognizer:tap];
</code></pre>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>需求：监听 app 进入后台的通知。</p>
<pre><code class="objc">[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(NSNotification * notification) {
        LxDBAnyVar(notification);
}];
</code></pre>
<p>注意：使用 RAC 监听通知不需要<code>removeObserver</code>。因为监听者是 RAC 内部持有的，RAC 会管理通知什么时候释放。</p>
<h3 id="定时器-NSTimer"><a href="#定时器-NSTimer" class="headerlink" title="定时器 NSTimer"></a>定时器 NSTimer</h3><p>需求1. 延迟某个时间后再做某件事。<br>更改<code>afterDelay</code>属性:</p>
<pre><code class="objc">[[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{
        LxPrintAnything(rac);
}];
</code></pre>
<p>需求2. 每间隔多长时间做一件事。<br>更改<code>interval</code>属性:</p>
<pre><code class="objc">[[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]subscribeNext:^(NSDate * date) {
        LxDBAnyVar(date);
}];
</code></pre>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>需求：监听点击了 AlertView 的哪一个按钮。</p>
<pre><code class="objc">UIAlertView * alertView = [[UIAlertView alloc]initWithTitle:@&quot;RAC&quot; message:@&quot;ReactiveCocoa&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;Ensure&quot;, nil];  
[[self rac_signalForSelector:@selector(alertView:clickedButtonAtIndex:) fromProtocol:@protocol(UIAlertViewDelegate)] subscribeNext:^(RACTuple * tuple) {
        LxDBAnyVar(tuple);
        LxDBAnyVar(tuple.first);
        LxDBAnyVar(tuple.second);
        LxDBAnyVar(tuple.third);
}];
[alertView show];
</code></pre>
<p><code>tuple</code>是 RAC 自己定义的集合类，特点是一个对象含有多个对象。此处对应 alertView 中的按钮。<br>更简单方式：</p>
<pre><code class="objc">[[alertView rac_buttonClickedSignal]subscribeNext:^(id x) {
        LxDBAnyVar(x);
}];
</code></pre>
<p>RAC 取代代理有局限：<strong>只能是没有返回值（void）的代理方法。</strong></p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>需求：监听 scrollView 滑动时 contentOffset 的变化。</p>
<pre><code class="objc">[RACObserve(scrollView, contentOffset) subscribeNext:^(id x) {
        LxDBAnyVar(x);
}];
</code></pre>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="RAC-常见类"><a href="#RAC-常见类" class="headerlink" title="RAC 常见类"></a>RAC 常见类</h2><h3 id="RACSignal-核心"><a href="#RACSignal-核心" class="headerlink" title="RACSignal (核心)"></a>RACSignal (核心)</h3><p>过程：创建信号 -&gt; 激活信号 -&gt; 废弃信号。<br>RAC的核心就是<code>RACSignal</code>，我们可以直接创建信号<code>createSignal</code>，并发送<code>sendNext</code>，当信号完成后用<code>dispose</code>销毁。</p>
<pre><code class="objc">// 1.创建信号
RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        // block调用时刻：每当有订阅者订阅信号，就会调用block。

        // 2.发送信号:注意signal本身不具备发送信号的能力，而是交给内部一个订阅者去发出。
        [subscriber sendNext:@1];

        // 如果不再发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。
        [subscriber sendCompleted];

        return [RACDisposable disposableWithBlock:^{

            // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。
            // 执行完Block后，当前信号就不在被订阅了。
            NSLog(@&quot;信号被销毁&quot;);

        }];
    }];

    // 3.订阅信号,才会激活信号.
    [siganl subscribeNext:^(id x) {
        // block调用时刻：每当有信号发出数据，就会调用block.
        NSLog(@&quot;接收到数据:%@&quot;,x);
    }error:^(NSError *error) {

     NSLog(error);
   }completed:^{

     NSLog(@&quot;completed&quot;);
 }];
</code></pre>
<h3 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h3><p>处理事件的类。如监听按钮点击，网络请求，可以把事件如何处理，事件中的数据如何传递等包装到这个类中。</p>
<pre><code class="objc">// 1.创建命令
RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {


    NSLog(@&quot;执行命令&quot;);

    // 创建空信号,必须返回信号
    //        return [RACSignal empty];

    // 2.创建信号,用来传递数据
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        [subscriber sendNext:@&quot;请求数据&quot;];

        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。
        [subscriber sendCompleted];

        return nil;
    }];

}];

// 强引用命令，不要被销毁，否则接收不到数据
_conmmand = command;

// 3.订阅RACCommand中的信号
[command.executionSignals subscribeNext:^(id x) {

    [x subscribeNext:^(id x) {

        NSLog(@&quot;%@&quot;,x);
    }];

}];

// RAC高级用法
// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号
[command.executionSignals.switchToLatest subscribeNext:^(id x) {

    NSLog(@&quot;%@&quot;,x);
}];

// 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。
[[command.executing skip:1] subscribeNext:^(id x) {

    if ([x boolValue] == YES) {
        // 正在执行
        NSLog(@&quot;正在执行&quot;);

    }else{
        // 执行完成
        NSLog(@&quot;执行完成&quot;);
    }

}];
// 5.执行命令
[self.conmmand execute:@1];
</code></pre>
<h2 id="RAC-常见宏"><a href="#RAC-常见宏" class="headerlink" title="RAC 常见宏"></a>RAC 常见宏</h2><h3 id="RAC-TARGET-KEYPATH-NIL-VALUE-…"><a href="#RAC-TARGET-KEYPATH-NIL-VALUE-…" class="headerlink" title="RAC(TARGET, [KEYPATH, [NIL_VALUE]]=…"></a>RAC(TARGET, [KEYPATH, [NIL_VALUE]]=…</h3><p>用于给某个对象的某个属性绑定信号。</p>
<pre><code class="objc">// 只要文本框文字改变，就会修改label的文字
RAC(self.label,text) = _textField.rac_textSignal;
</code></pre>
<h3 id="RACObserve-TARGET-KEYPATH"><a href="#RACObserve-TARGET-KEYPATH" class="headerlink" title="RACObserve(TARGET, [KEYPATH])"></a>RACObserve(TARGET, [KEYPATH])</h3><p>用于监听某个对象的某个属性,返回信号。</p>
<pre><code class="objc">[RACObserve(scrollView, contentOffset) subscribeNext:^(id x) {
        NSLog(x);
}];
</code></pre>
<h2 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h2><h3 id="映射-flattenMap-Map"><a href="#映射-flattenMap-Map" class="headerlink" title="映射 flattenMap,Map"></a>映射 flattenMap,Map</h3><p>用于把源信号内容映射成新的内容。<br>Map 使用：</p>
<ol>
<li>传入一个block,类型是返回对象，参数是value。</li>
<li>value就是源信号的内容，直接拿到源信号的内容做处理。</li>
<li>把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。</li>
</ol>
<pre><code class="objc">[[_textField.rac_textSignal map:^id(id value) {
        // 当源信号发出，就会调用这个block，修改源信号的内容
        // 返回值：就是处理完源信号的内容。
        return [NSString stringWithFormat:@&quot;输出:%@&quot;,value];
    }] subscribeNext:^(id x) {

        NSLog(@&quot;%@&quot;,x);
}];
</code></pre>
<h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>多个异步请求都完成后，再做某件事。<br>将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的 signal 至少都有过一次 <code>sendNext</code>，才会触发合并的信号。</p>
<pre><code class="objc">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

   [subscriber sendNext:@1];

   return nil;
}];

RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

   [subscriber sendNext:@2];

   return nil;
}];

// 把两个信号组合成一个信号,跟zip一样，没什么区别
RACSignal *combineSignal = [signalA combineLatestWith:signalB];

[combineSignal subscribeNext:^(id x) {

   NSLog(@&quot;%@&quot;,x);
}];
</code></pre>
<p>当组合信号被订阅，内部会自动订阅signalA、signalB，必须两个信号都发出内容，才会被触发。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>用于信号发出的内容是元组，把信号发出元组的值聚合成一个值。<br>常见用法：先组合再聚合。</p>
<pre><code class="objc">combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock  
RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

   [subscriber sendNext:@1];

   return nil;
}];

RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

   [subscriber sendNext:@2];

   return nil;
}];

// reduce中的block简介:
// reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容
// reduceblcok的返回值：聚合信号之后的内容。
RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2){

  return [NSString stringWithFormat:@&quot;%@ %@&quot;,num1,num2];

}];

[reduceSignal subscribeNext:^(id x) {

   NSLog(@&quot;%@&quot;,x);
}];
</code></pre>
<h1 id="实战：用-RAC-实现登录模块"><a href="#实战：用-RAC-实现登录模块" class="headerlink" title="实战：用 RAC 实现登录模块"></a>实战：用 RAC 实现登录模块</h1><p><img src="http://seuzl.qiniudn.com/md/1528982272205.gif" alt=""><br>如图是常见的一个登录需求，登录按钮在信息填写完整且符合规定前不可用，我们尝试用 RAC+MVVM 实现。项目结构如图：<br><img src="http://seuzl.qiniudn.com/md/1528982501723.png" alt=""></p>
<h2 id="model-层"><a href="#model-层" class="headerlink" title="model 层"></a>model 层</h2><pre><code class="objc">@interface User : NSObject

@property NSString  * user_id;
@property NSString  * access_token;
@property NSString  *phone_num;
@property NSString  *password;
@property BOOL      isLogin;

@end
</code></pre>
<h2 id="view-model-层"><a href="#view-model-层" class="headerlink" title="view-model 层"></a>view-model 层</h2><p><img src="http://seuzl.qiniudn.com/md/1528981796015.png" alt=""><br>MVVM 相比 MVC 多了 view-model 层，将原先 controller 层的大部分业务逻辑抽离出来，本案例主要涉及两个：</p>
<ol>
<li>判断是否允许登录</li>
<li>执行登录动作</li>
</ol>
<p>因此在 LoginViewModel 中设置两个信号。</p>
<pre><code class="objc">@interface LoginViewModel : NSObject

@property(nonatomic,strong) User *user;

//是否允许登录的信号
@property(nonatomic,strong,readonly) RACSignal *enableLoginSignal;
//执行登录操作的信号
@property(nonatomic,strong,readonly) RACCommand *loginCommand;

@end
</code></pre>
<h3 id="判断是否允许登录"><a href="#判断是否允许登录" class="headerlink" title="判断是否允许登录"></a>判断是否允许登录</h3><pre><code class="objc">//    监听账号的属性值改变，把它们聚合为一个信号。
_enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.user, phone_num),RACObserve(self.user, password)] reduce:^id(NSString *phone_num,NSString *password){

    NSPredicate *phoneNum_prdicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;^1[3|4|5|7|8][0-9]\\d{8}$&quot;];
    NSPredicate *pwd_predicate     = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,@&quot;^.{6,}$&quot;];
    return @([phoneNum_prdicate evaluateWithObject:phone_num] &amp;&amp; [pwd_predicate evaluateWithObject:password]);

}];
</code></pre>
<p>看得出来相比以前用<code>target-action</code>监听 textField 变化，再用<code>if...else</code>判断两个值是否都存在且合法，现在利用 RAC <code>conbine + reduce</code>处理信号，只需单个函数即可实现，代码清爽很多。</p>
<h3 id="执行登录动作"><a href="#执行登录动作" class="headerlink" title="执行登录动作"></a>执行登录动作</h3><pre><code class="objc">_loginCommand = [[RACCommand alloc]initWithSignalBlock:^RACSignal *(id input) {

    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        [User loginWithParameters:_user.mj_keyValues SuccessBlock:^(id returnValue) {

            User* newUser = [User mj_objectWithKeyValues:returnValue];
            _user.user_id      = newUser.user_id;
            _user.access_token = newUser.access_token;
            _user.isLogin      = YES;

            [subscriber sendNext:@&quot;success&quot;];
            [subscriber sendCompleted];

        } FailureBlock:^(NSError *error) {

            [subscriber sendNext:[NSString stringWithFormat:@&quot;登录失败!%@&quot;,error]];
            [subscriber sendCompleted];

        }];

        return nil;

    }];
}];
</code></pre>
<p>注意<code>raccommand</code>返回的需是一个信号，登录操作就在这里面，登录之后发送信号。<br><code>loginCommand</code>还可以监听登录状态。</p>
<pre><code class="objc">[[_loginCommand.executing skip:1]subscribeNext:^(id x) {

    if ([x isEqualToNumber:@(YES)]) {
        [Config showProgressHUDwithStatus:@&quot;登录中...&quot;];
    } else {
        [Config dismissHUD];
    }
}];
@end
</code></pre>
<h2 id="controller-层"><a href="#controller-层" class="headerlink" title="controller 层"></a>controller 层</h2><pre><code class="objc">@interface LoginVC : UIViewController

@property (strong, nonatomic) IBOutlet UITextField    *accountTextField;
@property (strong, nonatomic) IBOutlet UITextField    *pwdTextField;
@property (strong, nonatomic) IBOutlet UIButton       *loginBtn;
@property (strong,nonatomic ) LoginViewModel          *loginViewModel;

@end
</code></pre>
<h3 id="视图模型绑定"><a href="#视图模型绑定" class="headerlink" title="视图模型绑定"></a>视图模型绑定</h3><pre><code class="objc">// 给模型的属性绑定信号
// 账号文本框一改变，就给 User 属性赋值    
RAC(self.loginViewModel.user,phone_num) = _accountTextField.rac_textSignal;
RAC(self.loginViewModel.user,password)  = _pwdTextField.rac_textSignal;

// 为登录按钮的&quot;enable&quot;属性绑定信号
RAC(self.loginBtn,enabled)              = self.loginViewModel.enableLoginSignal;
</code></pre>
<h3 id="监听登录动作"><a href="#监听登录动作" class="headerlink" title="监听登录动作"></a>监听登录动作</h3><pre><code class="objc">// 监听登录按钮的点击,执行loginCommand
[[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside]subscribeNext:^(id x) {

// 执行登录
    [self.loginViewModel.loginCommand execute:nil];

}];
</code></pre>
<h3 id="监听登录结果"><a href="#监听登录结果" class="headerlink" title="监听登录结果"></a>监听登录结果</h3><p>订阅<code>loginCommand</code>返回的信号，如果返回 success 就存储登录信息。</p>
<pre><code class="objc">[self.loginViewModel.loginCommand.executionSignals.switchToLatest subscribeNext:^(NSString* x) {

    if ([x isEqualToString:@&quot;success&quot;]) {

//  存储用户信息及登录状态，此处不能使用 realm 作数据库,realm 不允许在 observer 中 addObject。

        NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];

        [defaults setValue:_loginViewModel.user.phone_num forKey:@&quot;phone_num&quot;];
        [defaults setValue:_loginViewModel.user.access_token forKey:@&quot;access_token&quot;];
        [defaults setValue:[NSNumber numberWithInteger:_loginViewModel.user.user_id] forKey:@&quot;user_id&quot;];
        [defaults setValue:[NSNumber numberWithBool:_loginViewModel.user.isLogin] forKey:@&quot;isLogin&quot;];
        [defaults synchronize];

        [self performSegueWithIdentifier:@&quot;toTabBarController&quot; sender:nil];

    }
}];
</code></pre>
<blockquote>
<p>上述登录代码可<a href="https://github.com/zltunes/CollegeLinkedin" target="_blank" rel="noopener">参考这里</a></p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://zltunes.github.io/2018/06/14/reactivecocoa-tutorial/" data-id="cjilgzi8400168rrklfsv99l1" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMUlEQVR42u3a226DQAwFwPz/T9PXSBRybNNULLNPEaVhh0ru+vJ6xWt7W+9X9p/39+9/ur/z6CkXLwwMjNsyttN1vq3kkQnp/AWd7w0DA+M5jPyrc1j0+Disf9gzBgYGxgEjv9LbIgYGBsb3A241icXAwMCoJrHVklx+z1dzcQwMjBsy8qr79z//SX8DAwPjVoytuKrBsbrFrbUwMDDWZlx17MsHJq4KuBgYGE9jTAJfNRnubS65goGBsTZjUrLPr/QOoMkxFAMDY21G3izsNQ+SzVXv/OVZGBgYD2NMRsGqhbb5mMVhwMXAwFiIMRmDmBTd5gfQUR6MgYFxK8a83TgPx9XC3OH/DQwMjEUZvQGIeYMzeSnlFBcDA2NRxlWdz0nwrYb7w78DBgbGooxe6zEvpfXCaDUcY2BgPIeR/FqhehcE2cI8SG9mBAMDYyFGr1VwntwmIbsXfDEwMJ7GmB/1qoW2yUjZYQKMgYGxNCMvjVUPZ5NyW7Uwh4GB8RxGnpQWTpfFlzIa+MDAwHgAI0k+e4lociisth8+HA0xMDCWZsyHJ3oNy174Hk18YGBg3ISxFVc+AJEfIvOC2oe/AwYGxqKMfOUDEL3xi2uLfRgYGOsx8lQzD5GTt9gr6mFgYDyBUS3oJ0W3/Bv+JBfHwMDAGB8Tk2/7h4CLgYGxBCNpWFYbA1VS1MLEwMBYjtEbieiNn1bT6YvLbRgYGDdk9M5dSXDMg2+V12xqYmBg3I/xA10tLLpIMioXAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a></div><div class="post-nav"><a class="pre" href="/2018/06/15/rails-tutorial/">使用 rails 打造简洁的 web app</a><a class="next" href="/2018/06/14/jspatch-swift/">iOS 热更新解读（三）—— JSPatch 之于 Swift</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjkyMi8xMzQ1OA=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://zltunes.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/换机/" style="font-size: 15px;">换机</a> <a href="/tags/通知/" style="font-size: 15px;">通知</a> <a href="/tags/Messages/" style="font-size: 15px;">Messages</a> <a href="/tags/JSPatch/" style="font-size: 15px;">JSPatch</a> <a href="/tags/iPhone/" style="font-size: 15px;">iPhone</a> <a href="/tags/动态化/" style="font-size: 15px;">动态化</a> <a href="/tags/rails/" style="font-size: 15px;">rails</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/ROS/" style="font-size: 15px;">ROS</a> <a href="/tags/机器人/" style="font-size: 15px;">机器人</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/15/rails-tutorial/">使用 rails 打造简洁的 web app</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/reactivecocoa-tutorial/">ReactiveCocoa 入门与登录实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/jspatch-swift/">iOS 热更新解读（三）—— JSPatch 之于 Swift</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/jspatch-sourcecode/">iOS 热更新解读（二）—— JSPatch 源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/jspatch-apatch&javascriptcore/">iOS 热更新解读（一）APatch & JavaScriptCore</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/ios-android-transfer/">iPhone & Android 换机通信方案分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/ios10-notification/">iOS 10 通知更新详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/ios10-messages-framework/">iOS 10 之 Messages framework</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/iosapp-certificate-signature/">iOS 程序证书及签名机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/robot-operating-system-intro/">机器人操作系统（ROS/Android）对比</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://dreampiggy.com/" title="小猪的博客" target="_blank">小猪的博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">zltunes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>